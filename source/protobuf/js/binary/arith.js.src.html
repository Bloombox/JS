<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>arith.js</title><link href="../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;arith.js&quot;,&quot;protobuf/js/binary/arith.js&quot;,[&quot;// Protocol Buffers - Google&#39;s data interchange format&quot;,&quot;// Copyright 2008 Google Inc.  All rights reserved.&quot;,&quot;// https://developers.google.com/protocol-buffers/&quot;,&quot;//&quot;,&quot;// Redistribution and use in source and binary forms, with or without&quot;,&quot;// modification, are permitted provided that the following conditions are&quot;,&quot;// met:&quot;,&quot;//&quot;,&quot;//     * Redistributions of source code must retain the above copyright&quot;,&quot;// notice, this list of conditions and the following disclaimer.&quot;,&quot;//     * Redistributions in binary form must reproduce the above&quot;,&quot;// copyright notice, this list of conditions and the following disclaimer&quot;,&quot;// in the documentation and/or other materials provided with the&quot;,&quot;// distribution.&quot;,&quot;//     * Neither the name of Google Inc. nor the names of its&quot;,&quot;// contributors may be used to endorse or promote products derived from&quot;,&quot;// this software without specific prior written permission.&quot;,&quot;//&quot;,&quot;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;,&quot;// \&quot;AS IS\&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR&quot;,&quot;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&quot;,&quot;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&quot;,&quot;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,&quot;,&quot;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY&quot;,&quot;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&quot;,&quot;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&quot;,&quot;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview This file contains helper code used by jspb.utils to&quot;,&quot; * handle 64-bit integer conversion to/from strings.&quot;,&quot; *&quot;,&quot; * @author cfallin@google.com (Chris Fallin)&quot;,&quot; *&quot;,&quot; * TODO(haberman): move this to javascript/closure/math?&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;jspb.arith.Int64&#39;);&quot;,&quot;goog.provide(&#39;jspb.arith.UInt64&#39;);&quot;,null,&quot;/**&quot;,&quot; * UInt64 implements some 64-bit arithmetic routines necessary for properly&quot;,&quot; * handling 64-bit integer fields. It implements lossless integer arithmetic on&quot;,&quot; * top of JavaScript&#39;s number type, which has only 53 bits of precision, by&quot;,&quot; * representing 64-bit integers as two 32-bit halves.&quot;,&quot; *&quot;,&quot; * @param {number} lo The low 32 bits.&quot;,&quot; * @param {number} hi The high 32 bits.&quot;,&quot; * @constructor&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64 = function(lo, hi) {&quot;,&quot;  /**&quot;,&quot;   * The low 32 bits.&quot;,&quot;   * @public {number}&quot;,&quot;   */&quot;,&quot;  this.lo = lo;&quot;,&quot;  /**&quot;,&quot;   * The high 32 bits.&quot;,&quot;   * @public {number}&quot;,&quot;   */&quot;,&quot;  this.hi = hi;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Compare two 64-bit numbers. Returns -1 if the first is&quot;,&quot; * less, +1 if the first is greater, or 0 if both are equal.&quot;,&quot; * @param {!jspb.arith.UInt64} other&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.prototype.cmp = function(other) {&quot;,&quot;  if (this.hi &lt; other.hi || (this.hi == other.hi &amp;&amp; this.lo &lt; other.lo)) {&quot;,&quot;    return -1;&quot;,&quot;  } else if (this.hi == other.hi &amp;&amp; this.lo == other.lo) {&quot;,&quot;    return 0;&quot;,&quot;  } else {&quot;,&quot;    return 1;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Right-shift this number by one bit.&quot;,&quot; * @return {!jspb.arith.UInt64}&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.prototype.rightShift = function() {&quot;,&quot;  var hi = this.hi &gt;&gt;&gt; 1;&quot;,&quot;  var lo = (this.lo &gt;&gt;&gt; 1) | ((this.hi &amp; 1) &lt;&lt; 31);&quot;,&quot;  return new jspb.arith.UInt64(lo &gt;&gt;&gt; 0, hi &gt;&gt;&gt; 0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Left-shift this number by one bit.&quot;,&quot; * @return {!jspb.arith.UInt64}&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.prototype.leftShift = function() {&quot;,&quot;  var lo = this.lo &lt;&lt; 1;&quot;,&quot;  var hi = (this.hi &lt;&lt; 1) | (this.lo &gt;&gt;&gt; 31);&quot;,&quot;  return new jspb.arith.UInt64(lo &gt;&gt;&gt; 0, hi &gt;&gt;&gt; 0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Test the MSB.&quot;,&quot; * @return {boolean}&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.prototype.msb = function() {&quot;,&quot;  return !!(this.hi &amp; 0x80000000);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Test the LSB.&quot;,&quot; * @return {boolean}&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.prototype.lsb = function() {&quot;,&quot;  return !!(this.lo &amp; 1);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Test whether this number is zero.&quot;,&quot; * @return {boolean}&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.prototype.zero = function() {&quot;,&quot;  return this.lo == 0 &amp;&amp; this.hi == 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Add two 64-bit numbers to produce a 64-bit number.&quot;,&quot; * @param {!jspb.arith.UInt64} other&quot;,&quot; * @return {!jspb.arith.UInt64}&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.prototype.add = function(other) {&quot;,&quot;  var lo = ((this.lo + other.lo) &amp; 0xffffffff) &gt;&gt;&gt; 0;&quot;,&quot;  var hi =&quot;,&quot;      (((this.hi + other.hi) &amp; 0xffffffff) &gt;&gt;&gt; 0) +&quot;,&quot;      (((this.lo + other.lo) &gt;= 0x100000000) ? 1 : 0);&quot;,&quot;  return new jspb.arith.UInt64(lo &gt;&gt;&gt; 0, hi &gt;&gt;&gt; 0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Subtract two 64-bit numbers to produce a 64-bit number.&quot;,&quot; * @param {!jspb.arith.UInt64} other&quot;,&quot; * @return {!jspb.arith.UInt64}&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.prototype.sub = function(other) {&quot;,&quot;  var lo = ((this.lo - other.lo) &amp; 0xffffffff) &gt;&gt;&gt; 0;&quot;,&quot;  var hi =&quot;,&quot;      (((this.hi - other.hi) &amp; 0xffffffff) &gt;&gt;&gt; 0) -&quot;,&quot;      (((this.lo - other.lo) &lt; 0) ? 1 : 0);&quot;,&quot;  return new jspb.arith.UInt64(lo &gt;&gt;&gt; 0, hi &gt;&gt;&gt; 0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Multiply two 32-bit numbers to produce a 64-bit number.&quot;,&quot; * @param {number} a The first integer:  must be in [0, 2^32-1).&quot;,&quot; * @param {number} b The second integer: must be in [0, 2^32-1).&quot;,&quot; * @return {!jspb.arith.UInt64}&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.mul32x32 = function(a, b) {&quot;,&quot;  // Directly multiplying two 32-bit numbers may produce up to 64 bits of&quot;,&quot;  // precision, thus losing precision because of the 53-bit mantissa of&quot;,&quot;  // JavaScript numbers. So we multiply with 16-bit digits (radix 65536)&quot;,&quot;  // instead.&quot;,&quot;  var aLow = (a &amp; 0xffff);&quot;,&quot;  var aHigh = (a &gt;&gt;&gt; 16);&quot;,&quot;  var bLow = (b &amp; 0xffff);&quot;,&quot;  var bHigh = (b &gt;&gt;&gt; 16);&quot;,&quot;  var productLow =&quot;,&quot;      // 32-bit result, result bits 0-31, take all 32 bits&quot;,&quot;      (aLow * bLow) +&quot;,&quot;      // 32-bit result, result bits 16-47, take bottom 16 as our top 16&quot;,&quot;      ((aLow * bHigh) &amp; 0xffff) * 0x10000 +&quot;,&quot;      // 32-bit result, result bits 16-47, take bottom 16 as our top 16&quot;,&quot;      ((aHigh * bLow) &amp; 0xffff) * 0x10000;&quot;,&quot;  var productHigh =&quot;,&quot;      // 32-bit result, result bits 32-63, take all 32 bits&quot;,&quot;      (aHigh * bHigh) +&quot;,&quot;      // 32-bit result, result bits 16-47, take top 16 as our bottom 16&quot;,&quot;      ((aLow * bHigh) &gt;&gt;&gt; 16) +&quot;,&quot;      // 32-bit result, result bits 16-47, take top 16 as our bottom 16&quot;,&quot;      ((aHigh * bLow) &gt;&gt;&gt; 16);&quot;,null,&quot;  // Carry. Note that we actually have up to *two* carries due to addition of&quot;,&quot;  // three terms.&quot;,&quot;  while (productLow &gt;= 0x100000000) {&quot;,&quot;    productLow -= 0x100000000;&quot;,&quot;    productHigh += 1;&quot;,&quot;  }&quot;,null,&quot;  return new jspb.arith.UInt64(productLow &gt;&gt;&gt; 0, productHigh &gt;&gt;&gt; 0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Multiply this number by a 32-bit number, producing a 96-bit number, then&quot;,&quot; * truncate the top 32 bits.&quot;,&quot; * @param {number} a The multiplier.&quot;,&quot; * @return {!jspb.arith.UInt64}&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.prototype.mul = function(a) {&quot;,&quot;  // Produce two parts: at bits 0-63, and 32-95.&quot;,&quot;  var lo = jspb.arith.UInt64.mul32x32(this.lo, a);&quot;,&quot;  var hi = jspb.arith.UInt64.mul32x32(this.hi, a);&quot;,&quot;  // Left-shift hi by 32 bits, truncating its top bits. The parts will then be&quot;,&quot;  // aligned for addition.&quot;,&quot;  hi.hi = hi.lo;&quot;,&quot;  hi.lo = 0;&quot;,&quot;  return lo.add(hi);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Divide a 64-bit number by a 32-bit number to produce a&quot;,&quot; * 64-bit quotient and a 32-bit remainder.&quot;,&quot; * @param {number} _divisor&quot;,&quot; * @return {Array&lt;jspb.arith.UInt64&gt;} array of [quotient, remainder],&quot;,&quot; * unless divisor is 0, in which case an empty array is returned.&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.prototype.div = function(_divisor) {&quot;,&quot;  if (_divisor == 0) {&quot;,&quot;    return [];&quot;,&quot;  }&quot;,null,&quot;  // We perform long division using a radix-2 algorithm, for simplicity (i.e.,&quot;,&quot;  // one bit at a time). TODO: optimize to a radix-2^32 algorithm, taking care&quot;,&quot;  // to get the variable shifts right.&quot;,&quot;  var quotient = new jspb.arith.UInt64(0, 0);&quot;,&quot;  var remainder = new jspb.arith.UInt64(this.lo, this.hi);&quot;,&quot;  var divisor = new jspb.arith.UInt64(_divisor, 0);&quot;,&quot;  var unit = new jspb.arith.UInt64(1, 0);&quot;,null,&quot;  // Left-shift the divisor and unit until the high bit of divisor is set.&quot;,&quot;  while (!divisor.msb()) {&quot;,&quot;    divisor = divisor.leftShift();&quot;,&quot;    unit = unit.leftShift();&quot;,&quot;  }&quot;,null,&quot;  // Perform long division one bit at a time.&quot;,&quot;  while (!unit.zero()) {&quot;,&quot;    // If divisor &lt; remainder, add unit to quotient and subtract divisor from&quot;,&quot;    // remainder.&quot;,&quot;    if (divisor.cmp(remainder) &lt;= 0) {&quot;,&quot;      quotient = quotient.add(unit);&quot;,&quot;      remainder = remainder.sub(divisor);&quot;,&quot;    }&quot;,&quot;    // Right-shift the divisor and unit.&quot;,&quot;    divisor = divisor.rightShift();&quot;,&quot;    unit = unit.rightShift();&quot;,&quot;  }&quot;,null,&quot;  return [quotient, remainder];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Convert a 64-bit number to a string.&quot;,&quot; * @return {string}&quot;,&quot; * @override&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.prototype.toString = function() {&quot;,&quot;  var result = &#39;&#39;;&quot;,&quot;  var num = this;&quot;,&quot;  while (!num.zero()) {&quot;,&quot;    var divResult = num.div(10);&quot;,&quot;    var quotient = divResult[0], remainder = divResult[1];&quot;,&quot;    result = remainder.lo + result;&quot;,&quot;    num = quotient;&quot;,&quot;  }&quot;,&quot;  if (result == &#39;&#39;) {&quot;,&quot;    result = &#39;0&#39;;&quot;,&quot;  }&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Parse a string into a 64-bit number. Returns `null` on a parse error.&quot;,&quot; * @param {string} s&quot;,&quot; * @return {?jspb.arith.UInt64}&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.fromString = function(s) {&quot;,&quot;  var result = new jspb.arith.UInt64(0, 0);&quot;,&quot;  // optimization: reuse this instance for each digit.&quot;,&quot;  var digit64 = new jspb.arith.UInt64(0, 0);&quot;,&quot;  for (var i = 0; i &lt; s.length; i++) {&quot;,&quot;    if (s[i] &lt; &#39;0&#39; || s[i] &gt; &#39;9&#39;) {&quot;,&quot;      return null;&quot;,&quot;    }&quot;,&quot;    var digit = parseInt(s[i], 10);&quot;,&quot;    digit64.lo = digit;&quot;,&quot;    result = result.mul(10).add(digit64);&quot;,&quot;  }&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Make a copy of the uint64.&quot;,&quot; * @return {!jspb.arith.UInt64}&quot;,&quot; */&quot;,&quot;jspb.arith.UInt64.prototype.clone = function() {&quot;,&quot;  return new jspb.arith.UInt64(this.lo, this.hi);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Int64 is like UInt64, but modifies string conversions to interpret the stored&quot;,&quot; * 64-bit value as a twos-complement-signed integer. It does *not* support the&quot;,&quot; * full range of operations that UInt64 does: only add, subtract, and string&quot;,&quot; * conversions.&quot;,&quot; *&quot;,&quot; * N.B. that multiply and divide routines are *NOT* supported. They will throw&quot;,&quot; * exceptions. (They are not necessary to implement string conversions, which&quot;,&quot; * are the only operations we really need in jspb.)&quot;,&quot; *&quot;,&quot; * @param {number} lo The low 32 bits.&quot;,&quot; * @param {number} hi The high 32 bits.&quot;,&quot; * @constructor&quot;,&quot; */&quot;,&quot;jspb.arith.Int64 = function(lo, hi) {&quot;,&quot;  /**&quot;,&quot;   * The low 32 bits.&quot;,&quot;   * @public {number}&quot;,&quot;   */&quot;,&quot;  this.lo = lo;&quot;,&quot;  /**&quot;,&quot;   * The high 32 bits.&quot;,&quot;   * @public {number}&quot;,&quot;   */&quot;,&quot;  this.hi = hi;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Add two 64-bit numbers to produce a 64-bit number.&quot;,&quot; * @param {!jspb.arith.Int64} other&quot;,&quot; * @return {!jspb.arith.Int64}&quot;,&quot; */&quot;,&quot;jspb.arith.Int64.prototype.add = function(other) {&quot;,&quot;  var lo = ((this.lo + other.lo) &amp; 0xffffffff) &gt;&gt;&gt; 0;&quot;,&quot;  var hi =&quot;,&quot;      (((this.hi + other.hi) &amp; 0xffffffff) &gt;&gt;&gt; 0) +&quot;,&quot;      (((this.lo + other.lo) &gt;= 0x100000000) ? 1 : 0);&quot;,&quot;  return new jspb.arith.Int64(lo &gt;&gt;&gt; 0, hi &gt;&gt;&gt; 0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Subtract two 64-bit numbers to produce a 64-bit number.&quot;,&quot; * @param {!jspb.arith.Int64} other&quot;,&quot; * @return {!jspb.arith.Int64}&quot;,&quot; */&quot;,&quot;jspb.arith.Int64.prototype.sub = function(other) {&quot;,&quot;  var lo = ((this.lo - other.lo) &amp; 0xffffffff) &gt;&gt;&gt; 0;&quot;,&quot;  var hi =&quot;,&quot;      (((this.hi - other.hi) &amp; 0xffffffff) &gt;&gt;&gt; 0) -&quot;,&quot;      (((this.lo - other.lo) &lt; 0) ? 1 : 0);&quot;,&quot;  return new jspb.arith.Int64(lo &gt;&gt;&gt; 0, hi &gt;&gt;&gt; 0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Make a copy of the int64.&quot;,&quot; * @return {!jspb.arith.Int64}&quot;,&quot; */&quot;,&quot;jspb.arith.Int64.prototype.clone = function() {&quot;,&quot;  return new jspb.arith.Int64(this.lo, this.hi);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Convert a 64-bit number to a string.&quot;,&quot; * @return {string}&quot;,&quot; * @override&quot;,&quot; */&quot;,&quot;jspb.arith.Int64.prototype.toString = function() {&quot;,&quot;  // If the number is negative, find its twos-complement inverse.&quot;,&quot;  var sign = (this.hi &amp; 0x80000000) != 0;&quot;,&quot;  var num = new jspb.arith.UInt64(this.lo, this.hi);&quot;,&quot;  if (sign) {&quot;,&quot;    num = new jspb.arith.UInt64(0, 0).sub(num);&quot;,&quot;  }&quot;,&quot;  return (sign ? &#39;-&#39; : &#39;&#39;) + num.toString();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Parse a string into a 64-bit number. Returns `null` on a parse error.&quot;,&quot; * @param {string} s&quot;,&quot; * @return {?jspb.arith.Int64}&quot;,&quot; */&quot;,&quot;jspb.arith.Int64.fromString = function(s) {&quot;,&quot;  var hasNegative = (s.length &gt; 0 &amp;&amp; s[0] == &#39;-&#39;);&quot;,&quot;  if (hasNegative) {&quot;,&quot;    s = s.substring(1);&quot;,&quot;  }&quot;,&quot;  var num = jspb.arith.UInt64.fromString(s);&quot;,&quot;  if (num === null) {&quot;,&quot;    return null;&quot;,&quot;  }&quot;,&quot;  if (hasNegative) {&quot;,&quot;    num = new jspb.arith.UInt64(0, 0).sub(num);&quot;,&quot;  }&quot;,&quot;  return new jspb.arith.Int64(num.lo, num.hi);&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../dossier.js" defer></script>