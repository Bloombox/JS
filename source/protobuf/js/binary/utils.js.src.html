<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>utils.js</title><link href="../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;utils.js&quot;,&quot;protobuf/js/binary/utils.js&quot;,[&quot;// Protocol Buffers - Google&#39;s data interchange format&quot;,&quot;// Copyright 2008 Google Inc.  All rights reserved.&quot;,&quot;// https://developers.google.com/protocol-buffers/&quot;,&quot;//&quot;,&quot;// Redistribution and use in source and binary forms, with or without&quot;,&quot;// modification, are permitted provided that the following conditions are&quot;,&quot;// met:&quot;,&quot;//&quot;,&quot;//     * Redistributions of source code must retain the above copyright&quot;,&quot;// notice, this list of conditions and the following disclaimer.&quot;,&quot;//     * Redistributions in binary form must reproduce the above&quot;,&quot;// copyright notice, this list of conditions and the following disclaimer&quot;,&quot;// in the documentation and/or other materials provided with the&quot;,&quot;// distribution.&quot;,&quot;//     * Neither the name of Google Inc. nor the names of its&quot;,&quot;// contributors may be used to endorse or promote products derived from&quot;,&quot;// this software without specific prior written permission.&quot;,&quot;//&quot;,&quot;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;,&quot;// \&quot;AS IS\&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR&quot;,&quot;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&quot;,&quot;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&quot;,&quot;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,&quot;,&quot;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY&quot;,&quot;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&quot;,&quot;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&quot;,&quot;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview This file contains helper code used by jspb.BinaryReader&quot;,&quot; * and BinaryWriter.&quot;,&quot; *&quot;,&quot; * @author aappleby@google.com (Austin Appleby)&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;jspb.utils&#39;);&quot;,null,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;goog.crypt&#39;);&quot;,&quot;goog.require(&#39;goog.crypt.base64&#39;);&quot;,&quot;goog.require(&#39;goog.string&#39;);&quot;,&quot;goog.require(&#39;jspb.BinaryConstants&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * Javascript can&#39;t natively handle 64-bit data types, so to manipulate them we&quot;,&quot; * have to split them into two 32-bit halves and do the math manually.&quot;,&quot; *&quot;,&quot; * Instead of instantiating and passing small structures around to do this, we&quot;,&quot; * instead just use two global temporary values. This one stores the low 32&quot;,&quot; * bits of a split value - for example, if the original value was a 64-bit&quot;,&quot; * integer, this temporary value will contain the low 32 bits of that integer.&quot;,&quot; * If the original value was a double, this temporary value will contain the&quot;,&quot; * low 32 bits of the binary representation of that double, etcetera.&quot;,&quot; * @type {number}&quot;,&quot; */&quot;,&quot;jspb.utils.split64Low = 0;&quot;,null,null,&quot;/**&quot;,&quot; * And correspondingly, this temporary variable will contain the high 32 bits&quot;,&quot; * of whatever value was split.&quot;,&quot; * @type {number}&quot;,&quot; */&quot;,&quot;jspb.utils.split64High = 0;&quot;,null,null,&quot;/**&quot;,&quot; * Splits an unsigned Javascript integer into two 32-bit halves and stores it&quot;,&quot; * in the temp values above.&quot;,&quot; * @param {number} value The number to split.&quot;,&quot; */&quot;,&quot;jspb.utils.splitUint64 = function(value) {&quot;,&quot;  // Extract low 32 bits and high 32 bits as unsigned integers.&quot;,&quot;  var lowBits = value &gt;&gt;&gt; 0;&quot;,&quot;  var highBits = Math.floor((value - lowBits) /&quot;,&quot;                            jspb.BinaryConstants.TWO_TO_32) &gt;&gt;&gt; 0;&quot;,null,&quot;  jspb.utils.split64Low = lowBits;&quot;,&quot;  jspb.utils.split64High = highBits;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Splits a signed Javascript integer into two 32-bit halves and stores it in&quot;,&quot; * the temp values above.&quot;,&quot; * @param {number} value The number to split.&quot;,&quot; */&quot;,&quot;jspb.utils.splitInt64 = function(value) {&quot;,&quot;  // Convert to sign-magnitude representation.&quot;,&quot;  var sign = (value &lt; 0);&quot;,&quot;  value = Math.abs(value);&quot;,null,&quot;  // Extract low 32 bits and high 32 bits as unsigned integers.&quot;,&quot;  var lowBits = value &gt;&gt;&gt; 0;&quot;,&quot;  var highBits = Math.floor((value - lowBits) /&quot;,&quot;                            jspb.BinaryConstants.TWO_TO_32);&quot;,&quot;  highBits = highBits &gt;&gt;&gt; 0;&quot;,null,&quot;  // Perform two&#39;s complement conversion if the sign bit was set.&quot;,&quot;  if (sign) {&quot;,&quot;    highBits = ~highBits &gt;&gt;&gt; 0;&quot;,&quot;    lowBits = ~lowBits &gt;&gt;&gt; 0;&quot;,&quot;    lowBits += 1;&quot;,&quot;    if (lowBits &gt; 0xFFFFFFFF) {&quot;,&quot;      lowBits = 0;&quot;,&quot;      highBits++;&quot;,&quot;      if (highBits &gt; 0xFFFFFFFF) highBits = 0;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  jspb.utils.split64Low = lowBits;&quot;,&quot;  jspb.utils.split64High = highBits;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Convers a signed Javascript integer into zigzag format, splits it into two&quot;,&quot; * 32-bit halves, and stores it in the temp values above.&quot;,&quot; * @param {number} value The number to split.&quot;,&quot; */&quot;,&quot;jspb.utils.splitZigzag64 = function(value) {&quot;,&quot;  // Convert to sign-magnitude and scale by 2 before we split the value.&quot;,&quot;  var sign = (value &lt; 0);&quot;,&quot;  value = Math.abs(value) * 2;&quot;,null,&quot;  jspb.utils.splitUint64(value);&quot;,&quot;  var lowBits = jspb.utils.split64Low;&quot;,&quot;  var highBits = jspb.utils.split64High;&quot;,null,&quot;  // If the value is negative, subtract 1 from the split representation so we&quot;,&quot;  // don&#39;t lose the sign bit due to precision issues.&quot;,&quot;  if (sign) {&quot;,&quot;    if (lowBits == 0) {&quot;,&quot;      if (highBits == 0) {&quot;,&quot;        lowBits = 0xFFFFFFFF;&quot;,&quot;        highBits = 0xFFFFFFFF;&quot;,&quot;      } else {&quot;,&quot;        highBits--;&quot;,&quot;        lowBits = 0xFFFFFFFF;&quot;,&quot;      }&quot;,&quot;    } else {&quot;,&quot;      lowBits--;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  jspb.utils.split64Low = lowBits;&quot;,&quot;  jspb.utils.split64High = highBits;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a floating-point number into 32-bit IEEE representation and stores&quot;,&quot; * it in the temp values above.&quot;,&quot; * @param {number} value&quot;,&quot; */&quot;,&quot;jspb.utils.splitFloat32 = function(value) {&quot;,&quot;  var sign = (value &lt; 0) ? 1 : 0;&quot;,&quot;  value = sign ? -value : value;&quot;,&quot;  var exp;&quot;,&quot;  var mant;&quot;,null,&quot;  // Handle zeros.&quot;,&quot;  if (value === 0) {&quot;,&quot;    if ((1 / value) &gt; 0) {&quot;,&quot;      // Positive zero.&quot;,&quot;      jspb.utils.split64High = 0;&quot;,&quot;      jspb.utils.split64Low = 0x00000000;&quot;,&quot;    } else {&quot;,&quot;      // Negative zero.&quot;,&quot;      jspb.utils.split64High = 0;&quot;,&quot;      jspb.utils.split64Low = 0x80000000;&quot;,&quot;    }&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  // Handle nans.&quot;,&quot;  if (isNaN(value)) {&quot;,&quot;    jspb.utils.split64High = 0;&quot;,&quot;    jspb.utils.split64Low = 0x7FFFFFFF;&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  // Handle infinities.&quot;,&quot;  if (value &gt; jspb.BinaryConstants.FLOAT32_MAX) {&quot;,&quot;    jspb.utils.split64High = 0;&quot;,&quot;    jspb.utils.split64Low = ((sign &lt;&lt; 31) | (0x7F800000)) &gt;&gt;&gt; 0;&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  // Handle denormals.&quot;,&quot;  if (value &lt; jspb.BinaryConstants.FLOAT32_MIN) {&quot;,&quot;    // Number is a denormal.&quot;,&quot;    mant = Math.round(value / Math.pow(2, -149));&quot;,&quot;    jspb.utils.split64High = 0;&quot;,&quot;    jspb.utils.split64Low = ((sign &lt;&lt; 31) | mant) &gt;&gt;&gt; 0;&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  exp = Math.floor(Math.log(value) / Math.LN2);&quot;,&quot;  mant = value * Math.pow(2, -exp);&quot;,&quot;  mant = Math.round(mant * jspb.BinaryConstants.TWO_TO_23) &amp; 0x7FFFFF;&quot;,null,&quot;  jspb.utils.split64High = 0;&quot;,&quot;  jspb.utils.split64Low = ((sign &lt;&lt; 31) | ((exp + 127) &lt;&lt; 23) | mant) &gt;&gt;&gt; 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a floating-point number into 64-bit IEEE representation and stores&quot;,&quot; * it in the temp values above.&quot;,&quot; * @param {number} value&quot;,&quot; */&quot;,&quot;jspb.utils.splitFloat64 = function(value) {&quot;,&quot;  var sign = (value &lt; 0) ? 1 : 0;&quot;,&quot;  value = sign ? -value : value;&quot;,null,&quot;  // Handle zeros.&quot;,&quot;  if (value === 0) {&quot;,&quot;    if ((1 / value) &gt; 0) {&quot;,&quot;      // Positive zero.&quot;,&quot;      jspb.utils.split64High = 0x00000000;&quot;,&quot;      jspb.utils.split64Low = 0x00000000;&quot;,&quot;    } else {&quot;,&quot;      // Negative zero.&quot;,&quot;      jspb.utils.split64High = 0x80000000;&quot;,&quot;      jspb.utils.split64Low = 0x00000000;&quot;,&quot;    }&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  // Handle nans.&quot;,&quot;  if (isNaN(value)) {&quot;,&quot;    jspb.utils.split64High = 0x7FFFFFFF;&quot;,&quot;    jspb.utils.split64Low = 0xFFFFFFFF;&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  // Handle infinities.&quot;,&quot;  if (value &gt; jspb.BinaryConstants.FLOAT64_MAX) {&quot;,&quot;    jspb.utils.split64High = ((sign &lt;&lt; 31) | (0x7FF00000)) &gt;&gt;&gt; 0;&quot;,&quot;    jspb.utils.split64Low = 0;&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  // Handle denormals.&quot;,&quot;  if (value &lt; jspb.BinaryConstants.FLOAT64_MIN) {&quot;,&quot;    // Number is a denormal.&quot;,&quot;    var mant = value / Math.pow(2, -1074);&quot;,&quot;    var mantHigh = (mant / jspb.BinaryConstants.TWO_TO_32);&quot;,&quot;    jspb.utils.split64High = ((sign &lt;&lt; 31) | mantHigh) &gt;&gt;&gt; 0;&quot;,&quot;    jspb.utils.split64Low = (mant &gt;&gt;&gt; 0);&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  var exp = Math.floor(Math.log(value) / Math.LN2);&quot;,&quot;  if (exp == 1024) exp = 1023;&quot;,&quot;  var mant = value * Math.pow(2, -exp);&quot;,null,&quot;  var mantHigh = (mant * jspb.BinaryConstants.TWO_TO_20) &amp; 0xFFFFF;&quot;,&quot;  var mantLow = (mant * jspb.BinaryConstants.TWO_TO_52) &gt;&gt;&gt; 0;&quot;,null,&quot;  jspb.utils.split64High =&quot;,&quot;      ((sign &lt;&lt; 31) | ((exp + 1023) &lt;&lt; 20) | mantHigh) &gt;&gt;&gt; 0;&quot;,&quot;  jspb.utils.split64Low = mantLow;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts an 8-character hash string into two 32-bit numbers and stores them&quot;,&quot; * in the temp values above.&quot;,&quot; * @param {string} hash&quot;,&quot; */&quot;,&quot;jspb.utils.splitHash64 = function(hash) {&quot;,&quot;  var a = hash.charCodeAt(0);&quot;,&quot;  var b = hash.charCodeAt(1);&quot;,&quot;  var c = hash.charCodeAt(2);&quot;,&quot;  var d = hash.charCodeAt(3);&quot;,&quot;  var e = hash.charCodeAt(4);&quot;,&quot;  var f = hash.charCodeAt(5);&quot;,&quot;  var g = hash.charCodeAt(6);&quot;,&quot;  var h = hash.charCodeAt(7);&quot;,null,&quot;  jspb.utils.split64Low = (a + (b &lt;&lt; 8) + (c &lt;&lt; 16) + (d &lt;&lt; 24)) &gt;&gt;&gt; 0;&quot;,&quot;  jspb.utils.split64High = (e + (f &lt;&lt; 8) + (g &lt;&lt; 16) + (h &lt;&lt; 24)) &gt;&gt;&gt; 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Joins two 32-bit values into a 64-bit unsigned integer. Precision will be&quot;,&quot; * lost if the result is greater than 2^52.&quot;,&quot; * @param {number} bitsLow&quot;,&quot; * @param {number} bitsHigh&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;jspb.utils.joinUint64 = function(bitsLow, bitsHigh) {&quot;,&quot;  return bitsHigh * jspb.BinaryConstants.TWO_TO_32 + bitsLow;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Joins two 32-bit values into a 64-bit signed integer. Precision will be lost&quot;,&quot; * if the result is greater than 2^52.&quot;,&quot; * @param {number} bitsLow&quot;,&quot; * @param {number} bitsHigh&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;jspb.utils.joinInt64 = function(bitsLow, bitsHigh) {&quot;,&quot;  // If the high bit is set, do a manual two&#39;s complement conversion.&quot;,&quot;  var sign = (bitsHigh &amp; 0x80000000);&quot;,&quot;  if (sign) {&quot;,&quot;    bitsLow = (~bitsLow + 1) &gt;&gt;&gt; 0;&quot;,&quot;    bitsHigh = ~bitsHigh &gt;&gt;&gt; 0;&quot;,&quot;    if (bitsLow == 0) {&quot;,&quot;      bitsHigh = (bitsHigh + 1) &gt;&gt;&gt; 0;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  var result = jspb.utils.joinUint64(bitsLow, bitsHigh);&quot;,&quot;  return sign ? -result : result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Joins two 32-bit values into a 64-bit unsigned integer and applies zigzag&quot;,&quot; * decoding. Precision will be lost if the result is greater than 2^52.&quot;,&quot; * @param {number} bitsLow&quot;,&quot; * @param {number} bitsHigh&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;jspb.utils.joinZigzag64 = function(bitsLow, bitsHigh) {&quot;,&quot;  // Extract the sign bit and shift right by one.&quot;,&quot;  var sign = bitsLow &amp; 1;&quot;,&quot;  bitsLow = ((bitsLow &gt;&gt;&gt; 1) | (bitsHigh &lt;&lt; 31)) &gt;&gt;&gt; 0;&quot;,&quot;  bitsHigh = bitsHigh &gt;&gt;&gt; 1;&quot;,null,&quot;  // Increment the split value if the sign bit was set.&quot;,&quot;  if (sign) {&quot;,&quot;    bitsLow = (bitsLow + 1) &gt;&gt;&gt; 0;&quot;,&quot;    if (bitsLow == 0) {&quot;,&quot;      bitsHigh = (bitsHigh + 1) &gt;&gt;&gt; 0;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  var result = jspb.utils.joinUint64(bitsLow, bitsHigh);&quot;,&quot;  return sign ? -result : result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Joins two 32-bit values into a 32-bit IEEE floating point number and&quot;,&quot; * converts it back into a Javascript number.&quot;,&quot; * @param {number} bitsLow The low 32 bits of the binary number;&quot;,&quot; * @param {number} bitsHigh The high 32 bits of the binary number.&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;jspb.utils.joinFloat32 = function(bitsLow, bitsHigh) {&quot;,&quot;  var sign = ((bitsLow &gt;&gt; 31) * 2 + 1);&quot;,&quot;  var exp = (bitsLow &gt;&gt;&gt; 23) &amp; 0xFF;&quot;,&quot;  var mant = bitsLow &amp; 0x7FFFFF;&quot;,null,&quot;  if (exp == 0xFF) {&quot;,&quot;    if (mant) {&quot;,&quot;      return NaN;&quot;,&quot;    } else {&quot;,&quot;      return sign * Infinity;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  if (exp == 0) {&quot;,&quot;    // Denormal.&quot;,&quot;    return sign * Math.pow(2, -149) * mant;&quot;,&quot;  } else {&quot;,&quot;    return sign * Math.pow(2, exp - 150) *&quot;,&quot;           (mant + Math.pow(2, 23));&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Joins two 32-bit values into a 64-bit IEEE floating point number and&quot;,&quot; * converts it back into a Javascript number.&quot;,&quot; * @param {number} bitsLow The low 32 bits of the binary number;&quot;,&quot; * @param {number} bitsHigh The high 32 bits of the binary number.&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;jspb.utils.joinFloat64 = function(bitsLow, bitsHigh) {&quot;,&quot;  var sign = ((bitsHigh &gt;&gt; 31) * 2 + 1);&quot;,&quot;  var exp = (bitsHigh &gt;&gt;&gt; 20) &amp; 0x7FF;&quot;,&quot;  var mant = jspb.BinaryConstants.TWO_TO_32 * (bitsHigh &amp; 0xFFFFF) + bitsLow;&quot;,null,&quot;  if (exp == 0x7FF) {&quot;,&quot;    if (mant) {&quot;,&quot;      return NaN;&quot;,&quot;    } else {&quot;,&quot;      return sign * Infinity;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  if (exp == 0) {&quot;,&quot;    // Denormal.&quot;,&quot;    return sign * Math.pow(2, -1074) * mant;&quot;,&quot;  } else {&quot;,&quot;    return sign * Math.pow(2, exp - 1075) *&quot;,&quot;           (mant + jspb.BinaryConstants.TWO_TO_52);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Joins two 32-bit values into an 8-character hash string.&quot;,&quot; * @param {number} bitsLow&quot;,&quot; * @param {number} bitsHigh&quot;,&quot; * @return {string}&quot;,&quot; */&quot;,&quot;jspb.utils.joinHash64 = function(bitsLow, bitsHigh) {&quot;,&quot;  var a = (bitsLow &gt;&gt;&gt; 0) &amp; 0xFF;&quot;,&quot;  var b = (bitsLow &gt;&gt;&gt; 8) &amp; 0xFF;&quot;,&quot;  var c = (bitsLow &gt;&gt;&gt; 16) &amp; 0xFF;&quot;,&quot;  var d = (bitsLow &gt;&gt;&gt; 24) &amp; 0xFF;&quot;,&quot;  var e = (bitsHigh &gt;&gt;&gt; 0) &amp; 0xFF;&quot;,&quot;  var f = (bitsHigh &gt;&gt;&gt; 8) &amp; 0xFF;&quot;,&quot;  var g = (bitsHigh &gt;&gt;&gt; 16) &amp; 0xFF;&quot;,&quot;  var h = (bitsHigh &gt;&gt;&gt; 24) &amp; 0xFF;&quot;,null,&quot;  return String.fromCharCode(a, b, c, d, e, f, g, h);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Individual digits for number-&gt;string conversion.&quot;,&quot; * @const {!Array&lt;string&gt;}&quot;,&quot; */&quot;,&quot;jspb.utils.DIGITS = [&quot;,&quot;  &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,&quot;,&quot;  &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;&quot;,&quot;];&quot;,null,null,&quot;/**&quot;,&quot; * Losslessly converts a 64-bit unsigned integer in 32:32 split representation&quot;,&quot; * into a decimal string.&quot;,&quot; * @param {number} bitsLow The low 32 bits of the binary number;&quot;,&quot; * @param {number} bitsHigh The high 32 bits of the binary number.&quot;,&quot; * @return {string} The binary number represented as a string.&quot;,&quot; */&quot;,&quot;jspb.utils.joinUnsignedDecimalString = function(bitsLow, bitsHigh) {&quot;,&quot;  // Skip the expensive conversion if the number is small enough to use the&quot;,&quot;  // built-in conversions.&quot;,&quot;  if (bitsHigh &lt;= 0x1FFFFF) {&quot;,&quot;    return &#39;&#39; + (jspb.BinaryConstants.TWO_TO_32 * bitsHigh + bitsLow);&quot;,&quot;  }&quot;,null,&quot;  // What this code is doing is essentially converting the input number from&quot;,&quot;  // base-2 to base-1e7, which allows us to represent the 64-bit range with&quot;,&quot;  // only 3 (very large) digits. Those digits are then trivial to convert to&quot;,&quot;  // a base-10 string.&quot;,null,&quot;  // The magic numbers used here are -&quot;,&quot;  // 2^24 = 16777216 = (1,6777216) in base-1e7.&quot;,&quot;  // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.&quot;,null,&quot;  // Split 32:32 representation into 16:24:24 representation so our&quot;,&quot;  // intermediate digits don&#39;t overflow.&quot;,&quot;  var low = bitsLow &amp; 0xFFFFFF;&quot;,&quot;  var mid = (((bitsLow &gt;&gt;&gt; 24) | (bitsHigh &lt;&lt; 8)) &gt;&gt;&gt; 0) &amp; 0xFFFFFF;&quot;,&quot;  var high = (bitsHigh &gt;&gt; 16) &amp; 0xFFFF;&quot;,null,&quot;  // Assemble our three base-1e7 digits, ignoring carries. The maximum&quot;,&quot;  // value in a digit at this step is representable as a 48-bit integer, which&quot;,&quot;  // can be stored in a 64-bit floating point number.&quot;,&quot;  var digitA = low + (mid * 6777216) + (high * 6710656);&quot;,&quot;  var digitB = mid + (high * 8147497);&quot;,&quot;  var digitC = (high * 2);&quot;,null,&quot;  // Apply carries from A to B and from B to C.&quot;,&quot;  var base = 10000000;&quot;,&quot;  if (digitA &gt;= base) {&quot;,&quot;    digitB += Math.floor(digitA / base);&quot;,&quot;    digitA %= base;&quot;,&quot;  }&quot;,null,&quot;  if (digitB &gt;= base) {&quot;,&quot;    digitC += Math.floor(digitB / base);&quot;,&quot;    digitB %= base;&quot;,&quot;  }&quot;,null,&quot;  // Convert base-1e7 digits to base-10, omitting leading zeroes.&quot;,&quot;  var table = jspb.utils.DIGITS;&quot;,&quot;  var start = false;&quot;,&quot;  var result = &#39;&#39;;&quot;,null,&quot;  function emit(digit) {&quot;,&quot;    var temp = base;&quot;,&quot;    for (var i = 0; i &lt; 7; i++) {&quot;,&quot;      temp /= 10;&quot;,&quot;      var decimalDigit = ((digit / temp) % 10) &gt;&gt;&gt; 0;&quot;,&quot;      if ((decimalDigit == 0) &amp;&amp; !start) continue;&quot;,&quot;      start = true;&quot;,&quot;      result += table[decimalDigit];&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  if (digitC || start) emit(digitC);&quot;,&quot;  if (digitB || start) emit(digitB);&quot;,&quot;  if (digitA || start) emit(digitA);&quot;,null,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Losslessly converts a 64-bit signed integer in 32:32 split representation&quot;,&quot; * into a decimal string.&quot;,&quot; * @param {number} bitsLow The low 32 bits of the binary number;&quot;,&quot; * @param {number} bitsHigh The high 32 bits of the binary number.&quot;,&quot; * @return {string} The binary number represented as a string.&quot;,&quot; */&quot;,&quot;jspb.utils.joinSignedDecimalString = function(bitsLow, bitsHigh) {&quot;,&quot;  // If we&#39;re treating the input as a signed value and the high bit is set, do&quot;,&quot;  // a manual two&#39;s complement conversion before the decimal conversion.&quot;,&quot;  var negative = (bitsHigh &amp; 0x80000000);&quot;,&quot;  if (negative) {&quot;,&quot;    bitsLow = (~bitsLow + 1) &gt;&gt;&gt; 0;&quot;,&quot;    var carry = (bitsLow == 0) ? 1 : 0;&quot;,&quot;    bitsHigh = (~bitsHigh + carry) &gt;&gt;&gt; 0;&quot;,&quot;  }&quot;,null,&quot;  var result = jspb.utils.joinUnsignedDecimalString(bitsLow, bitsHigh);&quot;,&quot;  return negative ? &#39;-&#39; + result : result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Convert an 8-character hash string representing either a signed or unsigned&quot;,&quot; * 64-bit integer into its decimal representation without losing accuracy.&quot;,&quot; * @param {string} hash The hash string to convert.&quot;,&quot; * @param {boolean} signed True if we should treat the hash string as encoding&quot;,&quot; *     a signed integer.&quot;,&quot; * @return {string}&quot;,&quot; */&quot;,&quot;jspb.utils.hash64ToDecimalString = function(hash, signed) {&quot;,&quot;  jspb.utils.splitHash64(hash);&quot;,&quot;  var bitsLow = jspb.utils.split64Low;&quot;,&quot;  var bitsHigh = jspb.utils.split64High;&quot;,&quot;  return signed ?&quot;,&quot;      jspb.utils.joinSignedDecimalString(bitsLow, bitsHigh) :&quot;,&quot;      jspb.utils.joinUnsignedDecimalString(bitsLow, bitsHigh);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts an array of 8-character hash strings into their decimal&quot;,&quot; * representations.&quot;,&quot; * @param {!Array&lt;string&gt;} hashes The array of hash strings to convert.&quot;,&quot; * @param {boolean} signed True if we should treat the hash string as encoding&quot;,&quot; *     a signed integer.&quot;,&quot; * @return {!Array&lt;string&gt;}&quot;,&quot; */&quot;,&quot;jspb.utils.hash64ArrayToDecimalStrings = function(hashes, signed) {&quot;,&quot;  var result = new Array(hashes.length);&quot;,&quot;  for (var i = 0; i &lt; hashes.length; i++) {&quot;,&quot;    result[i] = jspb.utils.hash64ToDecimalString(hashes[i], signed);&quot;,&quot;  }&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a signed or unsigned decimal string into its hash string&quot;,&quot; * representation.&quot;,&quot; * @param {string} dec&quot;,&quot; * @return {string}&quot;,&quot; */&quot;,&quot;jspb.utils.decimalStringToHash64 = function(dec) {&quot;,&quot;  goog.asserts.assert(dec.length &gt; 0);&quot;,null,&quot;  // Check for minus sign.&quot;,&quot;  var minus = false;&quot;,&quot;  if (dec[0] === &#39;-&#39;) {&quot;,&quot;    minus = true;&quot;,&quot;    dec = dec.slice(1);&quot;,&quot;  }&quot;,null,&quot;  // Store result as a byte array.&quot;,&quot;  var resultBytes = [0, 0, 0, 0, 0, 0, 0, 0];&quot;,null,&quot;  // Set result to m*result + c.&quot;,&quot;  function muladd(m, c) {&quot;,&quot;    for (var i = 0; i &lt; 8 &amp;&amp; (m !== 1 || c &gt; 0); i++) {&quot;,&quot;      var r = m * resultBytes[i] + c;&quot;,&quot;      resultBytes[i] = r &amp; 0xFF;&quot;,&quot;      c = r &gt;&gt;&gt; 8;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // Negate the result bits.&quot;,&quot;  function neg() {&quot;,&quot;    for (var i = 0; i &lt; 8; i++) {&quot;,&quot;      resultBytes[i] = (~resultBytes[i]) &amp; 0xFF;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // For each decimal digit, set result to 10*result + digit.&quot;,&quot;  for (var i = 0; i &lt; dec.length; i++) {&quot;,&quot;    muladd(10, jspb.utils.DIGITS.indexOf(dec[i]));&quot;,&quot;  }&quot;,null,&quot;  // If there&#39;s a minus sign, convert into two&#39;s complement.&quot;,&quot;  if (minus) {&quot;,&quot;    neg();&quot;,&quot;    muladd(1, 1);&quot;,&quot;  }&quot;,null,&quot;  return goog.crypt.byteArrayToString(resultBytes);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a signed or unsigned decimal string into two 32-bit halves, and&quot;,&quot; * stores them in the temp variables listed above.&quot;,&quot; * @param {string} value The decimal string to convert.&quot;,&quot; */&quot;,&quot;jspb.utils.splitDecimalString = function(value) {&quot;,&quot;  jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(value));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts an 8-character hash string into its hexadecimal representation.&quot;,&quot; * @param {string} hash&quot;,&quot; * @return {string}&quot;,&quot; */&quot;,&quot;jspb.utils.hash64ToHexString = function(hash) {&quot;,&quot;  var temp = new Array(18);&quot;,&quot;  temp[0] = &#39;0&#39;;&quot;,&quot;  temp[1] = &#39;x&#39;;&quot;,null,&quot;  for (var i = 0; i &lt; 8; i++) {&quot;,&quot;    var c = hash.charCodeAt(7 - i);&quot;,&quot;    temp[i * 2 + 2] = jspb.utils.DIGITS[c &gt;&gt; 4];&quot;,&quot;    temp[i * 2 + 3] = jspb.utils.DIGITS[c &amp; 0xF];&quot;,&quot;  }&quot;,null,&quot;  var result = temp.join(&#39;&#39;);&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a &#39;0x&lt;16 digits&gt;&#39; hex string into its hash string representation.&quot;,&quot; * @param {string} hex&quot;,&quot; * @return {string}&quot;,&quot; */&quot;,&quot;jspb.utils.hexStringToHash64 = function(hex) {&quot;,&quot;  hex = hex.toLowerCase();&quot;,&quot;  goog.asserts.assert(hex.length == 18);&quot;,&quot;  goog.asserts.assert(hex[0] == &#39;0&#39;);&quot;,&quot;  goog.asserts.assert(hex[1] == &#39;x&#39;);&quot;,null,&quot;  var result = &#39;&#39;;&quot;,&quot;  for (var i = 0; i &lt; 8; i++) {&quot;,&quot;    var hi = jspb.utils.DIGITS.indexOf(hex[i * 2 + 2]);&quot;,&quot;    var lo = jspb.utils.DIGITS.indexOf(hex[i * 2 + 3]);&quot;,&quot;    result = String.fromCharCode(hi * 16 + lo) + result;&quot;,&quot;  }&quot;,null,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Convert an 8-character hash string representing either a signed or unsigned&quot;,&quot; * 64-bit integer into a Javascript number. Will lose accuracy if the result is&quot;,&quot; * larger than 2^52.&quot;,&quot; * @param {string} hash The hash string to convert.&quot;,&quot; * @param {boolean} signed True if the has should be interpreted as a signed&quot;,&quot; *     number.&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;jspb.utils.hash64ToNumber = function(hash, signed) {&quot;,&quot;  jspb.utils.splitHash64(hash);&quot;,&quot;  var bitsLow = jspb.utils.split64Low;&quot;,&quot;  var bitsHigh = jspb.utils.split64High;&quot;,&quot;  return signed ? jspb.utils.joinInt64(bitsLow, bitsHigh) :&quot;,&quot;                  jspb.utils.joinUint64(bitsLow, bitsHigh);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Convert a Javascript number into an 8-character hash string. Will lose&quot;,&quot; * precision if the value is non-integral or greater than 2^64.&quot;,&quot; * @param {number} value The integer to convert.&quot;,&quot; * @return {string}&quot;,&quot; */&quot;,&quot;jspb.utils.numberToHash64 = function(value) {&quot;,&quot;  jspb.utils.splitInt64(value);&quot;,&quot;  return jspb.utils.joinHash64(jspb.utils.split64Low,&quot;,&quot;                                  jspb.utils.split64High);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Counts the number of contiguous varints in a buffer.&quot;,&quot; * @param {!Uint8Array} buffer The buffer to scan.&quot;,&quot; * @param {number} start The starting point in the buffer to scan.&quot;,&quot; * @param {number} end The end point in the buffer to scan.&quot;,&quot; * @return {number} The number of varints in the buffer.&quot;,&quot; */&quot;,&quot;jspb.utils.countVarints = function(buffer, start, end) {&quot;,&quot;  // Count how many high bits of each byte were set in the buffer.&quot;,&quot;  var count = 0;&quot;,&quot;  for (var i = start; i &lt; end; i++) {&quot;,&quot;    count += buffer[i] &gt;&gt; 7;&quot;,&quot;  }&quot;,null,&quot;  // The number of varints in the buffer equals the size of the buffer minus&quot;,&quot;  // the number of non-terminal bytes in the buffer (those with the high bit&quot;,&quot;  // set).&quot;,&quot;  return (end - start) - count;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Counts the number of contiguous varint fields with the given field number in&quot;,&quot; * the buffer.&quot;,&quot; * @param {!Uint8Array} buffer The buffer to scan.&quot;,&quot; * @param {number} start The starting point in the buffer to scan.&quot;,&quot; * @param {number} end The end point in the buffer to scan.&quot;,&quot; * @param {number} field The field number to count.&quot;,&quot; * @return {number} The number of matching fields in the buffer.&quot;,&quot; */&quot;,&quot;jspb.utils.countVarintFields = function(buffer, start, end, field) {&quot;,&quot;  var count = 0;&quot;,&quot;  var cursor = start;&quot;,&quot;  var tag = field * 8 + jspb.BinaryConstants.WireType.VARINT;&quot;,null,&quot;  if (tag &lt; 128) {&quot;,&quot;    // Single-byte field tag, we can use a slightly quicker count.&quot;,&quot;    while (cursor &lt; end) {&quot;,&quot;      // Skip the field tag, or exit if we find a non-matching tag.&quot;,&quot;      if (buffer[cursor++] != tag) return count;&quot;,null,&quot;      // Field tag matches, we&#39;ve found a valid field.&quot;,&quot;      count++;&quot;,null,&quot;      // Skip the varint.&quot;,&quot;      while (1) {&quot;,&quot;        var x = buffer[cursor++];&quot;,&quot;        if ((x &amp; 0x80) == 0) break;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    while (cursor &lt; end) {&quot;,&quot;      // Skip the field tag, or exit if we find a non-matching tag.&quot;,&quot;      var temp = tag;&quot;,&quot;      while (temp &gt; 128) {&quot;,&quot;        if (buffer[cursor] != ((temp &amp; 0x7F) | 0x80)) return count;&quot;,&quot;        cursor++;&quot;,&quot;        temp &gt;&gt;= 7;&quot;,&quot;      }&quot;,&quot;      if (buffer[cursor++] != temp) return count;&quot;,null,&quot;      // Field tag matches, we&#39;ve found a valid field.&quot;,&quot;      count++;&quot;,null,&quot;      // Skip the varint.&quot;,&quot;      while (1) {&quot;,&quot;        var x = buffer[cursor++];&quot;,&quot;        if ((x &amp; 0x80) == 0) break;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return count;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Counts the number of contiguous fixed32 fields with the given tag in the&quot;,&quot; * buffer.&quot;,&quot; * @param {!Uint8Array} buffer The buffer to scan.&quot;,&quot; * @param {number} start The starting point in the buffer to scan.&quot;,&quot; * @param {number} end The end point in the buffer to scan.&quot;,&quot; * @param {number} tag The tag value to count.&quot;,&quot; * @param {number} stride The number of bytes to skip per field.&quot;,&quot; * @return {number} The number of fields with a matching tag in the buffer.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.utils.countFixedFields_ =&quot;,&quot;    function(buffer, start, end, tag, stride) {&quot;,&quot;  var count = 0;&quot;,&quot;  var cursor = start;&quot;,null,&quot;  if (tag &lt; 128) {&quot;,&quot;    // Single-byte field tag, we can use a slightly quicker count.&quot;,&quot;    while (cursor &lt; end) {&quot;,&quot;      // Skip the field tag, or exit if we find a non-matching tag.&quot;,&quot;      if (buffer[cursor++] != tag) return count;&quot;,null,&quot;      // Field tag matches, we&#39;ve found a valid field.&quot;,&quot;      count++;&quot;,null,&quot;      // Skip the value.&quot;,&quot;      cursor += stride;&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    while (cursor &lt; end) {&quot;,&quot;      // Skip the field tag, or exit if we find a non-matching tag.&quot;,&quot;      var temp = tag;&quot;,&quot;      while (temp &gt; 128) {&quot;,&quot;        if (buffer[cursor++] != ((temp &amp; 0x7F) | 0x80)) return count;&quot;,&quot;        temp &gt;&gt;= 7;&quot;,&quot;      }&quot;,&quot;      if (buffer[cursor++] != temp) return count;&quot;,null,&quot;      // Field tag matches, we&#39;ve found a valid field.&quot;,&quot;      count++;&quot;,null,&quot;      // Skip the value.&quot;,&quot;      cursor += stride;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return count;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Counts the number of contiguous fixed32 fields with the given field number&quot;,&quot; * in the buffer.&quot;,&quot; * @param {!Uint8Array} buffer The buffer to scan.&quot;,&quot; * @param {number} start The starting point in the buffer to scan.&quot;,&quot; * @param {number} end The end point in the buffer to scan.&quot;,&quot; * @param {number} field The field number to count.&quot;,&quot; * @return {number} The number of matching fields in the buffer.&quot;,&quot; */&quot;,&quot;jspb.utils.countFixed32Fields = function(buffer, start, end, field) {&quot;,&quot;  var tag = field * 8 + jspb.BinaryConstants.WireType.FIXED32;&quot;,&quot;  return jspb.utils.countFixedFields_(buffer, start, end, tag, 4);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Counts the number of contiguous fixed64 fields with the given field number&quot;,&quot; * in the buffer.&quot;,&quot; * @param {!Uint8Array} buffer The buffer to scan.&quot;,&quot; * @param {number} start The starting point in the buffer to scan.&quot;,&quot; * @param {number} end The end point in the buffer to scan.&quot;,&quot; * @param {number} field The field number to count&quot;,&quot; * @return {number} The number of matching fields in the buffer.&quot;,&quot; */&quot;,&quot;jspb.utils.countFixed64Fields = function(buffer, start, end, field) {&quot;,&quot;  var tag = field * 8 + jspb.BinaryConstants.WireType.FIXED64;&quot;,&quot;  return jspb.utils.countFixedFields_(buffer, start, end, tag, 8);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Counts the number of contiguous delimited fields with the given field number&quot;,&quot; * in the buffer.&quot;,&quot; * @param {!Uint8Array} buffer The buffer to scan.&quot;,&quot; * @param {number} start The starting point in the buffer to scan.&quot;,&quot; * @param {number} end The end point in the buffer to scan.&quot;,&quot; * @param {number} field The field number to count.&quot;,&quot; * @return {number} The number of matching fields in the buffer.&quot;,&quot; */&quot;,&quot;jspb.utils.countDelimitedFields = function(buffer, start, end, field) {&quot;,&quot;  var count = 0;&quot;,&quot;  var cursor = start;&quot;,&quot;  var tag = field * 8 + jspb.BinaryConstants.WireType.DELIMITED;&quot;,null,&quot;  while (cursor &lt; end) {&quot;,&quot;    // Skip the field tag, or exit if we find a non-matching tag.&quot;,&quot;    var temp = tag;&quot;,&quot;    while (temp &gt; 128) {&quot;,&quot;      if (buffer[cursor++] != ((temp &amp; 0x7F) | 0x80)) return count;&quot;,&quot;      temp &gt;&gt;= 7;&quot;,&quot;    }&quot;,&quot;    if (buffer[cursor++] != temp) return count;&quot;,null,&quot;    // Field tag matches, we&#39;ve found a valid field.&quot;,&quot;    count++;&quot;,null,&quot;    // Decode the length prefix.&quot;,&quot;    var length = 0;&quot;,&quot;    var shift = 1;&quot;,&quot;    while (1) {&quot;,&quot;      temp = buffer[cursor++];&quot;,&quot;      length += (temp &amp; 0x7f) * shift;&quot;,&quot;      shift *= 128;&quot;,&quot;      if ((temp &amp; 0x80) == 0) break;&quot;,&quot;    }&quot;,null,&quot;    // Advance the cursor past the blob.&quot;,&quot;    cursor += length;&quot;,&quot;  }&quot;,&quot;  return count;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * String-ify bytes for text format. Should be optimized away in non-debug.&quot;,&quot; * The returned string uses \\xXX escapes for all values and is itself quoted.&quot;,&quot; * [1, 31] serializes to &#39;\&quot;\\x01\\x1f\&quot;&#39;.&quot;,&quot; * @param {jspb.ByteSource} byteSource The bytes to serialize.&quot;,&quot; * @return {string} Stringified bytes for text format.&quot;,&quot; */&quot;,&quot;jspb.utils.debugBytesToTextFormat = function(byteSource) {&quot;,&quot;  var s = &#39;\&quot;&#39;;&quot;,&quot;  if (byteSource) {&quot;,&quot;    var bytes = jspb.utils.byteSourceToUint8Array(byteSource);&quot;,&quot;    for (var i = 0; i &lt; bytes.length; i++) {&quot;,&quot;      s += &#39;\\\\x&#39;;&quot;,&quot;      if (bytes[i] &lt; 16) s += &#39;0&#39;;&quot;,&quot;      s += bytes[i].toString(16);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return s + &#39;\&quot;&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * String-ify a scalar for text format. Should be optimized away in non-debug.&quot;,&quot; * @param {string|number|boolean} scalar The scalar to stringify.&quot;,&quot; * @return {string} Stringified scalar for text format.&quot;,&quot; */&quot;,&quot;jspb.utils.debugScalarToTextFormat = function(scalar) {&quot;,&quot;  if (goog.isString(scalar)) {&quot;,&quot;    return goog.string.quote(scalar);&quot;,&quot;  } else {&quot;,&quot;    return scalar.toString();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Utility function: convert a string with codepoints 0--255 inclusive to a&quot;,&quot; * Uint8Array. If any codepoints greater than 255 exist in the string, throws an&quot;,&quot; * exception.&quot;,&quot; * @param {string} str&quot;,&quot; * @return {!Uint8Array}&quot;,&quot; */&quot;,&quot;jspb.utils.stringToByteArray = function(str) {&quot;,&quot;  var arr = new Uint8Array(str.length);&quot;,&quot;  for (var i = 0; i &lt; str.length; i++) {&quot;,&quot;    var codepoint = str.charCodeAt(i);&quot;,&quot;    if (codepoint &gt; 255) {&quot;,&quot;      throw new Error(&#39;Conversion error: string contains codepoint &#39; +&quot;,&quot;                      &#39;outside of byte range&#39;);&quot;,&quot;    }&quot;,&quot;    arr[i] = codepoint;&quot;,&quot;  }&quot;,&quot;  return arr;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts any type defined in jspb.ByteSource into a Uint8Array.&quot;,&quot; * @param {!jspb.ByteSource} data&quot;,&quot; * @return {!Uint8Array}&quot;,&quot; * @suppress {invalidCasts}&quot;,&quot; */&quot;,&quot;jspb.utils.byteSourceToUint8Array = function(data) {&quot;,&quot;  if (data.constructor === Uint8Array) {&quot;,&quot;    return /** @type {!Uint8Array} */(data);&quot;,&quot;  }&quot;,null,&quot;  if (data.constructor === ArrayBuffer) {&quot;,&quot;    data = /** @type {!ArrayBuffer} */(data);&quot;,&quot;    return /** @type {!Uint8Array} */(new Uint8Array(data));&quot;,&quot;  }&quot;,null,&quot;  if (data.constructor === Array) {&quot;,&quot;    data = /** @type {!Array&lt;number&gt;} */(data);&quot;,&quot;    return /** @type {!Uint8Array} */(new Uint8Array(data));&quot;,&quot;  }&quot;,null,&quot;  if (data.constructor === String) {&quot;,&quot;    data = /** @type {string} */(data);&quot;,&quot;    return goog.crypt.base64.decodeStringToUint8Array(data);&quot;,&quot;  }&quot;,null,&quot;  goog.asserts.fail(&#39;Type not convertible to Uint8Array.&#39;);&quot;,&quot;  return /** @type {!Uint8Array} */(new Uint8Array(0));&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../dossier.js" defer></script>