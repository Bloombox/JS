<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>encoder.js</title><link href="../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;encoder.js&quot;,&quot;protobuf/js/binary/encoder.js&quot;,[&quot;// Protocol Buffers - Google&#39;s data interchange format&quot;,&quot;// Copyright 2008 Google Inc.  All rights reserved.&quot;,&quot;// https://developers.google.com/protocol-buffers/&quot;,&quot;//&quot;,&quot;// Redistribution and use in source and binary forms, with or without&quot;,&quot;// modification, are permitted provided that the following conditions are&quot;,&quot;// met:&quot;,&quot;//&quot;,&quot;//     * Redistributions of source code must retain the above copyright&quot;,&quot;// notice, this list of conditions and the following disclaimer.&quot;,&quot;//     * Redistributions in binary form must reproduce the above&quot;,&quot;// copyright notice, this list of conditions and the following disclaimer&quot;,&quot;// in the documentation and/or other materials provided with the&quot;,&quot;// distribution.&quot;,&quot;//     * Neither the name of Google Inc. nor the names of its&quot;,&quot;// contributors may be used to endorse or promote products derived from&quot;,&quot;// this software without specific prior written permission.&quot;,&quot;//&quot;,&quot;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;,&quot;// \&quot;AS IS\&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR&quot;,&quot;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&quot;,&quot;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&quot;,&quot;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,&quot;,&quot;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY&quot;,&quot;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&quot;,&quot;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&quot;,&quot;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview BinaryEncode defines methods for encoding Javascript values&quot;,&quot; * into arrays of bytes compatible with the Protocol Buffer wire format.&quot;,&quot; *&quot;,&quot; * @author aappleby@google.com (Austin Appleby)&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;jspb.BinaryEncoder&#39;);&quot;,null,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;jspb.BinaryConstants&#39;);&quot;,&quot;goog.require(&#39;jspb.utils&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * BinaryEncoder implements encoders for all the wire types specified in&quot;,&quot; * https://developers.google.com/protocol-buffers/docs/encoding.&quot;,&quot; *&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder = function() {&quot;,&quot;  /** @private {!Array&lt;number&gt;} */&quot;,&quot;  this.buffer_ = [];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.length = function() {&quot;,&quot;  return this.buffer_.length;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.end = function() {&quot;,&quot;  var buffer = this.buffer_;&quot;,&quot;  this.buffer_ = [];&quot;,&quot;  return buffer;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Encodes a 64-bit integer in 32:32 split representation into its wire-format&quot;,&quot; * varint representation and stores it in the buffer.&quot;,&quot; * @param {number} lowBits The low 32 bits of the int.&quot;,&quot; * @param {number} highBits The high 32 bits of the int.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeSplitVarint64 = function(lowBits, highBits) {&quot;,&quot;  goog.asserts.assert(lowBits == Math.floor(lowBits));&quot;,&quot;  goog.asserts.assert(highBits == Math.floor(highBits));&quot;,&quot;  goog.asserts.assert((lowBits &gt;= 0) &amp;&amp;&quot;,&quot;                      (lowBits &lt; jspb.BinaryConstants.TWO_TO_32));&quot;,&quot;  goog.asserts.assert((highBits &gt;= 0) &amp;&amp;&quot;,&quot;                      (highBits &lt; jspb.BinaryConstants.TWO_TO_32));&quot;,null,&quot;  // Break the binary representation into chunks of 7 bits, set the 8th bit&quot;,&quot;  // in each chunk if it&#39;s not the final chunk, and append to the result.&quot;,&quot;  while (highBits &gt; 0 || lowBits &gt; 127) {&quot;,&quot;    this.buffer_.push((lowBits &amp; 0x7f) | 0x80);&quot;,&quot;    lowBits = ((lowBits &gt;&gt;&gt; 7) | (highBits &lt;&lt; 25)) &gt;&gt;&gt; 0;&quot;,&quot;    highBits = highBits &gt;&gt;&gt; 7;&quot;,&quot;  }&quot;,&quot;  this.buffer_.push(lowBits);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Encodes a 64-bit integer in 32:32 split representation into its wire-format&quot;,&quot; * fixed representation and stores it in the buffer.&quot;,&quot; * @param {number} lowBits The low 32 bits of the int.&quot;,&quot; * @param {number} highBits The high 32 bits of the int.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeSplitFixed64 = function(lowBits, highBits) {&quot;,&quot;  goog.asserts.assert(lowBits == Math.floor(lowBits));&quot;,&quot;  goog.asserts.assert(highBits == Math.floor(highBits));&quot;,&quot;  goog.asserts.assert((lowBits &gt;= 0) &amp;&amp;&quot;,&quot;                      (lowBits &lt; jspb.BinaryConstants.TWO_TO_32));&quot;,&quot;  goog.asserts.assert((highBits &gt;= 0) &amp;&amp;&quot;,&quot;                      (highBits &lt; jspb.BinaryConstants.TWO_TO_32));&quot;,&quot;  this.writeUint32(lowBits);&quot;,&quot;  this.writeUint32(highBits);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Encodes a 32-bit unsigned integer into its wire-format varint representation&quot;,&quot; * and stores it in the buffer.&quot;,&quot; * @param {number} value The integer to convert.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeUnsignedVarint32 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= 0) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_32));&quot;,null,&quot;  while (value &gt; 127) {&quot;,&quot;    this.buffer_.push((value &amp; 0x7f) | 0x80);&quot;,&quot;    value = value &gt;&gt;&gt; 7;&quot;,&quot;  }&quot;,null,&quot;  this.buffer_.push(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Encodes a 32-bit signed integer into its wire-format varint representation&quot;,&quot; * and stores it in the buffer.&quot;,&quot; * @param {number} value The integer to convert.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeSignedVarint32 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_31) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_31));&quot;,null,&quot;  // Use the unsigned version if the value is not negative.&quot;,&quot;  if (value &gt;= 0) {&quot;,&quot;    this.writeUnsignedVarint32(value);&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  // Write nine bytes with a _signed_ right shift so we preserve the sign bit.&quot;,&quot;  for (var i = 0; i &lt; 9; i++) {&quot;,&quot;    this.buffer_.push((value &amp; 0x7f) | 0x80);&quot;,&quot;    value = value &gt;&gt; 7;&quot;,&quot;  }&quot;,null,&quot;  // The above loop writes out 63 bits, so the last byte is always the sign bit&quot;,&quot;  // which is always set for negative numbers.&quot;,&quot;  this.buffer_.push(1);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Encodes a 64-bit unsigned integer into its wire-format varint representation&quot;,&quot; * and stores it in the buffer. Integers that are not representable in 64 bits&quot;,&quot; * will be truncated.&quot;,&quot; * @param {number} value The integer to convert.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeUnsignedVarint64 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= 0) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_64));&quot;,&quot;  jspb.utils.splitInt64(value);&quot;,&quot;  this.writeSplitVarint64(jspb.utils.split64Low,&quot;,&quot;                          jspb.utils.split64High);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Encodes a 64-bit signed integer into its wire-format varint representation&quot;,&quot; * and stores it in the buffer. Integers that are not representable in 64 bits&quot;,&quot; * will be truncated.&quot;,&quot; * @param {number} value The integer to convert.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeSignedVarint64 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_63) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_63));&quot;,&quot;  jspb.utils.splitInt64(value);&quot;,&quot;  this.writeSplitVarint64(jspb.utils.split64Low,&quot;,&quot;                          jspb.utils.split64High);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Encodes a JavaScript integer into its wire-format, zigzag-encoded varint&quot;,&quot; * representation and stores it in the buffer.&quot;,&quot; * @param {number} value The integer to convert.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeZigzagVarint32 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_31) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_31));&quot;,&quot;  this.writeUnsignedVarint32(((value &lt;&lt; 1) ^ (value &gt;&gt; 31)) &gt;&gt;&gt; 0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Encodes a JavaScript integer into its wire-format, zigzag-encoded varint&quot;,&quot; * representation and stores it in the buffer. Integers not representable in 64&quot;,&quot; * bits will be truncated.&quot;,&quot; * @param {number} value The integer to convert.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeZigzagVarint64 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_63) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_63));&quot;,&quot;  jspb.utils.splitZigzag64(value);&quot;,&quot;  this.writeSplitVarint64(jspb.utils.split64Low,&quot;,&quot;                          jspb.utils.split64High);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Encodes a JavaScript decimal string into its wire-format, zigzag-encoded&quot;,&quot; * varint representation and stores it in the buffer. Integers not representable&quot;,&quot; * in 64 bits will be truncated.&quot;,&quot; * @param {string} value The integer to convert.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeZigzagVarint64String = function(value) {&quot;,&quot;  // TODO(haberman): write lossless 64-bit zig-zag math.&quot;,&quot;  this.writeZigzagVarint64(parseInt(value, 10));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 8-bit unsigned integer to the buffer. Numbers outside the range&quot;,&quot; * [0,2^8) will be truncated.&quot;,&quot; * @param {number} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeUint8 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= 0) &amp;&amp; (value &lt; 256));&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 0) &amp; 0xFF);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 16-bit unsigned integer to the buffer. Numbers outside the&quot;,&quot; * range [0,2^16) will be truncated.&quot;,&quot; * @param {number} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeUint16 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= 0) &amp;&amp; (value &lt; 65536));&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 0) &amp; 0xFF);&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 8) &amp; 0xFF);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 32-bit unsigned integer to the buffer. Numbers outside the&quot;,&quot; * range [0,2^32) will be truncated.&quot;,&quot; * @param {number} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeUint32 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= 0) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_32));&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 0) &amp; 0xFF);&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 8) &amp; 0xFF);&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 16) &amp; 0xFF);&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 24) &amp; 0xFF);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 64-bit unsigned integer to the buffer. Numbers outside the&quot;,&quot; * range [0,2^64) will be truncated.&quot;,&quot; * @param {number} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeUint64 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= 0) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_64));&quot;,&quot;  jspb.utils.splitUint64(value);&quot;,&quot;  this.writeUint32(jspb.utils.split64Low);&quot;,&quot;  this.writeUint32(jspb.utils.split64High);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 8-bit integer to the buffer. Numbers outside the range&quot;,&quot; * [-2^7,2^7) will be truncated.&quot;,&quot; * @param {number} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeInt8 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= -128) &amp;&amp; (value &lt; 128));&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 0) &amp; 0xFF);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 16-bit integer to the buffer. Numbers outside the range&quot;,&quot; * [-2^15,2^15) will be truncated.&quot;,&quot; * @param {number} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeInt16 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= -32768) &amp;&amp; (value &lt; 32768));&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 0) &amp; 0xFF);&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 8) &amp; 0xFF);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 32-bit integer to the buffer. Numbers outside the range&quot;,&quot; * [-2^31,2^31) will be truncated.&quot;,&quot; * @param {number} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeInt32 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_31) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_31));&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 0) &amp; 0xFF);&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 8) &amp; 0xFF);&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 16) &amp; 0xFF);&quot;,&quot;  this.buffer_.push((value &gt;&gt;&gt; 24) &amp; 0xFF);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 64-bit integer to the buffer. Numbers outside the range&quot;,&quot; * [-2^63,2^63) will be truncated.&quot;,&quot; * @param {number} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeInt64 = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_63) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_63));&quot;,&quot;  jspb.utils.splitInt64(value);&quot;,&quot;  this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 64-bit integer decimal strings to the buffer. Numbers outside the&quot;,&quot; * range [-2^63,2^63) will be truncated.&quot;,&quot; * @param {string} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeInt64String = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((+value &gt;= -jspb.BinaryConstants.TWO_TO_63) &amp;&amp;&quot;,&quot;                      (+value &lt; jspb.BinaryConstants.TWO_TO_63));&quot;,&quot;  jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(value));&quot;,&quot;  this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a single-precision floating point value to the buffer. Numbers&quot;,&quot; * requiring more than 32 bits of precision will be truncated.&quot;,&quot; * @param {number} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeFloat = function(value) {&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.FLOAT32_MAX) &amp;&amp;&quot;,&quot;                      (value &lt;= jspb.BinaryConstants.FLOAT32_MAX));&quot;,&quot;  jspb.utils.splitFloat32(value);&quot;,&quot;  this.writeUint32(jspb.utils.split64Low);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a double-precision floating point value to the buffer. As this is&quot;,&quot; * the native format used by JavaScript, no precision will be lost.&quot;,&quot; * @param {number} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeDouble = function(value) {&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.FLOAT64_MAX) &amp;&amp;&quot;,&quot;                      (value &lt;= jspb.BinaryConstants.FLOAT64_MAX));&quot;,&quot;  jspb.utils.splitFloat64(value);&quot;,&quot;  this.writeUint32(jspb.utils.split64Low);&quot;,&quot;  this.writeUint32(jspb.utils.split64High);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a boolean value to the buffer as a varint. We allow numbers as input&quot;,&quot; * because the JSPB code generator uses 0/1 instead of true/false to save space&quot;,&quot; * in the string representation of the proto.&quot;,&quot; * @param {boolean|number} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeBool = function(value) {&quot;,&quot;  goog.asserts.assert(goog.isBoolean(value) || goog.isNumber(value));&quot;,&quot;  this.buffer_.push(value ? 1 : 0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an enum value to the buffer as a varint.&quot;,&quot; * @param {number} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeEnum = function(value) {&quot;,&quot;  goog.asserts.assert(value == Math.floor(value));&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_31) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_31));&quot;,&quot;  this.writeSignedVarint32(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an arbitrary byte array to the buffer.&quot;,&quot; * @param {!Uint8Array} bytes The array of bytes to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeBytes = function(bytes) {&quot;,&quot;  this.buffer_.push.apply(this.buffer_, bytes);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 64-bit hash string (8 characters @ 8 bits of data each) to the&quot;,&quot; * buffer as a varint.&quot;,&quot; * @param {string} hash The hash to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeVarintHash64 = function(hash) {&quot;,&quot;  jspb.utils.splitHash64(hash);&quot;,&quot;  this.writeSplitVarint64(jspb.utils.split64Low,&quot;,&quot;                          jspb.utils.split64High);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 64-bit hash string (8 characters @ 8 bits of data each) to the&quot;,&quot; * buffer as a fixed64.&quot;,&quot; * @param {string} hash The hash to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeFixedHash64 = function(hash) {&quot;,&quot;  jspb.utils.splitHash64(hash);&quot;,&quot;  this.writeUint32(jspb.utils.split64Low);&quot;,&quot;  this.writeUint32(jspb.utils.split64High);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a UTF16 Javascript string to the buffer encoded as UTF8.&quot;,&quot; * TODO(aappleby): Add support for surrogate pairs, reject unpaired surrogates.&quot;,&quot; * @param {string} value The string to write.&quot;,&quot; * @return {number} The number of bytes used to encode the string.&quot;,&quot; */&quot;,&quot;jspb.BinaryEncoder.prototype.writeString = function(value) {&quot;,&quot;  var oldLength = this.buffer_.length;&quot;,null,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,null,&quot;    var c = value.charCodeAt(i);&quot;,null,&quot;    if (c &lt; 128) {&quot;,&quot;      this.buffer_.push(c);&quot;,&quot;    } else if (c &lt; 2048) {&quot;,&quot;      this.buffer_.push((c &gt;&gt; 6) | 192);&quot;,&quot;      this.buffer_.push((c &amp; 63) | 128);&quot;,&quot;    } else if (c &lt; 65536) {&quot;,&quot;      // Look for surrogates&quot;,&quot;      if (c &gt;= 0xD800 &amp;&amp; c &lt;= 0xDBFF &amp;&amp; i + 1 &lt; value.length) {&quot;,&quot;        var second = value.charCodeAt(i + 1);&quot;,&quot;        if (second &gt;= 0xDC00 &amp;&amp; second &lt;= 0xDFFF) { // low surrogate&quot;,&quot;          // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae&quot;,&quot;          c = (c - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;&quot;,null,&quot;          this.buffer_.push((c &gt;&gt; 18) | 240);&quot;,&quot;          this.buffer_.push(((c &gt;&gt; 12) &amp; 63 ) | 128);&quot;,&quot;          this.buffer_.push(((c &gt;&gt; 6) &amp; 63) | 128);&quot;,&quot;          this.buffer_.push((c &amp; 63) | 128);&quot;,&quot;          i++;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;      else {&quot;,&quot;        this.buffer_.push((c &gt;&gt; 12) | 224);&quot;,&quot;        this.buffer_.push(((c &gt;&gt; 6) &amp; 63) | 128);&quot;,&quot;        this.buffer_.push((c &amp; 63) | 128);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  var length = this.buffer_.length - oldLength;&quot;,&quot;  return length;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../dossier.js" defer></script>