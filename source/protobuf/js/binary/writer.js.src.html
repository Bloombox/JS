<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>writer.js</title><link href="../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;writer.js&quot;,&quot;protobuf/js/binary/writer.js&quot;,[&quot;// Protocol Buffers - Google&#39;s data interchange format&quot;,&quot;// Copyright 2008 Google Inc.  All rights reserved.&quot;,&quot;// https://developers.google.com/protocol-buffers/&quot;,&quot;//&quot;,&quot;// Redistribution and use in source and binary forms, with or without&quot;,&quot;// modification, are permitted provided that the following conditions are&quot;,&quot;// met:&quot;,&quot;//&quot;,&quot;//     * Redistributions of source code must retain the above copyright&quot;,&quot;// notice, this list of conditions and the following disclaimer.&quot;,&quot;//     * Redistributions in binary form must reproduce the above&quot;,&quot;// copyright notice, this list of conditions and the following disclaimer&quot;,&quot;// in the documentation and/or other materials provided with the&quot;,&quot;// distribution.&quot;,&quot;//     * Neither the name of Google Inc. nor the names of its&quot;,&quot;// contributors may be used to endorse or promote products derived from&quot;,&quot;// this software without specific prior written permission.&quot;,&quot;//&quot;,&quot;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;,&quot;// \&quot;AS IS\&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR&quot;,&quot;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&quot;,&quot;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&quot;,&quot;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,&quot;,&quot;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY&quot;,&quot;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&quot;,&quot;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&quot;,&quot;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview This file contains utilities for encoding Javascript objects&quot;,&quot; * into binary, wire-format protocol buffers (in the form of Uint8Arrays) that&quot;,&quot; * a server can consume directly.&quot;,&quot; *&quot;,&quot; * jspb&#39;s BinaryWriter class defines methods for efficiently encoding&quot;,&quot; * Javascript objects into binary, wire-format protocol buffers and supports&quot;,&quot; * all the fundamental field types used in protocol buffers.&quot;,&quot; *&quot;,&quot; * Major caveat 1 - Users of this library _must_ keep their Javascript proto&quot;,&quot; * parsing code in sync with the original .proto file - presumably you&#39;ll be&quot;,&quot; * using the typed jspb code generator, but if you bypass that you&#39;ll need&quot;,&quot; * to keep things in sync by hand.&quot;,&quot; *&quot;,&quot; * Major caveat 2 - Javascript is unable to accurately represent integers&quot;,&quot; * larger than 2^53 due to its use of a double-precision floating point format&quot;,&quot; * for all numbers. BinaryWriter does not make any special effort to preserve&quot;,&quot; * precision for values above this limit - if you need to pass 64-bit integers&quot;,&quot; * (hash codes, for example) between the client and server without precision&quot;,&quot; * loss, do _not_ use this library.&quot;,&quot; *&quot;,&quot; * Major caveat 3 - This class uses typed arrays and must not be used on older&quot;,&quot; * browsers that do not support them.&quot;,&quot; *&quot;,&quot; * @author aappleby@google.com (Austin Appleby)&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;jspb.BinaryWriter&#39;);&quot;,null,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;goog.crypt.base64&#39;);&quot;,&quot;goog.require(&#39;jspb.BinaryConstants&#39;);&quot;,&quot;goog.require(&#39;jspb.BinaryEncoder&#39;);&quot;,&quot;goog.require(&#39;jspb.arith.Int64&#39;);&quot;,&quot;goog.require(&#39;jspb.arith.UInt64&#39;);&quot;,&quot;goog.require(&#39;jspb.utils&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * BinaryWriter implements encoders for all the wire types specified in&quot;,&quot; * https://developers.google.com/protocol-buffers/docs/encoding.&quot;,&quot; *&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter = function() {&quot;,&quot;  /**&quot;,&quot;   * Blocks of serialized data that will be concatenated once all messages have&quot;,&quot;   * been written.&quot;,&quot;   * @private {!Array&lt;!Uint8Array|!Array&lt;number&gt;&gt;}&quot;,&quot;   */&quot;,&quot;  this.blocks_ = [];&quot;,null,&quot;  /**&quot;,&quot;   * Total number of bytes in the blocks_ array. Does _not_ include bytes in&quot;,&quot;   * the encoder below.&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.totalLength_ = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Binary encoder holding pieces of a message that we&#39;re still serializing.&quot;,&quot;   * When we get to a stopping point (either the start of a new submessage, or&quot;,&quot;   * when we need to append a raw Uint8Array), the encoder&#39;s buffer will be&quot;,&quot;   * added to the block array above and the encoder will be reset.&quot;,&quot;   * @private {!jspb.BinaryEncoder}&quot;,&quot;   */&quot;,&quot;  this.encoder_ = new jspb.BinaryEncoder();&quot;,null,&quot;  /**&quot;,&quot;   * A stack of bookmarks containing the parent blocks for each message started&quot;,&quot;   * via beginSubMessage(), needed as bookkeeping for endSubMessage().&quot;,&quot;   * TODO(aappleby): Deprecated, users should be calling writeMessage().&quot;,&quot;   * @private {!Array&lt;!Array&lt;number&gt;&gt;}&quot;,&quot;   */&quot;,&quot;  this.bookmarks_ = [];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Append a typed array of bytes onto the buffer.&quot;,&quot; *&quot;,&quot; * @param {!Uint8Array} arr The byte array to append.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.appendUint8Array_ = function(arr) {&quot;,&quot;  var temp = this.encoder_.end();&quot;,&quot;  this.blocks_.push(temp);&quot;,&quot;  this.blocks_.push(arr);&quot;,&quot;  this.totalLength_ += temp.length + arr.length;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Begins a new message by writing the field header and returning a bookmark&quot;,&quot; * which we will use to patch in the message length to in endDelimited_ below.&quot;,&quot; * @param {number} field&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.beginDelimited_ = function(field) {&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  var bookmark = this.encoder_.end();&quot;,&quot;  this.blocks_.push(bookmark);&quot;,&quot;  this.totalLength_ += bookmark.length;&quot;,&quot;  bookmark.push(this.totalLength_);&quot;,&quot;  return bookmark;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Ends a message by encoding the _change_ in length of the buffer to the&quot;,&quot; * parent block and adds the number of bytes needed to encode that length to&quot;,&quot; * the total byte length.&quot;,&quot; * @param {!Array&lt;number&gt;} bookmark&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.endDelimited_ = function(bookmark) {&quot;,&quot;  var oldLength = bookmark.pop();&quot;,&quot;  var messageLength = this.totalLength_ + this.encoder_.length() - oldLength;&quot;,&quot;  goog.asserts.assert(messageLength &gt;= 0);&quot;,null,&quot;  while (messageLength &gt; 127) {&quot;,&quot;    bookmark.push((messageLength &amp; 0x7f) | 0x80);&quot;,&quot;    messageLength = messageLength &gt;&gt;&gt; 7;&quot;,&quot;    this.totalLength_++;&quot;,&quot;  }&quot;,null,&quot;  bookmark.push(messageLength);&quot;,&quot;  this.totalLength_++;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a pre-serialized message to the buffer.&quot;,&quot; * @param {!Uint8Array} bytes The array of bytes to write.&quot;,&quot; * @param {number} start The start of the range to write.&quot;,&quot; * @param {number} end The end of the range to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeSerializedMessage = function(&quot;,&quot;    bytes, start, end) {&quot;,&quot;  this.appendUint8Array_(bytes.subarray(start, end));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a pre-serialized message to the buffer if the message and endpoints&quot;,&quot; * are non-null.&quot;,&quot; * @param {?Uint8Array} bytes The array of bytes to write.&quot;,&quot; * @param {?number} start The start of the range to write.&quot;,&quot; * @param {?number} end The end of the range to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.maybeWriteSerializedMessage = function(&quot;,&quot;    bytes, start, end) {&quot;,&quot;  if (bytes != null &amp;&amp; start != null &amp;&amp; end != null) {&quot;,&quot;    this.writeSerializedMessage(bytes, start, end);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Resets the writer, throwing away any accumulated buffers.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.reset = function() {&quot;,&quot;  this.blocks_ = [];&quot;,&quot;  this.encoder_.end();&quot;,&quot;  this.totalLength_ = 0;&quot;,&quot;  this.bookmarks_ = [];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts the encoded data into a Uint8Array.&quot;,&quot; * @return {!Uint8Array}&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.getResultBuffer = function() {&quot;,&quot;  goog.asserts.assert(this.bookmarks_.length == 0);&quot;,null,&quot;  var flat = new Uint8Array(this.totalLength_ + this.encoder_.length());&quot;,null,&quot;  var blocks = this.blocks_;&quot;,&quot;  var blockCount = blocks.length;&quot;,&quot;  var offset = 0;&quot;,null,&quot;  for (var i = 0; i &lt; blockCount; i++) {&quot;,&quot;    var block = blocks[i];&quot;,&quot;    flat.set(block, offset);&quot;,&quot;    offset += block.length;&quot;,&quot;  }&quot;,null,&quot;  var tail = this.encoder_.end();&quot;,&quot;  flat.set(tail, offset);&quot;,&quot;  offset += tail.length;&quot;,null,&quot;  // Post condition: `flattened` must have had every byte written.&quot;,&quot;  goog.asserts.assert(offset == flat.length);&quot;,null,&quot;  // Replace our block list with the flattened block, which lets GC reclaim&quot;,&quot;  // the temp blocks sooner.&quot;,&quot;  this.blocks_ = [flat];&quot;,null,&quot;  return flat;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts the encoded data into a base64-encoded string.&quot;,&quot; * @return {string}&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.getResultBase64String = function() {&quot;,&quot;  return goog.crypt.base64.encodeByteArray(this.getResultBuffer());&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Begins a new sub-message. The client must call endSubMessage() when they&#39;re&quot;,&quot; * done.&quot;,&quot; * TODO(aappleby): Deprecated. Move callers to writeMessage().&quot;,&quot; * @param {number} field The field number of the sub-message.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.beginSubMessage = function(field) {&quot;,&quot;  this.bookmarks_.push(this.beginDelimited_(field));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Finishes a sub-message and packs it into the parent messages&#39; buffer.&quot;,&quot; * TODO(aappleby): Deprecated. Move callers to writeMessage().&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.endSubMessage = function() {&quot;,&quot;  goog.asserts.assert(this.bookmarks_.length &gt;= 0);&quot;,&quot;  this.endDelimited_(this.bookmarks_.pop());&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Encodes a (field number, wire type) tuple into a wire-format field header&quot;,&quot; * and stores it in the buffer as a varint.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number} wireType The wire-type of the field, as specified in the&quot;,&quot; *     protocol buffer documentation.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeFieldHeader_ =&quot;,&quot;    function(field, wireType) {&quot;,&quot;  goog.asserts.assert(field &gt;= 1 &amp;&amp; field == Math.floor(field));&quot;,&quot;  var x = field * 8 + wireType;&quot;,&quot;  this.encoder_.writeUnsignedVarint32(x);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a field of any valid scalar type to the binary stream.&quot;,&quot; * @param {jspb.BinaryConstants.FieldType} fieldType&quot;,&quot; * @param {number} field&quot;,&quot; * @param {jspb.AnyFieldType} value&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeAny = function(fieldType, field, value) {&quot;,&quot;  var fieldTypes = jspb.BinaryConstants.FieldType;&quot;,&quot;  switch (fieldType) {&quot;,&quot;    case fieldTypes.DOUBLE:&quot;,&quot;      this.writeDouble(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.FLOAT:&quot;,&quot;      this.writeFloat(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.INT64:&quot;,&quot;      this.writeInt64(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.UINT64:&quot;,&quot;      this.writeUint64(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.INT32:&quot;,&quot;      this.writeInt32(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.FIXED64:&quot;,&quot;      this.writeFixed64(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.FIXED32:&quot;,&quot;      this.writeFixed32(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.BOOL:&quot;,&quot;      this.writeBool(field, /** @type {boolean} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.STRING:&quot;,&quot;      this.writeString(field, /** @type {string} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.GROUP:&quot;,&quot;      goog.asserts.fail(&#39;Group field type not supported in writeAny()&#39;);&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.MESSAGE:&quot;,&quot;      goog.asserts.fail(&#39;Message field type not supported in writeAny()&#39;);&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.BYTES:&quot;,&quot;      this.writeBytes(field, /** @type {?Uint8Array} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.UINT32:&quot;,&quot;      this.writeUint32(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.ENUM:&quot;,&quot;      this.writeEnum(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.SFIXED32:&quot;,&quot;      this.writeSfixed32(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.SFIXED64:&quot;,&quot;      this.writeSfixed64(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.SINT32:&quot;,&quot;      this.writeSint32(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.SINT64:&quot;,&quot;      this.writeSint64(field, /** @type {number} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.FHASH64:&quot;,&quot;      this.writeFixedHash64(field, /** @type {string} */(value));&quot;,&quot;      return;&quot;,&quot;    case fieldTypes.VHASH64:&quot;,&quot;      this.writeVarintHash64(field, /** @type {string} */(value));&quot;,&quot;      return;&quot;,&quot;    default:&quot;,&quot;      goog.asserts.fail(&#39;Invalid field type in writeAny()&#39;);&quot;,&quot;      return;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a varint field to the buffer without range checking.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeUnsignedVarint32_ = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  this.encoder_.writeUnsignedVarint32(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a varint field to the buffer without range checking.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeSignedVarint32_ = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  this.encoder_.writeSignedVarint32(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a varint field to the buffer without range checking.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeUnsignedVarint64_ = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  this.encoder_.writeUnsignedVarint64(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a varint field to the buffer without range checking.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeSignedVarint64_ = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  this.encoder_.writeSignedVarint64(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a zigzag varint field to the buffer without range checking.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeZigzagVarint32_ = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  this.encoder_.writeZigzagVarint32(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a zigzag varint field to the buffer without range checking.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeZigzagVarint64_ = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  this.encoder_.writeZigzagVarint64(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a zigzag varint field to the buffer without range checking.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {string?} value The value to write.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeZigzagVarint64String_ = function(&quot;,&quot;    field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  this.encoder_.writeZigzagVarint64String(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an int32 field to the buffer. Numbers outside the range [-2^31,2^31)&quot;,&quot; * will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeInt32 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_31) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_31));&quot;,&quot;  this.writeSignedVarint32_(field, value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an int32 field represented as a string to the buffer. Numbers outside&quot;,&quot; * the range [-2^31,2^31) will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {string?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeInt32String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  var intValue = /** {number} */ parseInt(value, 10);&quot;,&quot;  goog.asserts.assert((intValue &gt;= -jspb.BinaryConstants.TWO_TO_31) &amp;&amp;&quot;,&quot;                      (intValue &lt; jspb.BinaryConstants.TWO_TO_31));&quot;,&quot;  this.writeSignedVarint32_(field, intValue);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an int64 field to the buffer. Numbers outside the range [-2^63,2^63)&quot;,&quot; * will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeInt64 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_63) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_63));&quot;,&quot;  this.writeSignedVarint64_(field, value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a int64 field (with value as a string) to the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {string?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeInt64String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  var num = jspb.arith.Int64.fromString(value);&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  this.encoder_.writeSplitVarint64(num.lo, num.hi);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a uint32 field to the buffer. Numbers outside the range [0,2^32)&quot;,&quot; * will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeUint32 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert((value &gt;= 0) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_32));&quot;,&quot;  this.writeUnsignedVarint32_(field, value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a uint32 field represented as a string to the buffer. Numbers outside&quot;,&quot; * the range [0,2^32) will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {string?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeUint32String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  var intValue = /** {number} */ parseInt(value, 10);&quot;,&quot;  goog.asserts.assert((intValue &gt;= 0) &amp;&amp;&quot;,&quot;                      (intValue &lt; jspb.BinaryConstants.TWO_TO_32));&quot;,&quot;  this.writeUnsignedVarint32_(field, intValue);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a uint64 field to the buffer. Numbers outside the range [0,2^64)&quot;,&quot; * will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeUint64 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert((value &gt;= 0) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_64));&quot;,&quot;  this.writeUnsignedVarint64_(field, value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a uint64 field (with value as a string) to the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {string?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeUint64String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  var num = jspb.arith.UInt64.fromString(value);&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  this.encoder_.writeSplitVarint64(num.lo, num.hi);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a sint32 field to the buffer. Numbers outside the range [-2^31,2^31)&quot;,&quot; * will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeSint32 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_31) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_31));&quot;,&quot;  this.writeZigzagVarint32_(field, value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a sint64 field to the buffer. Numbers outside the range [-2^63,2^63)&quot;,&quot; * will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeSint64 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_63) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_63));&quot;,&quot;  this.writeZigzagVarint64_(field, value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a sint64 field to the buffer. Numbers outside the range [-2^63,2^63)&quot;,&quot; * will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {string?} value The decimal string to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeSint64String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert((+value &gt;= -jspb.BinaryConstants.TWO_TO_63) &amp;&amp;&quot;,&quot;                      (+value &lt; jspb.BinaryConstants.TWO_TO_63));&quot;,&quot;  this.writeZigzagVarint64String_(field, value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a fixed32 field to the buffer. Numbers outside the range [0,2^32)&quot;,&quot; * will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeFixed32 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert((value &gt;= 0) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_32));&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.FIXED32);&quot;,&quot;  this.encoder_.writeUint32(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a fixed64 field to the buffer. Numbers outside the range [0,2^64)&quot;,&quot; * will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeFixed64 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert((value &gt;= 0) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_64));&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.FIXED64);&quot;,&quot;  this.encoder_.writeUint64(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a fixed64 field (with value as a string) to the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {string?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeFixed64String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  var num = jspb.arith.UInt64.fromString(value);&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.FIXED64);&quot;,&quot;  this.encoder_.writeSplitFixed64(num.lo, num.hi);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a sfixed32 field to the buffer. Numbers outside the range&quot;,&quot; * [-2^31,2^31) will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeSfixed32 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_31) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_31));&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.FIXED32);&quot;,&quot;  this.encoder_.writeInt32(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a sfixed64 field to the buffer. Numbers outside the range&quot;,&quot; * [-2^63,2^63) will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeSfixed64 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_63) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_63));&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.FIXED64);&quot;,&quot;  this.encoder_.writeInt64(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a sfixed64 string field to the buffer. Numbers outside the range&quot;,&quot; * [-2^63,2^63) will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {string?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeSfixed64String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  var num = jspb.arith.Int64.fromString(value);&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.FIXED64);&quot;,&quot;  this.encoder_.writeSplitFixed64(num.lo, num.hi);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a single-precision floating point field to the buffer. Numbers&quot;,&quot; * requiring more than 32 bits of precision will be truncated.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeFloat = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.FIXED32);&quot;,&quot;  this.encoder_.writeFloat(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a double-precision floating point field to the buffer. As this is the&quot;,&quot; * native format used by JavaScript, no precision will be lost.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeDouble = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.FIXED64);&quot;,&quot;  this.encoder_.writeDouble(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a boolean field to the buffer. We allow numbers as input&quot;,&quot; * because the JSPB code generator uses 0/1 instead of true/false to save space&quot;,&quot; * in the string representation of the proto.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {boolean?|number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeBool = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert(goog.isBoolean(value) || goog.isNumber(value));&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  this.encoder_.writeBool(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an enum field to the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {number?} value The value to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeEnum = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert((value &gt;= -jspb.BinaryConstants.TWO_TO_31) &amp;&amp;&quot;,&quot;                      (value &lt; jspb.BinaryConstants.TWO_TO_31));&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  this.encoder_.writeSignedVarint32(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a string field to the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {string?} value The string to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeString = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  this.encoder_.writeString(value);&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an arbitrary byte field to the buffer. Note - to match the behavior&quot;,&quot; * of the C++ implementation, empty byte arrays _are_ serialized.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?jspb.ByteSource} value The array of bytes to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeBytes = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  var bytes = jspb.utils.byteSourceToUint8Array(value);&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  this.encoder_.writeUnsignedVarint32(bytes.length);&quot;,&quot;  this.appendUint8Array_(bytes);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a message to the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?MessageType} value The message to write.&quot;,&quot; * @param {function(MessageTypeNonNull, !jspb.BinaryWriter)} writerCallback&quot;,&quot; *     Will be invoked with the value to write and the writer to write it with.&quot;,&quot; * @template MessageType&quot;,&quot; * Use go/closure-ttl to declare a non-nullable version of MessageType.  Replace&quot;,&quot; * the null in blah|null with none.  This is necessary because the compiler will&quot;,&quot; * infer MessageType to be nullable if the value parameter is nullable.&quot;,&quot; * @template MessageTypeNonNull :=&quot;,&quot; *     cond(isUnknown(MessageType), unknown(),&quot;,&quot; *       mapunion(MessageType, (X) =&gt;&quot;,&quot; *         cond(eq(X, &#39;null&#39;), none(), X)))&quot;,&quot; * =:&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeMessage = function(&quot;,&quot;    field, value, writerCallback) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  writerCallback(value, this);&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a group message to the buffer.&quot;,&quot; *&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?MessageType} value The message to write, wrapped with START_GROUP /&quot;,&quot; *     END_GROUP tags. Will be a no-op if &#39;value&#39; is null.&quot;,&quot; * @param {function(MessageTypeNonNull, !jspb.BinaryWriter)} writerCallback&quot;,&quot; *     Will be invoked with the value to write and the writer to write it with.&quot;,&quot; * @template MessageType&quot;,&quot; * Use go/closure-ttl to declare a non-nullable version of MessageType.  Replace&quot;,&quot; * the null in blah|null with none.  This is necessary because the compiler will&quot;,&quot; * infer MessageType to be nullable if the value parameter is nullable.&quot;,&quot; * @template MessageTypeNonNull :=&quot;,&quot; *     cond(isUnknown(MessageType), unknown(),&quot;,&quot; *       mapunion(MessageType, (X) =&gt;&quot;,&quot; *         cond(eq(X, &#39;null&#39;), none(), X)))&quot;,&quot; * =:&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeGroup = function(&quot;,&quot;    field, value, writerCallback) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.START_GROUP);&quot;,&quot;  writerCallback(value, this);&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.END_GROUP);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 64-bit hash string field (8 characters @ 8 bits of data each) to&quot;,&quot; * the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {string?} value The hash string.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeFixedHash64 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert(value.length == 8);&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.FIXED64);&quot;,&quot;  this.encoder_.writeFixedHash64(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 64-bit hash string field (8 characters @ 8 bits of data each) to&quot;,&quot; * the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {string?} value The hash string.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeVarintHash64 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  goog.asserts.assert(value.length == 8);&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  this.encoder_.writeVarintHash64(value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a repeated 32-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedInt32 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeSignedVarint32_(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers formatted as strings to the buffer as a repeated&quot;,&quot; * 32-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedInt32String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeInt32String(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a repeated 64-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedInt64 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeSignedVarint64_(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers formatted as strings to the buffer as a repeated&quot;,&quot; * 64-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedInt64String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeInt64String(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array numbers to the buffer as a repeated unsigned 32-bit int&quot;,&quot; *     field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedUint32 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeUnsignedVarint32_(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers formatted as strings to the buffer as a repeated&quot;,&quot; * unsigned 32-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedUint32String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeUint32String(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array numbers to the buffer as a repeated unsigned 64-bit int&quot;,&quot; *     field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedUint64 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeUnsignedVarint64_(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers formatted as strings to the buffer as a repeated&quot;,&quot; * unsigned 64-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedUint64String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeUint64String(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array numbers to the buffer as a repeated signed 32-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedSint32 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeZigzagVarint32_(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array numbers to the buffer as a repeated signed 64-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedSint64 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeZigzagVarint64_(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array numbers to the buffer as a repeated signed 64-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedSint64String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeZigzagVarint64String_(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a repeated fixed32 field. This&quot;,&quot; * works for both signed and unsigned fixed32s.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedFixed32 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeFixed32(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a repeated fixed64 field. This&quot;,&quot; * works for both signed and unsigned fixed64s.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedFixed64 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeFixed64(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a repeated fixed64 field. This&quot;,&quot; * works for both signed and unsigned fixed64s.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of decimal strings to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedFixed64String = function(&quot;,&quot;    field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeFixed64String(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a repeated sfixed32 field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedSfixed32 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeSfixed32(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a repeated sfixed64 field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedSfixed64 = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeSfixed64(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of decimal strings to the buffer as a repeated sfixed64&quot;,&quot; * field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of decimal strings to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedSfixed64String = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeSfixed64String(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a repeated float field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedFloat = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeFloat(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a repeated double field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedDouble = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeDouble(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of booleans to the buffer as a repeated bool field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;boolean&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedBool = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeBool(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of enums to the buffer as a repeated enum field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedEnum = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeEnum(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of strings to the buffer as a repeated string field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of strings to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedString = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeString(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of arbitrary byte fields to the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;!jspb.ByteSource&gt;} value The arrays of arrays of bytes to&quot;,&quot; *     write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedBytes = function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeBytes(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of messages to the buffer.&quot;,&quot; * @template MessageType&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;MessageType&gt;} value The array of messages to&quot;,&quot; *    write.&quot;,&quot; * @param {function(MessageType, !jspb.BinaryWriter)} writerCallback&quot;,&quot; *     Will be invoked with the value to write and the writer to write it with.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedMessage = function(&quot;,&quot;    field, value, writerCallback) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    var bookmark = this.beginDelimited_(field);&quot;,&quot;    writerCallback(value[i], this);&quot;,&quot;    this.endDelimited_(bookmark);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of group messages to the buffer.&quot;,&quot; * @template MessageType&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;MessageType&gt;} value The array of messages to&quot;,&quot; *    write.&quot;,&quot; * @param {function(MessageType, !jspb.BinaryWriter)} writerCallback&quot;,&quot; *     Will be invoked with the value to write and the writer to write it with.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedGroup = function(&quot;,&quot;    field, value, writerCallback) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.START_GROUP);&quot;,&quot;    writerCallback(value[i], this);&quot;,&quot;    this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.END_GROUP);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 64-bit hash string field (8 characters @ 8 bits of data each) to&quot;,&quot; * the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of hashes to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedFixedHash64 =&quot;,&quot;    function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeFixedHash64(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a repeated 64-bit hash string field (8 characters @ 8 bits of data&quot;,&quot; * each) to the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of hashes to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writeRepeatedVarintHash64 =&quot;,&quot;    function(field, value) {&quot;,&quot;  if (value == null) return;&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.writeVarintHash64(field, value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a packed 32-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedInt32 = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeSignedVarint32(value[i]);&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers represented as strings to the buffer as a packed&quot;,&quot; * 32-bit int field.&quot;,&quot; * @param {number} field&quot;,&quot; * @param {?Array&lt;string&gt;} value&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedInt32String = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeSignedVarint32(parseInt(value[i], 10));&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a packed 64-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedInt64 = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeSignedVarint64(value[i]);&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers represented as strings to the buffer as a packed&quot;,&quot; * 64-bit int field.&quot;,&quot; * @param {number} field&quot;,&quot; * @param {?Array&lt;string&gt;} value&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedInt64String = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    var num = jspb.arith.Int64.fromString(value[i]);&quot;,&quot;    this.encoder_.writeSplitVarint64(num.lo, num.hi);&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array numbers to the buffer as a packed unsigned 32-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedUint32 = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeUnsignedVarint32(value[i]);&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers represented as strings to the buffer as a packed&quot;,&quot; * unsigned 32-bit int field.&quot;,&quot; * @param {number} field&quot;,&quot; * @param {?Array&lt;string&gt;} value&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedUint32String =&quot;,&quot;    function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeUnsignedVarint32(parseInt(value[i], 10));&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array numbers to the buffer as a packed unsigned 64-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedUint64 = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeUnsignedVarint64(value[i]);&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers represented as strings to the buffer as a packed&quot;,&quot; * unsigned 64-bit int field.&quot;,&quot; * @param {number} field&quot;,&quot; * @param {?Array&lt;string&gt;} value&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedUint64String =&quot;,&quot;    function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    var num = jspb.arith.UInt64.fromString(value[i]);&quot;,&quot;    this.encoder_.writeSplitVarint64(num.lo, num.hi);&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array numbers to the buffer as a packed signed 32-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedSint32 = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeZigzagVarint32(value[i]);&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a packed signed 64-bit int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedSint64 = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeZigzagVarint64(value[i]);&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of decimal strings to the buffer as a packed signed 64-bit&quot;,&quot; * int field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of decimal strings to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedSint64String = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    // TODO(haberman): make lossless&quot;,&quot;    this.encoder_.writeZigzagVarint64(parseInt(value[i], 10));&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a packed fixed32 field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedFixed32 = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  this.encoder_.writeUnsignedVarint32(value.length * 4);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeUint32(value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a packed fixed64 field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedFixed64 = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  this.encoder_.writeUnsignedVarint32(value.length * 8);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeUint64(value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers represented as strings to the buffer as a packed&quot;,&quot; * fixed64 field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of strings to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedFixed64String = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  this.encoder_.writeUnsignedVarint32(value.length * 8);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    var num = jspb.arith.UInt64.fromString(value[i]);&quot;,&quot;    this.encoder_.writeSplitFixed64(num.lo, num.hi);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a packed sfixed32 field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedSfixed32 = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  this.encoder_.writeUnsignedVarint32(value.length * 4);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeInt32(value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a packed sfixed64 field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedSfixed64 = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  this.encoder_.writeUnsignedVarint32(value.length * 8);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeInt64(value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a packed sfixed64 field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of decimal strings to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedSfixed64String = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  this.encoder_.writeUnsignedVarint32(value.length * 8);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeInt64String(value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a packed float field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedFloat = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  this.encoder_.writeUnsignedVarint32(value.length * 4);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeFloat(value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of numbers to the buffer as a packed double field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedDouble = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  this.encoder_.writeUnsignedVarint32(value.length * 8);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeDouble(value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of booleans to the buffer as a packed bool field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;boolean&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedBool = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  this.encoder_.writeUnsignedVarint32(value.length);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeBool(value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes an array of enums to the buffer as a packed enum field.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;number&gt;} value The array of ints to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedEnum = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeEnum(value[i]);&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 64-bit hash string field (8 characters @ 8 bits of data each) to&quot;,&quot; * the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of hashes to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedFixedHash64 = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  this.writeFieldHeader_(field, jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  this.encoder_.writeUnsignedVarint32(value.length * 8);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeFixedHash64(value[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a 64-bit hash string field (8 characters @ 8 bits of data each) to&quot;,&quot; * the buffer.&quot;,&quot; * @param {number} field The field number.&quot;,&quot; * @param {?Array&lt;string&gt;} value The array of hashes to write.&quot;,&quot; */&quot;,&quot;jspb.BinaryWriter.prototype.writePackedVarintHash64 = function(field, value) {&quot;,&quot;  if (value == null || !value.length) return;&quot;,&quot;  var bookmark = this.beginDelimited_(field);&quot;,&quot;  for (var i = 0; i &lt; value.length; i++) {&quot;,&quot;    this.encoder_.writeVarintHash64(value[i]);&quot;,&quot;  }&quot;,&quot;  this.endDelimited_(bookmark);&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../dossier.js" defer></script>