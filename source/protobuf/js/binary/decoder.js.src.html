<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>decoder.js</title><link href="../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;decoder.js&quot;,&quot;protobuf/js/binary/decoder.js&quot;,[&quot;// Protocol Buffers - Google&#39;s data interchange format&quot;,&quot;// Copyright 2008 Google Inc.  All rights reserved.&quot;,&quot;// https://developers.google.com/protocol-buffers/&quot;,&quot;//&quot;,&quot;// Redistribution and use in source and binary forms, with or without&quot;,&quot;// modification, are permitted provided that the following conditions are&quot;,&quot;// met:&quot;,&quot;//&quot;,&quot;//     * Redistributions of source code must retain the above copyright&quot;,&quot;// notice, this list of conditions and the following disclaimer.&quot;,&quot;//     * Redistributions in binary form must reproduce the above&quot;,&quot;// copyright notice, this list of conditions and the following disclaimer&quot;,&quot;// in the documentation and/or other materials provided with the&quot;,&quot;// distribution.&quot;,&quot;//     * Neither the name of Google Inc. nor the names of its&quot;,&quot;// contributors may be used to endorse or promote products derived from&quot;,&quot;// this software without specific prior written permission.&quot;,&quot;//&quot;,&quot;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;,&quot;// \&quot;AS IS\&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR&quot;,&quot;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&quot;,&quot;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&quot;,&quot;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,&quot;,&quot;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY&quot;,&quot;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&quot;,&quot;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&quot;,&quot;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview This file contains utilities for decoding primitive values&quot;,&quot; * (signed and unsigned integers, varints, booleans, enums, hashes, strings,&quot;,&quot; * and raw bytes) embedded in Uint8Arrays into their corresponding Javascript&quot;,&quot; * types.&quot;,&quot; *&quot;,&quot; * Major caveat - Javascript is unable to accurately represent integers larger&quot;,&quot; * than 2^53 due to its use of a double-precision floating point format or all&quot;,&quot; * numbers. If you need to guarantee that 64-bit values survive with all bits&quot;,&quot; * intact, you _must_ read them using one of the Hash64 methods, which return&quot;,&quot; * an 8-character string.&quot;,&quot; *&quot;,&quot; * @author aappleby@google.com (Austin Appleby)&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;jspb.BinaryDecoder&#39;);&quot;,&quot;goog.provide(&#39;jspb.BinaryIterator&#39;);&quot;,null,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;goog.crypt&#39;);&quot;,&quot;goog.require(&#39;jspb.utils&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * Simple helper class for traversing the contents of repeated scalar fields.&quot;,&quot; * that may or may not have been packed into a wire-format blob.&quot;,&quot; * @param {?jspb.BinaryDecoder=} opt_decoder&quot;,&quot; * @param {?function(this:jspb.BinaryDecoder):(number|boolean|string)=}&quot;,&quot; *     opt_next The decoder method to use for next().&quot;,&quot; * @param {?Array&lt;number|boolean|string&gt;=} opt_elements&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; */&quot;,&quot;jspb.BinaryIterator = function(opt_decoder, opt_next, opt_elements) {&quot;,&quot;  /** @private {jspb.BinaryDecoder} */&quot;,&quot;  this.decoder_ = null;&quot;,null,&quot;  /**&quot;,&quot;   * The BinaryDecoder member function used when iterating over packed data.&quot;,&quot;   * @private {?function(this:jspb.BinaryDecoder):(number|boolean|string)}&quot;,&quot;   */&quot;,&quot;  this.nextMethod_ = null;&quot;,null,&quot;  /** @private {?Array&lt;number|boolean|string&gt;} */&quot;,&quot;  this.elements_ = null;&quot;,null,&quot;  /** @private {number} */&quot;,&quot;  this.cursor_ = 0;&quot;,null,&quot;  /** @private {number|boolean|string|null} */&quot;,&quot;  this.nextValue_ = null;&quot;,null,&quot;  /** @private {boolean} */&quot;,&quot;  this.atEnd_ = true;&quot;,null,&quot;  this.init_(opt_decoder, opt_next, opt_elements);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {?jspb.BinaryDecoder=} opt_decoder&quot;,&quot; * @param {?function(this:jspb.BinaryDecoder):(number|boolean|string)=}&quot;,&quot; *     opt_next The decoder method to use for next().&quot;,&quot; * @param {?Array&lt;number|boolean|string&gt;=} opt_elements&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryIterator.prototype.init_ =&quot;,&quot;    function(opt_decoder, opt_next, opt_elements) {&quot;,&quot;  if (opt_decoder &amp;&amp; opt_next) {&quot;,&quot;    this.decoder_ = opt_decoder;&quot;,&quot;    this.nextMethod_ = opt_next;&quot;,&quot;  }&quot;,&quot;  this.elements_ = opt_elements || null;&quot;,&quot;  this.cursor_ = 0;&quot;,&quot;  this.nextValue_ = null;&quot;,&quot;  this.atEnd_ = !this.decoder_ &amp;&amp; !this.elements_;&quot;,null,&quot;  this.next();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Global pool of BinaryIterator instances.&quot;,&quot; * @private {!Array&lt;!jspb.BinaryIterator&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryIterator.instanceCache_ = [];&quot;,null,null,&quot;/**&quot;,&quot; * Allocates a BinaryIterator from the cache, creating a new one if the cache&quot;,&quot; * is empty.&quot;,&quot; * @param {?jspb.BinaryDecoder=} opt_decoder&quot;,&quot; * @param {?function(this:jspb.BinaryDecoder):(number|boolean|string)=}&quot;,&quot; *     opt_next The decoder method to use for next().&quot;,&quot; * @param {?Array&lt;number|boolean|string&gt;=} opt_elements&quot;,&quot; * @return {!jspb.BinaryIterator}&quot;,&quot; */&quot;,&quot;jspb.BinaryIterator.alloc = function(opt_decoder, opt_next, opt_elements) {&quot;,&quot;  if (jspb.BinaryIterator.instanceCache_.length) {&quot;,&quot;    var iterator = jspb.BinaryIterator.instanceCache_.pop();&quot;,&quot;    iterator.init_(opt_decoder, opt_next, opt_elements);&quot;,&quot;    return iterator;&quot;,&quot;  } else {&quot;,&quot;    return new jspb.BinaryIterator(opt_decoder, opt_next, opt_elements);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Puts this instance back in the instance cache.&quot;,&quot; */&quot;,&quot;jspb.BinaryIterator.prototype.free = function() {&quot;,&quot;  this.clear();&quot;,&quot;  if (jspb.BinaryIterator.instanceCache_.length &lt; 100) {&quot;,&quot;    jspb.BinaryIterator.instanceCache_.push(this);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Clears the iterator.&quot;,&quot; */&quot;,&quot;jspb.BinaryIterator.prototype.clear = function() {&quot;,&quot;  if (this.decoder_) {&quot;,&quot;    this.decoder_.free();&quot;,&quot;  }&quot;,&quot;  this.decoder_ = null;&quot;,&quot;  this.nextMethod_ = null;&quot;,&quot;  this.elements_ = null;&quot;,&quot;  this.cursor_ = 0;&quot;,&quot;  this.nextValue_ = null;&quot;,&quot;  this.atEnd_ = true;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the element at the iterator, or null if the iterator is invalid or&quot;,&quot; * past the end of the decoder/array.&quot;,&quot; * @return {number|boolean|string|null}&quot;,&quot; */&quot;,&quot;jspb.BinaryIterator.prototype.get = function() {&quot;,&quot;  return this.nextValue_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if the iterator is at the end of the decoder/array.&quot;,&quot; * @return {boolean}&quot;,&quot; */&quot;,&quot;jspb.BinaryIterator.prototype.atEnd = function() {&quot;,&quot;  return this.atEnd_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the element at the iterator and steps to the next element,&quot;,&quot; * equivalent to &#39;*pointer++&#39; in C.&quot;,&quot; * @return {number|boolean|string|null}&quot;,&quot; */&quot;,&quot;jspb.BinaryIterator.prototype.next = function() {&quot;,&quot;  var lastValue = this.nextValue_;&quot;,&quot;  if (this.decoder_) {&quot;,&quot;    if (this.decoder_.atEnd()) {&quot;,&quot;      this.nextValue_ = null;&quot;,&quot;      this.atEnd_ = true;&quot;,&quot;    } else {&quot;,&quot;      this.nextValue_ = this.nextMethod_.call(this.decoder_);&quot;,&quot;    }&quot;,&quot;  } else if (this.elements_) {&quot;,&quot;    if (this.cursor_ == this.elements_.length) {&quot;,&quot;      this.nextValue_ = null;&quot;,&quot;      this.atEnd_ = true;&quot;,&quot;    } else {&quot;,&quot;      this.nextValue_ = this.elements_[this.cursor_++];&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return lastValue;&quot;,&quot;};&quot;,null,null,null,&quot;/**&quot;,&quot; * BinaryDecoder implements the decoders for all the wire types specified in&quot;,&quot; * https://developers.google.com/protocol-buffers/docs/encoding.&quot;,&quot; *&quot;,&quot; * @param {jspb.ByteSource=} opt_bytes The bytes we&#39;re reading from.&quot;,&quot; * @param {number=} opt_start The optional offset to start reading at.&quot;,&quot; * @param {number=} opt_length The optional length of the block to read -&quot;,&quot; *     we&#39;ll throw an assertion if we go off the end of the block.&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder = function(opt_bytes, opt_start, opt_length) {&quot;,&quot;  /**&quot;,&quot;   * Typed byte-wise view of the source buffer.&quot;,&quot;   * @private {?Uint8Array}&quot;,&quot;   */&quot;,&quot;  this.bytes_ = null;&quot;,null,&quot;  /**&quot;,&quot;   * Start point of the block to read.&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.start_ = 0;&quot;,null,&quot;  /**&quot;,&quot;   * End point of the block to read.&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.end_ = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Current read location in bytes_.&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.cursor_ = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Temporary storage for the low 32 bits of 64-bit data types that we&#39;re&quot;,&quot;   * decoding.&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.tempLow_ = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Temporary storage for the high 32 bits of 64-bit data types that we&#39;re&quot;,&quot;   * decoding.&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.tempHigh_ = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Set to true if this decoder encountered an error due to corrupt data.&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.error_ = false;&quot;,null,&quot;  if (opt_bytes) {&quot;,&quot;    this.setBlock(opt_bytes, opt_start, opt_length);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Global pool of BinaryDecoder instances.&quot;,&quot; * @private {!Array&lt;!jspb.BinaryDecoder&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.instanceCache_ = [];&quot;,null,null,&quot;/**&quot;,&quot; * Pops an instance off the instance cache, or creates one if the cache is&quot;,&quot; * empty.&quot;,&quot; * @param {jspb.ByteSource=} opt_bytes The bytes we&#39;re reading from.&quot;,&quot; * @param {number=} opt_start The optional offset to start reading at.&quot;,&quot; * @param {number=} opt_length The optional length of the block to read -&quot;,&quot; *     we&#39;ll throw an assertion if we go off the end of the block.&quot;,&quot; * @return {!jspb.BinaryDecoder}&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.alloc = function(opt_bytes, opt_start, opt_length) {&quot;,&quot;  if (jspb.BinaryDecoder.instanceCache_.length) {&quot;,&quot;    var newDecoder = jspb.BinaryDecoder.instanceCache_.pop();&quot;,&quot;    if (opt_bytes) {&quot;,&quot;      newDecoder.setBlock(opt_bytes, opt_start, opt_length);&quot;,&quot;    }&quot;,&quot;    return newDecoder;&quot;,&quot;  } else {&quot;,&quot;    return new jspb.BinaryDecoder(opt_bytes, opt_start, opt_length);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Puts this instance back in the instance cache.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.free = function() {&quot;,&quot;  this.clear();&quot;,&quot;  if (jspb.BinaryDecoder.instanceCache_.length &lt; 100) {&quot;,&quot;    jspb.BinaryDecoder.instanceCache_.push(this);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Makes a copy of this decoder.&quot;,&quot; * @return {!jspb.BinaryDecoder}&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.clone = function() {&quot;,&quot;  return jspb.BinaryDecoder.alloc(this.bytes_,&quot;,&quot;      this.start_, this.end_ - this.start_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Clears the decoder.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.clear = function() {&quot;,&quot;  this.bytes_ = null;&quot;,&quot;  this.start_ = 0;&quot;,&quot;  this.end_ = 0;&quot;,&quot;  this.cursor_ = 0;&quot;,&quot;  this.error_ = false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the raw buffer.&quot;,&quot; * @return {?Uint8Array} The raw buffer.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.getBuffer = function() {&quot;,&quot;  return this.bytes_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Changes the block of bytes we&#39;re decoding.&quot;,&quot; * @param {!jspb.ByteSource} data The bytes we&#39;re reading from.&quot;,&quot; * @param {number=} opt_start The optional offset to start reading at.&quot;,&quot; * @param {number=} opt_length The optional length of the block to read -&quot;,&quot; *     we&#39;ll throw an assertion if we go off the end of the block.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.setBlock =&quot;,&quot;    function(data, opt_start, opt_length) {&quot;,&quot;  this.bytes_ = jspb.utils.byteSourceToUint8Array(data);&quot;,&quot;  this.start_ = goog.isDef(opt_start) ? opt_start : 0;&quot;,&quot;  this.end_ =&quot;,&quot;      goog.isDef(opt_length) ? this.start_ + opt_length : this.bytes_.length;&quot;,&quot;  this.cursor_ = this.start_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.getEnd = function() {&quot;,&quot;  return this.end_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {number} end&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.setEnd = function(end) {&quot;,&quot;  this.end_ = end;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Moves the read cursor back to the start of the block.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.reset = function() {&quot;,&quot;  this.cursor_ = this.start_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the internal read cursor.&quot;,&quot; * @return {number} The internal read cursor.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.getCursor = function() {&quot;,&quot;  return this.cursor_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the internal read cursor.&quot;,&quot; * @param {number} cursor The new cursor.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.setCursor = function(cursor) {&quot;,&quot;  this.cursor_ = cursor;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Advances the stream cursor by the given number of bytes.&quot;,&quot; * @param {number} count The number of bytes to advance by.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.advance = function(count) {&quot;,&quot;  this.cursor_ += count;&quot;,&quot;  goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if this decoder is at the end of the block.&quot;,&quot; * @return {boolean}&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.atEnd = function() {&quot;,&quot;  return this.cursor_ == this.end_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if this decoder is at the end of the block.&quot;,&quot; * @return {boolean}&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.pastEnd = function() {&quot;,&quot;  return this.cursor_ &gt; this.end_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if this decoder encountered an error due to corrupt data.&quot;,&quot; * @return {boolean}&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.getError = function() {&quot;,&quot;  return this.error_ ||&quot;,&quot;         (this.cursor_ &lt; 0) ||&quot;,&quot;         (this.cursor_ &gt; this.end_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an unsigned varint from the binary stream and stores it as a split&quot;,&quot; * 64-bit integer. Since this does not convert the value to a number, no&quot;,&quot; * precision is lost.&quot;,&quot; *&quot;,&quot; * It&#39;s possible for an unsigned varint to be incorrectly encoded - more than&quot;,&quot; * 64 bits&#39; worth of data could be present. If this happens, this method will&quot;,&quot; * throw an error.&quot;,&quot; *&quot;,&quot; * Decoding varints requires doing some funny base-128 math - for more&quot;,&quot; * details on the format, see&quot;,&quot; * https://developers.google.com/protocol-buffers/docs/encoding&quot;,&quot; *&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readSplitVarint64_ = function() {&quot;,&quot;  var temp;&quot;,&quot;  var lowBits = 0;&quot;,&quot;  var highBits = 0;&quot;,null,&quot;  // Read the first four bytes of the varint, stopping at the terminator if we&quot;,&quot;  // see it.&quot;,&quot;  for (var i = 0; i &lt; 4; i++) {&quot;,&quot;    temp = this.bytes_[this.cursor_++];&quot;,&quot;    lowBits |= (temp &amp; 0x7F) &lt;&lt; (i * 7);&quot;,&quot;    if (temp &lt; 128) {&quot;,&quot;      this.tempLow_ = lowBits &gt;&gt;&gt; 0;&quot;,&quot;      this.tempHigh_ = 0;&quot;,&quot;      return;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // Read the fifth byte, which straddles the low and high dwords.&quot;,&quot;  temp = this.bytes_[this.cursor_++];&quot;,&quot;  lowBits |= (temp &amp; 0x7F) &lt;&lt; 28;&quot;,&quot;  highBits |= (temp &amp; 0x7F) &gt;&gt; 4;&quot;,&quot;  if (temp &lt; 128) {&quot;,&quot;    this.tempLow_ = lowBits &gt;&gt;&gt; 0;&quot;,&quot;    this.tempHigh_ = highBits &gt;&gt;&gt; 0;&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  // Read the sixth through tenth byte.&quot;,&quot;  for (var i = 0; i &lt; 5; i++) {&quot;,&quot;    temp = this.bytes_[this.cursor_++];&quot;,&quot;    highBits |= (temp &amp; 0x7F) &lt;&lt; (i * 7 + 3);&quot;,&quot;    if (temp &lt; 128) {&quot;,&quot;      this.tempLow_ = lowBits &gt;&gt;&gt; 0;&quot;,&quot;      this.tempHigh_ = highBits &gt;&gt;&gt; 0;&quot;,&quot;      return;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // If we did not see the terminator, the encoding was invalid.&quot;,&quot;  goog.asserts.fail(&#39;Failed to read varint, encoding is invalid.&#39;);&quot;,&quot;  this.error_ = true;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Skips over a varint in the block without decoding it.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.skipVarint = function() {&quot;,&quot;  while (this.bytes_[this.cursor_] &amp; 0x80) {&quot;,&quot;    this.cursor_++;&quot;,&quot;  }&quot;,&quot;  this.cursor_++;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Skips backwards over a varint in the block - to do this correctly, we have&quot;,&quot; * to know the value we&#39;re skipping backwards over or things are ambiguous.&quot;,&quot; * @param {number} value The varint value to unskip.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.unskipVarint = function(value) {&quot;,&quot;  while (value &gt; 128) {&quot;,&quot;    this.cursor_--;&quot;,&quot;    value = value &gt;&gt;&gt; 7;&quot;,&quot;  }&quot;,&quot;  this.cursor_--;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a 32-bit varint from the binary stream. Due to a quirk of the encoding&quot;,&quot; * format and Javascript&#39;s handling of bitwise math, this actually works&quot;,&quot; * correctly for both signed and unsigned 32-bit varints.&quot;,&quot; *&quot;,&quot; * This function is called vastly more frequently than any other in&quot;,&quot; * BinaryDecoder, so it has been unrolled and tweaked for performance.&quot;,&quot; *&quot;,&quot; * If there are more than 32 bits of data in the varint, it _must_ be due to&quot;,&quot; * sign-extension. If we&#39;re in debug mode and the high 32 bits don&#39;t match the&quot;,&quot; * expected sign extension, this method will throw an error.&quot;,&quot; *&quot;,&quot; * Decoding varints requires doing some funny base-128 math - for more&quot;,&quot; * details on the format, see&quot;,&quot; * https://developers.google.com/protocol-buffers/docs/encoding&quot;,&quot; *&quot;,&quot; * @return {number} The decoded unsigned 32-bit varint.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readUnsignedVarint32 = function() {&quot;,&quot;  var temp;&quot;,&quot;  var bytes = this.bytes_;&quot;,null,&quot;  temp = bytes[this.cursor_ + 0];&quot;,&quot;  var x = (temp &amp; 0x7F);&quot;,&quot;  if (temp &lt; 128) {&quot;,&quot;    this.cursor_ += 1;&quot;,&quot;    goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;    return x;&quot;,&quot;  }&quot;,null,&quot;  temp = bytes[this.cursor_ + 1];&quot;,&quot;  x |= (temp &amp; 0x7F) &lt;&lt; 7;&quot;,&quot;  if (temp &lt; 128) {&quot;,&quot;    this.cursor_ += 2;&quot;,&quot;    goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;    return x;&quot;,&quot;  }&quot;,null,&quot;  temp = bytes[this.cursor_ + 2];&quot;,&quot;  x |= (temp &amp; 0x7F) &lt;&lt; 14;&quot;,&quot;  if (temp &lt; 128) {&quot;,&quot;    this.cursor_ += 3;&quot;,&quot;    goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;    return x;&quot;,&quot;  }&quot;,null,&quot;  temp = bytes[this.cursor_ + 3];&quot;,&quot;  x |= (temp &amp; 0x7F) &lt;&lt; 21;&quot;,&quot;  if (temp &lt; 128) {&quot;,&quot;    this.cursor_ += 4;&quot;,&quot;    goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;    return x;&quot;,&quot;  }&quot;,null,&quot;  temp = bytes[this.cursor_ + 4];&quot;,&quot;  x |= (temp &amp; 0x0F) &lt;&lt; 28;&quot;,&quot;  if (temp &lt; 128) {&quot;,&quot;    // We&#39;re reading the high bits of an unsigned varint. The byte we just read&quot;,&quot;    // also contains bits 33 through 35, which we&#39;re going to discard.&quot;,&quot;    this.cursor_ += 5;&quot;,&quot;    goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;    return x &gt;&gt;&gt; 0;&quot;,&quot;  }&quot;,null,&quot;  // If we get here, we need to truncate coming bytes. However we need to make&quot;,&quot;  // sure cursor place is correct.&quot;,&quot;  this.cursor_ += 5;&quot;,&quot;  if (bytes[this.cursor_++] &gt;= 128 &amp;&amp;&quot;,&quot;      bytes[this.cursor_++] &gt;= 128 &amp;&amp;&quot;,&quot;      bytes[this.cursor_++] &gt;= 128 &amp;&amp;&quot;,&quot;      bytes[this.cursor_++] &gt;= 128 &amp;&amp;&quot;,&quot;      bytes[this.cursor_++] &gt;= 128) {&quot;,&quot;    // If we get here, the varint is too long.&quot;,&quot;    goog.asserts.assert(false);&quot;,&quot;  }&quot;,null,&quot;  goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;  return x;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * The readUnsignedVarint32 above deals with signed 32-bit varints correctly,&quot;,&quot; * so this is just an alias.&quot;,&quot; *&quot;,&quot; * @return {number} The decoded signed 32-bit varint.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readSignedVarint32 =&quot;,&quot;    jspb.BinaryDecoder.prototype.readUnsignedVarint32;&quot;,null,null,&quot;/**&quot;,&quot; * Reads a 32-bit unsigned variant and returns its value as a string.&quot;,&quot; *&quot;,&quot; * @return {string} The decoded unsigned 32-bit varint as a string.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readUnsignedVarint32String = function() {&quot;,&quot;  // 32-bit integers fit in JavaScript numbers without loss of precision, so&quot;,&quot;  // string variants of 32-bit varint readers can simply delegate then convert&quot;,&quot;  // to string.&quot;,&quot;  var value = this.readUnsignedVarint32();&quot;,&quot;  return value.toString();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a 32-bit signed variant and returns its value as a string.&quot;,&quot; *&quot;,&quot; * @return {string} The decoded signed 32-bit varint as a string.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readSignedVarint32String = function() {&quot;,&quot;  // 32-bit integers fit in JavaScript numbers without loss of precision, so&quot;,&quot;  // string variants of 32-bit varint readers can simply delegate then convert&quot;,&quot;  // to string.&quot;,&quot;  var value = this.readSignedVarint32();&quot;,&quot;  return value.toString();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed, zigzag-encoded 32-bit varint from the binary stream.&quot;,&quot; *&quot;,&quot; * Zigzag encoding is a modification of varint encoding that reduces the&quot;,&quot; * storage overhead for small negative integers - for more details on the&quot;,&quot; * format, see https://developers.google.com/protocol-buffers/docs/encoding&quot;,&quot; *&quot;,&quot; * @return {number} The decoded signed, zigzag-encoded 32-bit varint.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readZigzagVarint32 = function() {&quot;,&quot;  var result = this.readUnsignedVarint32();&quot;,&quot;  return (result &gt;&gt;&gt; 1) ^ - (result &amp; 1);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an unsigned 64-bit varint from the binary stream. Note that since&quot;,&quot; * Javascript represents all numbers as double-precision floats, there will be&quot;,&quot; * precision lost if the absolute value of the varint is larger than 2^53.&quot;,&quot; *&quot;,&quot; * @return {number} The decoded unsigned varint. Precision will be lost if the&quot;,&quot; *     integer exceeds 2^53.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readUnsignedVarint64 = function() {&quot;,&quot;  this.readSplitVarint64_();&quot;,&quot;  return jspb.utils.joinUint64(this.tempLow_, this.tempHigh_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an unsigned 64-bit varint from the binary stream and returns the value&quot;,&quot; * as a decimal string.&quot;,&quot; *&quot;,&quot; * @return {string} The decoded unsigned varint as a decimal string.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readUnsignedVarint64String = function() {&quot;,&quot;  this.readSplitVarint64_();&quot;,&quot;  return jspb.utils.joinUnsignedDecimalString(this.tempLow_, this.tempHigh_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed 64-bit varint from the binary stream. Note that since&quot;,&quot; * Javascript represents all numbers as double-precision floats, there will be&quot;,&quot; * precision lost if the absolute value of the varint is larger than 2^53.&quot;,&quot; *&quot;,&quot; * @return {number} The decoded signed varint. Precision will be lost if the&quot;,&quot; *     integer exceeds 2^53.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readSignedVarint64 = function() {&quot;,&quot;  this.readSplitVarint64_();&quot;,&quot;  return jspb.utils.joinInt64(this.tempLow_, this.tempHigh_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an signed 64-bit varint from the binary stream and returns the value&quot;,&quot; * as a decimal string.&quot;,&quot; *&quot;,&quot; * @return {string} The decoded signed varint as a decimal string.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readSignedVarint64String = function() {&quot;,&quot;  this.readSplitVarint64_();&quot;,&quot;  return jspb.utils.joinSignedDecimalString(this.tempLow_, this.tempHigh_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed, zigzag-encoded 64-bit varint from the binary stream. Note&quot;,&quot; * that since Javascript represents all numbers as double-precision floats,&quot;,&quot; * there will be precision lost if the absolute value of the varint is larger&quot;,&quot; * than 2^53.&quot;,&quot; *&quot;,&quot; * Zigzag encoding is a modification of varint encoding that reduces the&quot;,&quot; * storage overhead for small negative integers - for more details on the&quot;,&quot; * format, see https://developers.google.com/protocol-buffers/docs/encoding&quot;,&quot; *&quot;,&quot; * @return {number} The decoded zigzag varint. Precision will be lost if the&quot;,&quot; *     integer exceeds 2^53.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readZigzagVarint64 = function() {&quot;,&quot;  this.readSplitVarint64_();&quot;,&quot;  return jspb.utils.joinZigzag64(this.tempLow_, this.tempHigh_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed, zigzag-encoded 64-bit varint from the binary stream and&quot;,&quot; * returns its valud as a string.&quot;,&quot; *&quot;,&quot; * Zigzag encoding is a modification of varint encoding that reduces the&quot;,&quot; * storage overhead for small negative integers - for more details on the&quot;,&quot; * format, see https://developers.google.com/protocol-buffers/docs/encoding&quot;,&quot; *&quot;,&quot; * @return {string} The decoded signed, zigzag-encoded 64-bit varint as a&quot;,&quot; * string.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readZigzagVarint64String = function() {&quot;,&quot;  // TODO(haberman): write lossless 64-bit zig-zag math.&quot;,&quot;  var value = this.readZigzagVarint64();&quot;,&quot;  return value.toString();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a raw unsigned 8-bit integer from the binary stream.&quot;,&quot; *&quot;,&quot; * @return {number} The unsigned 8-bit integer read from the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readUint8 = function() {&quot;,&quot;  var a = this.bytes_[this.cursor_ + 0];&quot;,&quot;  this.cursor_ += 1;&quot;,&quot;  goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;  return a;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a raw unsigned 16-bit integer from the binary stream.&quot;,&quot; *&quot;,&quot; * @return {number} The unsigned 16-bit integer read from the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readUint16 = function() {&quot;,&quot;  var a = this.bytes_[this.cursor_ + 0];&quot;,&quot;  var b = this.bytes_[this.cursor_ + 1];&quot;,&quot;  this.cursor_ += 2;&quot;,&quot;  goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;  return (a &lt;&lt; 0) | (b &lt;&lt; 8);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a raw unsigned 32-bit integer from the binary stream.&quot;,&quot; *&quot;,&quot; * @return {number} The unsigned 32-bit integer read from the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readUint32 = function() {&quot;,&quot;  var a = this.bytes_[this.cursor_ + 0];&quot;,&quot;  var b = this.bytes_[this.cursor_ + 1];&quot;,&quot;  var c = this.bytes_[this.cursor_ + 2];&quot;,&quot;  var d = this.bytes_[this.cursor_ + 3];&quot;,&quot;  this.cursor_ += 4;&quot;,&quot;  goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;  return ((a &lt;&lt; 0) | (b &lt;&lt; 8) | (c &lt;&lt; 16) | (d &lt;&lt; 24)) &gt;&gt;&gt; 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a raw unsigned 64-bit integer from the binary stream. Note that since&quot;,&quot; * Javascript represents all numbers as double-precision floats, there will be&quot;,&quot; * precision lost if the absolute value of the integer is larger than 2^53.&quot;,&quot; *&quot;,&quot; * @return {number} The unsigned 64-bit integer read from the binary stream.&quot;,&quot; *     Precision will be lost if the integer exceeds 2^53.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readUint64 = function() {&quot;,&quot;  var bitsLow = this.readUint32();&quot;,&quot;  var bitsHigh = this.readUint32();&quot;,&quot;  return jspb.utils.joinUint64(bitsLow, bitsHigh);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a raw unsigned 64-bit integer from the binary stream. Note that since&quot;,&quot; * Javascript represents all numbers as double-precision floats, there will be&quot;,&quot; * precision lost if the absolute value of the integer is larger than 2^53.&quot;,&quot; *&quot;,&quot; * @return {string} The unsigned 64-bit integer read from the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readUint64String = function() {&quot;,&quot;  var bitsLow = this.readUint32();&quot;,&quot;  var bitsHigh = this.readUint32();&quot;,&quot;  return jspb.utils.joinUnsignedDecimalString(bitsLow, bitsHigh);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a raw signed 8-bit integer from the binary stream.&quot;,&quot; *&quot;,&quot; * @return {number} The signed 8-bit integer read from the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readInt8 = function() {&quot;,&quot;  var a = this.bytes_[this.cursor_ + 0];&quot;,&quot;  this.cursor_ += 1;&quot;,&quot;  goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;  return (a &lt;&lt; 24) &gt;&gt; 24;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a raw signed 16-bit integer from the binary stream.&quot;,&quot; *&quot;,&quot; * @return {number} The signed 16-bit integer read from the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readInt16 = function() {&quot;,&quot;  var a = this.bytes_[this.cursor_ + 0];&quot;,&quot;  var b = this.bytes_[this.cursor_ + 1];&quot;,&quot;  this.cursor_ += 2;&quot;,&quot;  goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;  return (((a &lt;&lt; 0) | (b &lt;&lt; 8)) &lt;&lt; 16) &gt;&gt; 16;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a raw signed 32-bit integer from the binary stream.&quot;,&quot; *&quot;,&quot; * @return {number} The signed 32-bit integer read from the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readInt32 = function() {&quot;,&quot;  var a = this.bytes_[this.cursor_ + 0];&quot;,&quot;  var b = this.bytes_[this.cursor_ + 1];&quot;,&quot;  var c = this.bytes_[this.cursor_ + 2];&quot;,&quot;  var d = this.bytes_[this.cursor_ + 3];&quot;,&quot;  this.cursor_ += 4;&quot;,&quot;  goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;  return (a &lt;&lt; 0) | (b &lt;&lt; 8) | (c &lt;&lt; 16) | (d &lt;&lt; 24);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a raw signed 64-bit integer from the binary stream. Note that since&quot;,&quot; * Javascript represents all numbers as double-precision floats, there will be&quot;,&quot; * precision lost if the absolute vlaue of the integer is larger than 2^53.&quot;,&quot; *&quot;,&quot; * @return {number} The signed 64-bit integer read from the binary stream.&quot;,&quot; *     Precision will be lost if the integer exceeds 2^53.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readInt64 = function() {&quot;,&quot;  var bitsLow = this.readUint32();&quot;,&quot;  var bitsHigh = this.readUint32();&quot;,&quot;  return jspb.utils.joinInt64(bitsLow, bitsHigh);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a raw signed 64-bit integer from the binary stream and returns it as a&quot;,&quot; * string.&quot;,&quot; *&quot;,&quot; * @return {string} The signed 64-bit integer read from the binary stream.&quot;,&quot; *     Precision will be lost if the integer exceeds 2^53.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readInt64String = function() {&quot;,&quot;  var bitsLow = this.readUint32();&quot;,&quot;  var bitsHigh = this.readUint32();&quot;,&quot;  return jspb.utils.joinSignedDecimalString(bitsLow, bitsHigh);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a 32-bit floating-point number from the binary stream, using the&quot;,&quot; * temporary buffer to realign the data.&quot;,&quot; *&quot;,&quot; * @return {number} The float read from the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readFloat = function() {&quot;,&quot;  var bitsLow = this.readUint32();&quot;,&quot;  var bitsHigh = 0;&quot;,&quot;  return jspb.utils.joinFloat32(bitsLow, bitsHigh);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a 64-bit floating-point number from the binary stream, using the&quot;,&quot; * temporary buffer to realign the data.&quot;,&quot; *&quot;,&quot; * @return {number} The double read from the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readDouble = function() {&quot;,&quot;  var bitsLow = this.readUint32();&quot;,&quot;  var bitsHigh = this.readUint32();&quot;,&quot;  return jspb.utils.joinFloat64(bitsLow, bitsHigh);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a boolean value from the binary stream.&quot;,&quot; * @return {boolean} The boolean read from the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readBool = function() {&quot;,&quot;  return !!this.bytes_[this.cursor_++];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an enum value from the binary stream, which are always encoded as&quot;,&quot; * signed varints.&quot;,&quot; * @return {number} The enum value read from the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readEnum = function() {&quot;,&quot;  return this.readSignedVarint32();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads and parses a UTF-8 encoded unicode string from the stream.&quot;,&quot; * The code is inspired by maps.vectortown.parse.StreamedDataViewReader.&quot;,&quot; * Supports codepoints from U+0000 up to U+10FFFF.&quot;,&quot; * (http://en.wikipedia.org/wiki/UTF-8).&quot;,&quot; * @param {number} length The length of the string to read.&quot;,&quot; * @return {string} The decoded string.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readString = function(length) {&quot;,&quot;  var bytes = this.bytes_;&quot;,&quot;  var cursor = this.cursor_;&quot;,&quot;  var end = cursor + length;&quot;,&quot;  var codeUnits = [];&quot;,null,&quot;  var result = &#39;&#39;;&quot;,&quot;  while (cursor &lt; end) {&quot;,&quot;    var c = bytes[cursor++];&quot;,&quot;    if (c &lt; 128) { // Regular 7-bit ASCII.&quot;,&quot;      codeUnits.push(c);&quot;,&quot;    } else if (c &lt; 192) {&quot;,&quot;      // UTF-8 continuation mark. We are out of sync. This&quot;,&quot;      // might happen if we attempted to read a character&quot;,&quot;      // with more than four bytes.&quot;,&quot;      continue;&quot;,&quot;    } else if (c &lt; 224) { // UTF-8 with two bytes.&quot;,&quot;      var c2 = bytes[cursor++];&quot;,&quot;      codeUnits.push(((c &amp; 31) &lt;&lt; 6) | (c2 &amp; 63));&quot;,&quot;    } else if (c &lt; 240) { // UTF-8 with three bytes.&quot;,&quot;      var c2 = bytes[cursor++];&quot;,&quot;      var c3 = bytes[cursor++];&quot;,&quot;      codeUnits.push(((c &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63));&quot;,&quot;    } else if (c &lt; 248) { // UTF-8 with 4 bytes.&quot;,&quot;      var c2 = bytes[cursor++];&quot;,&quot;      var c3 = bytes[cursor++];&quot;,&quot;      var c4 = bytes[cursor++];&quot;,&quot;      // Characters written on 4 bytes have 21 bits for a codepoint.&quot;,&quot;      // We can&#39;t fit that on 16bit characters, so we use surrogates.&quot;,&quot;      var codepoint = ((c &amp; 7) &lt;&lt; 18) | ((c2 &amp; 63) &lt;&lt; 12) | ((c3 &amp; 63) &lt;&lt; 6) | (c4 &amp; 63);&quot;,&quot;      // Surrogates formula from wikipedia.&quot;,&quot;      // 1. Subtract 0x10000 from codepoint&quot;,&quot;      codepoint -= 0x10000;&quot;,&quot;      // 2. Split this into the high 10-bit value and the low 10-bit value&quot;,&quot;      // 3. Add 0xD800 to the high value to form the high surrogate&quot;,&quot;      // 4. Add 0xDC00 to the low value to form the low surrogate:&quot;,&quot;      var low = (codepoint &amp; 1023) + 0xDC00;&quot;,&quot;      var high = ((codepoint &gt;&gt; 10) &amp; 1023) + 0xD800;&quot;,&quot;      codeUnits.push(high, low);&quot;,&quot;    }&quot;,null,&quot;    // Avoid exceeding the maximum stack size when calling {@code apply}.&quot;,&quot;    if (codeUnits.length &gt;= 8192) {&quot;,&quot;      result += String.fromCharCode.apply(null, codeUnits);&quot;,&quot;      codeUnits.length = 0;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  result += goog.crypt.byteArrayToString(codeUnits);&quot;,&quot;  this.cursor_ = cursor;&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads and parses a UTF-8 encoded unicode string (with length prefix) from&quot;,&quot; * the stream.&quot;,&quot; * @return {string} The decoded string.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readStringWithLength = function() {&quot;,&quot;  var length = this.readUnsignedVarint32();&quot;,&quot;  return this.readString(length);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a block of raw bytes from the binary stream.&quot;,&quot; *&quot;,&quot; * @param {number} length The number of bytes to read.&quot;,&quot; * @return {!Uint8Array} The decoded block of bytes, or an empty block if the&quot;,&quot; *     length was invalid.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readBytes = function(length) {&quot;,&quot;  if (length &lt; 0 ||&quot;,&quot;      this.cursor_ + length &gt; this.bytes_.length) {&quot;,&quot;    this.error_ = true;&quot;,&quot;    goog.asserts.fail(&#39;Invalid byte length!&#39;);&quot;,&quot;    return new Uint8Array(0);&quot;,&quot;  }&quot;,null,&quot;  var result = this.bytes_.subarray(this.cursor_, this.cursor_ + length);&quot;,null,&quot;  this.cursor_ += length;&quot;,&quot;  goog.asserts.assert(this.cursor_ &lt;= this.end_);&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a 64-bit varint from the stream and returns it as an 8-character&quot;,&quot; * Unicode string for use as a hash table key.&quot;,&quot; *&quot;,&quot; * @return {string} The hash value.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readVarintHash64 = function() {&quot;,&quot;  this.readSplitVarint64_();&quot;,&quot;  return jspb.utils.joinHash64(this.tempLow_, this.tempHigh_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a 64-bit fixed-width value from the stream and returns it as an&quot;,&quot; * 8-character Unicode string for use as a hash table key.&quot;,&quot; *&quot;,&quot; * @return {string} The hash value.&quot;,&quot; */&quot;,&quot;jspb.BinaryDecoder.prototype.readFixedHash64 = function() {&quot;,&quot;  var bytes = this.bytes_;&quot;,&quot;  var cursor = this.cursor_;&quot;,null,&quot;  var a = bytes[cursor + 0];&quot;,&quot;  var b = bytes[cursor + 1];&quot;,&quot;  var c = bytes[cursor + 2];&quot;,&quot;  var d = bytes[cursor + 3];&quot;,&quot;  var e = bytes[cursor + 4];&quot;,&quot;  var f = bytes[cursor + 5];&quot;,&quot;  var g = bytes[cursor + 6];&quot;,&quot;  var h = bytes[cursor + 7];&quot;,null,&quot;  this.cursor_ += 8;&quot;,null,&quot;  return String.fromCharCode(a, b, c, d, e, f, g, h);&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../dossier.js" defer></script>