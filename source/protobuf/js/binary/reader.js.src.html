<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>reader.js</title><link href="../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;reader.js&quot;,&quot;protobuf/js/binary/reader.js&quot;,[&quot;// Protocol Buffers - Google&#39;s data interchange format&quot;,&quot;// Copyright 2008 Google Inc.  All rights reserved.&quot;,&quot;// https://developers.google.com/protocol-buffers/&quot;,&quot;//&quot;,&quot;// Redistribution and use in source and binary forms, with or without&quot;,&quot;// modification, are permitted provided that the following conditions are&quot;,&quot;// met:&quot;,&quot;//&quot;,&quot;//     * Redistributions of source code must retain the above copyright&quot;,&quot;// notice, this list of conditions and the following disclaimer.&quot;,&quot;//     * Redistributions in binary form must reproduce the above&quot;,&quot;// copyright notice, this list of conditions and the following disclaimer&quot;,&quot;// in the documentation and/or other materials provided with the&quot;,&quot;// distribution.&quot;,&quot;//     * Neither the name of Google Inc. nor the names of its&quot;,&quot;// contributors may be used to endorse or promote products derived from&quot;,&quot;// this software without specific prior written permission.&quot;,&quot;//&quot;,&quot;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;,&quot;// \&quot;AS IS\&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR&quot;,&quot;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&quot;,&quot;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&quot;,&quot;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,&quot;,&quot;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY&quot;,&quot;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&quot;,&quot;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&quot;,&quot;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview This file contains utilities for converting binary,&quot;,&quot; * wire-format protocol buffers into Javascript data structures.&quot;,&quot; *&quot;,&quot; * jspb&#39;s BinaryReader class wraps the BinaryDecoder class to add methods&quot;,&quot; * that understand the protocol buffer syntax and can do the type checking and&quot;,&quot; * bookkeeping necessary to parse trees of nested messages.&quot;,&quot; *&quot;,&quot; * Major caveat - Users of this library _must_ keep their Javascript proto&quot;,&quot; * parsing code in sync with the original .proto file - presumably you&#39;ll be&quot;,&quot; * using the typed jspb code generator, but if you bypass that you&#39;ll need&quot;,&quot; * to keep things in sync by hand.&quot;,&quot; *&quot;,&quot; * @author aappleby@google.com (Austin Appleby)&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;jspb.BinaryReader&#39;);&quot;,null,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;jspb.BinaryConstants&#39;);&quot;,&quot;goog.require(&#39;jspb.BinaryDecoder&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * BinaryReader implements the decoders for all the wire types specified in&quot;,&quot; * https://developers.google.com/protocol-buffers/docs/encoding.&quot;,&quot; *&quot;,&quot; * @param {jspb.ByteSource=} opt_bytes The bytes we&#39;re reading from.&quot;,&quot; * @param {number=} opt_start The optional offset to start reading at.&quot;,&quot; * @param {number=} opt_length The optional length of the block to read -&quot;,&quot; *     we&#39;ll throw an assertion if we go off the end of the block.&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; */&quot;,&quot;jspb.BinaryReader = function(opt_bytes, opt_start, opt_length) {&quot;,&quot;  /**&quot;,&quot;   * Wire-format decoder.&quot;,&quot;   * @private {!jspb.BinaryDecoder}&quot;,&quot;   */&quot;,&quot;  this.decoder_ = jspb.BinaryDecoder.alloc(opt_bytes, opt_start, opt_length);&quot;,null,&quot;  /**&quot;,&quot;   * Cursor immediately before the field tag.&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.fieldCursor_ = this.decoder_.getCursor();&quot;,null,&quot;  /**&quot;,&quot;   * Field number of the next field in the buffer, filled in by nextField().&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER;&quot;,null,&quot;  /**&quot;,&quot;   * Wire type of the next proto field in the buffer, filled in by&quot;,&quot;   * nextField().&quot;,&quot;   * @private {jspb.BinaryConstants.WireType}&quot;,&quot;   */&quot;,&quot;  this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;&quot;,null,&quot;  /**&quot;,&quot;   * Set to true if this reader encountered an error due to corrupt data.&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.error_ = false;&quot;,null,&quot;  /**&quot;,&quot;   * User-defined reader callbacks.&quot;,&quot;   * @private {Object&lt;string, function(!jspb.BinaryReader):*&gt;}&quot;,&quot;   */&quot;,&quot;  this.readCallbacks_ = null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Global pool of BinaryReader instances.&quot;,&quot; * @private {!Array&lt;!jspb.BinaryReader&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.instanceCache_ = [];&quot;,null,null,&quot;/**&quot;,&quot; * Pops an instance off the instance cache, or creates one if the cache is&quot;,&quot; * empty.&quot;,&quot; * @param {jspb.ByteSource=} opt_bytes The bytes we&#39;re reading from.&quot;,&quot; * @param {number=} opt_start The optional offset to start reading at.&quot;,&quot; * @param {number=} opt_length The optional length of the block to read -&quot;,&quot; *     we&#39;ll throw an assertion if we go off the end of the block.&quot;,&quot; * @return {!jspb.BinaryReader}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.alloc =&quot;,&quot;    function(opt_bytes, opt_start, opt_length) {&quot;,&quot;  if (jspb.BinaryReader.instanceCache_.length) {&quot;,&quot;    var newReader = jspb.BinaryReader.instanceCache_.pop();&quot;,&quot;    if (opt_bytes) {&quot;,&quot;      newReader.decoder_.setBlock(opt_bytes, opt_start, opt_length);&quot;,&quot;    }&quot;,&quot;    return newReader;&quot;,&quot;  } else {&quot;,&quot;    return new jspb.BinaryReader(opt_bytes, opt_start, opt_length);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Alias for the above method.&quot;,&quot; * @param {jspb.ByteSource=} opt_bytes The bytes we&#39;re reading from.&quot;,&quot; * @param {number=} opt_start The optional offset to start reading at.&quot;,&quot; * @param {number=} opt_length The optional length of the block to read -&quot;,&quot; *     we&#39;ll throw an assertion if we go off the end of the block.&quot;,&quot; * @return {!jspb.BinaryReader}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.alloc = jspb.BinaryReader.alloc;&quot;,null,null,&quot;/**&quot;,&quot; * Puts this instance back in the instance cache.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.free = function() {&quot;,&quot;  this.decoder_.clear();&quot;,&quot;  this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER;&quot;,&quot;  this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;&quot;,&quot;  this.error_ = false;&quot;,&quot;  this.readCallbacks_ = null;&quot;,null,&quot;  if (jspb.BinaryReader.instanceCache_.length &lt; 100) {&quot;,&quot;    jspb.BinaryReader.instanceCache_.push(this);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the cursor immediately before the current field&#39;s tag.&quot;,&quot; * @return {number} The internal read cursor.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.getFieldCursor = function() {&quot;,&quot;  return this.fieldCursor_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the internal read cursor.&quot;,&quot; * @return {number} The internal read cursor.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.getCursor = function() {&quot;,&quot;  return this.decoder_.getCursor();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the raw buffer.&quot;,&quot; * @return {?Uint8Array} The raw buffer.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.getBuffer = function() {&quot;,&quot;  return this.decoder_.getBuffer();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {number} The field number of the next field in the buffer, or&quot;,&quot; *     INVALID_FIELD_NUMBER if there is no next field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.getFieldNumber = function() {&quot;,&quot;  return this.nextField_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {jspb.BinaryConstants.WireType} The wire type of the next field&quot;,&quot; *     in the stream, or WireType.INVALID if there is no next field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.getWireType = function() {&quot;,&quot;  return this.nextWireType_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {boolean} Whether the current wire type is an end-group tag. Used as&quot;,&quot; * an exit condition in decoder loops in generated code.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.isEndGroup = function() {&quot;,&quot;  return this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if this reader hit an error due to corrupt data.&quot;,&quot; * @return {boolean}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.getError = function() {&quot;,&quot;  return this.error_ || this.decoder_.getError();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Points this reader at a new block of bytes.&quot;,&quot; * @param {!Uint8Array} bytes The block of bytes we&#39;re reading from.&quot;,&quot; * @param {number} start The offset to start reading at.&quot;,&quot; * @param {number} length The length of the block to read.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.setBlock = function(bytes, start, length) {&quot;,&quot;  this.decoder_.setBlock(bytes, start, length);&quot;,&quot;  this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER;&quot;,&quot;  this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Rewinds the stream cursor to the beginning of the buffer and resets all&quot;,&quot; * internal state.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.reset = function() {&quot;,&quot;  this.decoder_.reset();&quot;,&quot;  this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER;&quot;,&quot;  this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Advances the stream cursor by the given number of bytes.&quot;,&quot; * @param {number} count The number of bytes to advance by.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.advance = function(count) {&quot;,&quot;  this.decoder_.advance(count);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads the next field header in the stream if there is one, returns true if&quot;,&quot; * we saw a valid field header or false if we&#39;ve read the whole stream.&quot;,&quot; * Throws an error if we encountered a deprecated START_GROUP/END_GROUP field.&quot;,&quot; * @return {boolean} True if the stream contains more fields.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.nextField = function() {&quot;,&quot;  // If we&#39;re at the end of the block, there are no more fields.&quot;,&quot;  if (this.decoder_.atEnd()) {&quot;,&quot;    return false;&quot;,&quot;  }&quot;,null,&quot;  // If we hit an error decoding the previous field, stop now before we&quot;,&quot;  // try to decode anything else&quot;,&quot;  if (this.getError()) {&quot;,&quot;    goog.asserts.fail(&#39;Decoder hit an error&#39;);&quot;,&quot;    return false;&quot;,&quot;  }&quot;,null,&quot;  // Otherwise just read the header of the next field.&quot;,&quot;  this.fieldCursor_ = this.decoder_.getCursor();&quot;,&quot;  var header = this.decoder_.readUnsignedVarint32();&quot;,null,&quot;  var nextField = header &gt;&gt;&gt; 3;&quot;,&quot;  var nextWireType = /** @type {jspb.BinaryConstants.WireType} */&quot;,&quot;      (header &amp; 0x7);&quot;,null,&quot;  // If the wire type isn&#39;t one of the valid ones, something&#39;s broken.&quot;,&quot;  if (nextWireType != jspb.BinaryConstants.WireType.VARINT &amp;&amp;&quot;,&quot;      nextWireType != jspb.BinaryConstants.WireType.FIXED32 &amp;&amp;&quot;,&quot;      nextWireType != jspb.BinaryConstants.WireType.FIXED64 &amp;&amp;&quot;,&quot;      nextWireType != jspb.BinaryConstants.WireType.DELIMITED &amp;&amp;&quot;,&quot;      nextWireType != jspb.BinaryConstants.WireType.START_GROUP &amp;&amp;&quot;,&quot;      nextWireType != jspb.BinaryConstants.WireType.END_GROUP) {&quot;,&quot;    goog.asserts.fail(&#39;Invalid wire type&#39;);&quot;,&quot;    this.error_ = true;&quot;,&quot;    return false;&quot;,&quot;  }&quot;,null,&quot;  this.nextField_ = nextField;&quot;,&quot;  this.nextWireType_ = nextWireType;&quot;,null,&quot;  return true;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Winds the reader back to just before this field&#39;s header.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.unskipHeader = function() {&quot;,&quot;  this.decoder_.unskipVarint((this.nextField_ &lt;&lt; 3) | this.nextWireType_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Skips all contiguous fields whose header matches the one we just read.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.skipMatchingFields = function() {&quot;,&quot;  var field = this.nextField_;&quot;,&quot;  this.unskipHeader();&quot;,null,&quot;  while (this.nextField() &amp;&amp; (this.getFieldNumber() == field)) {&quot;,&quot;    this.skipField();&quot;,&quot;  }&quot;,null,&quot;  if (!this.decoder_.atEnd()) {&quot;,&quot;    this.unskipHeader();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Skips over the next varint field in the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.skipVarintField = function() {&quot;,&quot;  if (this.nextWireType_ != jspb.BinaryConstants.WireType.VARINT) {&quot;,&quot;    goog.asserts.fail(&#39;Invalid wire type for skipVarintField&#39;);&quot;,&quot;    this.skipField();&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  this.decoder_.skipVarint();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Skips over the next delimited field in the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.skipDelimitedField = function() {&quot;,&quot;  if (this.nextWireType_ != jspb.BinaryConstants.WireType.DELIMITED) {&quot;,&quot;    goog.asserts.fail(&#39;Invalid wire type for skipDelimitedField&#39;);&quot;,&quot;    this.skipField();&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  var length = this.decoder_.readUnsignedVarint32();&quot;,&quot;  this.decoder_.advance(length);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Skips over the next fixed32 field in the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.skipFixed32Field = function() {&quot;,&quot;  if (this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED32) {&quot;,&quot;    goog.asserts.fail(&#39;Invalid wire type for skipFixed32Field&#39;);&quot;,&quot;    this.skipField();&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  this.decoder_.advance(4);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Skips over the next fixed64 field in the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.skipFixed64Field = function() {&quot;,&quot;  if (this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED64) {&quot;,&quot;    goog.asserts.fail(&#39;Invalid wire type for skipFixed64Field&#39;);&quot;,&quot;    this.skipField();&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  this.decoder_.advance(8);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Skips over the next group field in the binary stream.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.skipGroup = function() {&quot;,&quot;  // Keep a stack of start-group tags that must be matched by end-group tags.&quot;,&quot;  var nestedGroups = [this.nextField_];&quot;,&quot;  do {&quot;,&quot;    if (!this.nextField()) {&quot;,&quot;      goog.asserts.fail(&#39;Unmatched start-group tag: stream EOF&#39;);&quot;,&quot;      this.error_ = true;&quot;,&quot;      return;&quot;,&quot;    }&quot;,&quot;    if (this.nextWireType_ ==&quot;,&quot;        jspb.BinaryConstants.WireType.START_GROUP) {&quot;,&quot;      // Nested group start.&quot;,&quot;      nestedGroups.push(this.nextField_);&quot;,&quot;    } else if (this.nextWireType_ ==&quot;,&quot;               jspb.BinaryConstants.WireType.END_GROUP) {&quot;,&quot;      // Group end: check that it matches top-of-stack.&quot;,&quot;      if (this.nextField_ != nestedGroups.pop()) {&quot;,&quot;        goog.asserts.fail(&#39;Unmatched end-group tag&#39;);&quot;,&quot;        this.error_ = true;&quot;,&quot;        return;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  } while (nestedGroups.length &gt; 0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Skips over the next field in the binary stream - this is useful if we&#39;re&quot;,&quot; * decoding a message that contain unknown fields.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.skipField = function() {&quot;,&quot;  switch (this.nextWireType_) {&quot;,&quot;    case jspb.BinaryConstants.WireType.VARINT:&quot;,&quot;      this.skipVarintField();&quot;,&quot;      break;&quot;,&quot;    case jspb.BinaryConstants.WireType.FIXED64:&quot;,&quot;      this.skipFixed64Field();&quot;,&quot;      break;&quot;,&quot;    case jspb.BinaryConstants.WireType.DELIMITED:&quot;,&quot;      this.skipDelimitedField();&quot;,&quot;      break;&quot;,&quot;    case jspb.BinaryConstants.WireType.FIXED32:&quot;,&quot;      this.skipFixed32Field();&quot;,&quot;      break;&quot;,&quot;    case jspb.BinaryConstants.WireType.START_GROUP:&quot;,&quot;      this.skipGroup();&quot;,&quot;      break;&quot;,&quot;    default:&quot;,&quot;      goog.asserts.fail(&#39;Invalid wire encoding for field.&#39;);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Registers a user-defined read callback.&quot;,&quot; * @param {string} callbackName&quot;,&quot; * @param {function(!jspb.BinaryReader):*} callback&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.registerReadCallback =&quot;,&quot;    function(callbackName, callback) {&quot;,&quot;  if (goog.isNull(this.readCallbacks_)) {&quot;,&quot;    this.readCallbacks_ = {};&quot;,&quot;  }&quot;,&quot;  goog.asserts.assert(!this.readCallbacks_[callbackName]);&quot;,&quot;  this.readCallbacks_[callbackName] = callback;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Runs a registered read callback.&quot;,&quot; * @param {string} callbackName The name the callback is registered under.&quot;,&quot; * @return {*} The value returned by the callback.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.runReadCallback = function(callbackName) {&quot;,&quot;  goog.asserts.assert(!goog.isNull(this.readCallbacks_));&quot;,&quot;  var callback = this.readCallbacks_[callbackName];&quot;,&quot;  goog.asserts.assert(callback);&quot;,&quot;  return callback(this);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a field of any valid non-message type from the binary stream.&quot;,&quot; * @param {jspb.BinaryConstants.FieldType} fieldType&quot;,&quot; * @return {jspb.AnyFieldType}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readAny = function(fieldType) {&quot;,&quot;  this.nextWireType_ = jspb.BinaryConstants.FieldTypeToWireType(fieldType);&quot;,&quot;  var fieldTypes = jspb.BinaryConstants.FieldType;&quot;,&quot;  switch (fieldType) {&quot;,&quot;    case fieldTypes.DOUBLE:&quot;,&quot;      return this.readDouble();&quot;,&quot;    case fieldTypes.FLOAT:&quot;,&quot;      return this.readFloat();&quot;,&quot;    case fieldTypes.INT64:&quot;,&quot;      return this.readInt64();&quot;,&quot;    case fieldTypes.UINT64:&quot;,&quot;      return this.readUint64();&quot;,&quot;    case fieldTypes.INT32:&quot;,&quot;      return this.readInt32();&quot;,&quot;    case fieldTypes.FIXED64:&quot;,&quot;      return this.readFixed64();&quot;,&quot;    case fieldTypes.FIXED32:&quot;,&quot;      return this.readFixed32();&quot;,&quot;    case fieldTypes.BOOL:&quot;,&quot;      return this.readBool();&quot;,&quot;    case fieldTypes.STRING:&quot;,&quot;      return this.readString();&quot;,&quot;    case fieldTypes.GROUP:&quot;,&quot;      goog.asserts.fail(&#39;Group field type not supported in readAny()&#39;);&quot;,&quot;    case fieldTypes.MESSAGE:&quot;,&quot;      goog.asserts.fail(&#39;Message field type not supported in readAny()&#39;);&quot;,&quot;    case fieldTypes.BYTES:&quot;,&quot;      return this.readBytes();&quot;,&quot;    case fieldTypes.UINT32:&quot;,&quot;      return this.readUint32();&quot;,&quot;    case fieldTypes.ENUM:&quot;,&quot;      return this.readEnum();&quot;,&quot;    case fieldTypes.SFIXED32:&quot;,&quot;      return this.readSfixed32();&quot;,&quot;    case fieldTypes.SFIXED64:&quot;,&quot;      return this.readSfixed64();&quot;,&quot;    case fieldTypes.SINT32:&quot;,&quot;      return this.readSint32();&quot;,&quot;    case fieldTypes.SINT64:&quot;,&quot;      return this.readSint64();&quot;,&quot;    case fieldTypes.FHASH64:&quot;,&quot;      return this.readFixedHash64();&quot;,&quot;    case fieldTypes.VHASH64:&quot;,&quot;      return this.readVarintHash64();&quot;,&quot;    default:&quot;,&quot;      goog.asserts.fail(&#39;Invalid field type in readAny()&#39;);&quot;,&quot;  }&quot;,&quot;  return 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Deserialize a proto into the provided message object using the provided&quot;,&quot; * reader function. This function is templated as we currently have one client&quot;,&quot; * who is using manual deserialization instead of the code-generated versions.&quot;,&quot; * @template T&quot;,&quot; * @param {T} message&quot;,&quot; * @param {function(T, !jspb.BinaryReader)} reader&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readMessage = function(message, reader) {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);&quot;,null,&quot;  // Save the current endpoint of the decoder and move it to the end of the&quot;,&quot;  // embedded message.&quot;,&quot;  var oldEnd = this.decoder_.getEnd();&quot;,&quot;  var length = this.decoder_.readUnsignedVarint32();&quot;,&quot;  var newEnd = this.decoder_.getCursor() + length;&quot;,&quot;  this.decoder_.setEnd(newEnd);&quot;,null,&quot;  // Deserialize the embedded message.&quot;,&quot;  reader(message, this);&quot;,null,&quot;  // Advance the decoder past the embedded message and restore the endpoint.&quot;,&quot;  this.decoder_.setCursor(newEnd);&quot;,&quot;  this.decoder_.setEnd(oldEnd);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Deserialize a proto into the provided message object using the provided&quot;,&quot; * reader function, assuming that the message is serialized as a group&quot;,&quot; * with the given tag.&quot;,&quot; * @template T&quot;,&quot; * @param {number} field&quot;,&quot; * @param {T} message&quot;,&quot; * @param {function(T, !jspb.BinaryReader)} reader&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readGroup =&quot;,&quot;    function(field, message, reader) {&quot;,&quot;  // Ensure that the wire type is correct.&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.START_GROUP);&quot;,&quot;  // Ensure that the field number is correct.&quot;,&quot;  goog.asserts.assert(this.nextField_ == field);&quot;,null,&quot;  // Deserialize the message. The deserialization will stop at an END_GROUP tag.&quot;,&quot;  reader(message, this);&quot;,null,&quot;  if (!this.error_ &amp;&amp;&quot;,&quot;      this.nextWireType_ != jspb.BinaryConstants.WireType.END_GROUP) {&quot;,&quot;    goog.asserts.fail(&#39;Group submessage did not end with an END_GROUP tag&#39;);&quot;,&quot;    this.error_ = true;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Return a decoder that wraps the current delimited field.&quot;,&quot; * @return {!jspb.BinaryDecoder}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.getFieldDecoder = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);&quot;,null,&quot;  var length = this.decoder_.readUnsignedVarint32();&quot;,&quot;  var start = this.decoder_.getCursor();&quot;,&quot;  var end = start + length;&quot;,null,&quot;  var innerDecoder =&quot;,&quot;      jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(), start, length);&quot;,&quot;  this.decoder_.setCursor(end);&quot;,&quot;  return innerDecoder;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed 32-bit integer field from the binary stream, or throws an&quot;,&quot; * error if the next field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the signed 32-bit integer field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readInt32 = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readSignedVarint32();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed 32-bit integer field from the binary stream, or throws an&quot;,&quot; * error if the next field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * Returns the value as a string.&quot;,&quot; *&quot;,&quot; * @return {string} The value of the signed 32-bit integer field as a decimal&quot;,&quot; * string.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readInt32String = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readSignedVarint32String();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed 64-bit integer field from the binary stream, or throws an&quot;,&quot; * error if the next field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the signed 64-bit integer field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readInt64 = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readSignedVarint64();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed 64-bit integer field from the binary stream, or throws an&quot;,&quot; * error if the next field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * Returns the value as a string.&quot;,&quot; *&quot;,&quot; * @return {string} The value of the signed 64-bit integer field as a decimal&quot;,&quot; * string.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readInt64String = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readSignedVarint64String();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an unsigned 32-bit integer field from the binary stream, or throws an&quot;,&quot; * error if the next field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the unsigned 32-bit integer field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readUint32 = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readUnsignedVarint32();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an unsigned 32-bit integer field from the binary stream, or throws an&quot;,&quot; * error if the next field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * Returns the value as a string.&quot;,&quot; *&quot;,&quot; * @return {string} The value of the unsigned 32-bit integer field as a decimal&quot;,&quot; * string.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readUint32String = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readUnsignedVarint32String();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an unsigned 64-bit integer field from the binary stream, or throws an&quot;,&quot; * error if the next field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the unsigned 64-bit integer field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readUint64 = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readUnsignedVarint64();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an unsigned 64-bit integer field from the binary stream, or throws an&quot;,&quot; * error if the next field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * Returns the value as a string.&quot;,&quot; *&quot;,&quot; * @return {string} The value of the unsigned 64-bit integer field as a decimal&quot;,&quot; * string.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readUint64String = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readUnsignedVarint64String();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed zigzag-encoded 32-bit integer field from the binary stream,&quot;,&quot; * or throws an error if the next field in the stream is not of the correct&quot;,&quot; * wire type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the signed 32-bit integer field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readSint32 = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readZigzagVarint32();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed zigzag-encoded 64-bit integer field from the binary stream,&quot;,&quot; * or throws an error if the next field in the stream is not of the correct&quot;,&quot; * wire type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the signed 64-bit integer field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readSint64 = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readZigzagVarint64();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed zigzag-encoded 64-bit integer field from the binary stream,&quot;,&quot; * or throws an error if the next field in the stream is not of the correct&quot;,&quot; * wire type.&quot;,&quot; *&quot;,&quot; * @return {string} The value of the signed 64-bit integer field as a decimal string.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readSint64String = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readZigzagVarint64String();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an unsigned 32-bit fixed-length integer fiield from the binary stream,&quot;,&quot; * or throws an error if the next field in the stream is not of the correct&quot;,&quot; * wire type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the double field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readFixed32 = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32);&quot;,&quot;  return this.decoder_.readUint32();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an unsigned 64-bit fixed-length integer fiield from the binary stream,&quot;,&quot; * or throws an error if the next field in the stream is not of the correct&quot;,&quot; * wire type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the float field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readFixed64 = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);&quot;,&quot;  return this.decoder_.readUint64();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed 64-bit integer field from the binary stream as a string, or&quot;,&quot; * throws an error if the next field in the stream is not of the correct wire&quot;,&quot; * type.&quot;,&quot; *&quot;,&quot; * Returns the value as a string.&quot;,&quot; *&quot;,&quot; * @return {string} The value of the unsigned 64-bit integer field as a decimal&quot;,&quot; * string.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readFixed64String = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);&quot;,&quot;  return this.decoder_.readUint64String();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed 32-bit fixed-length integer fiield from the binary stream, or&quot;,&quot; * throws an error if the next field in the stream is not of the correct wire&quot;,&quot; * type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the signed 32-bit integer field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readSfixed32 = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32);&quot;,&quot;  return this.decoder_.readInt32();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed 32-bit fixed-length integer fiield from the binary stream, or&quot;,&quot; * throws an error if the next field in the stream is not of the correct wire&quot;,&quot; * type.&quot;,&quot; *&quot;,&quot; * @return {string} The value of the signed 32-bit integer field as a decimal&quot;,&quot; * string.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readSfixed32String = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32);&quot;,&quot;  return this.decoder_.readInt32().toString();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed 64-bit fixed-length integer fiield from the binary stream, or&quot;,&quot; * throws an error if the next field in the stream is not of the correct wire&quot;,&quot; * type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the sfixed64 field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readSfixed64 = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);&quot;,&quot;  return this.decoder_.readInt64();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a signed 64-bit fixed-length integer fiield from the binary stream, or&quot;,&quot; * throws an error if the next field in the stream is not of the correct wire&quot;,&quot; * type.&quot;,&quot; *&quot;,&quot; * Returns the value as a string.&quot;,&quot; *&quot;,&quot; * @return {string} The value of the sfixed64 field as a decimal string.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readSfixed64String = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);&quot;,&quot;  return this.decoder_.readInt64String();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a 32-bit floating-point field from the binary stream, or throws an&quot;,&quot; * error if the next field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the float field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readFloat = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32);&quot;,&quot;  return this.decoder_.readFloat();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a 64-bit floating-point field from the binary stream, or throws an&quot;,&quot; * error if the next field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the double field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readDouble = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);&quot;,&quot;  return this.decoder_.readDouble();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a boolean field from the binary stream, or throws an error if the next&quot;,&quot; * field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * @return {boolean} The value of the boolean field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readBool = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return !!this.decoder_.readUnsignedVarint32();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an enum field from the binary stream, or throws an error if the next&quot;,&quot; * field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * @return {number} The value of the enum field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readEnum = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readSignedVarint64();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a string field from the binary stream, or throws an error if the next&quot;,&quot; * field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * @return {string} The value of the string field.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readString = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  var length = this.decoder_.readUnsignedVarint32();&quot;,&quot;  return this.decoder_.readString(length);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a length-prefixed block of bytes from the binary stream, or returns&quot;,&quot; * null if the next field in the stream has an invalid length value.&quot;,&quot; *&quot;,&quot; * @return {!Uint8Array} The block of bytes.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readBytes = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  var length = this.decoder_.readUnsignedVarint32();&quot;,&quot;  return this.decoder_.readBytes(length);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a 64-bit varint or fixed64 field from the stream and returns it as a&quot;,&quot; * 8-character Unicode string for use as a hash table key, or throws an error&quot;,&quot; * if the next field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * @return {string} The hash value.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readVarintHash64 = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);&quot;,&quot;  return this.decoder_.readVarintHash64();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a 64-bit varint or fixed64 field from the stream and returns it as a&quot;,&quot; * 8-character Unicode string for use as a hash table key, or throws an error&quot;,&quot; * if the next field in the stream is not of the correct wire type.&quot;,&quot; *&quot;,&quot; * @return {string} The hash value.&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readFixedHash64 = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);&quot;,&quot;  return this.decoder_.readFixedHash64();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed scalar field using the supplied raw reader function.&quot;,&quot; * @param {function(this:jspb.BinaryDecoder)} decodeMethod&quot;,&quot; * @return {!Array}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedField_ = function(decodeMethod) {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);&quot;,&quot;  var length = this.decoder_.readUnsignedVarint32();&quot;,&quot;  var end = this.decoder_.getCursor() + length;&quot;,&quot;  var result = [];&quot;,&quot;  while (this.decoder_.getCursor() &lt; end) {&quot;,&quot;    // TODO(aappleby): .call is slow&quot;,&quot;    result.push(decodeMethod.call(this.decoder_));&quot;,&quot;  }&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed int32 field, which consists of a length header and a list of&quot;,&quot; * signed varints.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedInt32 = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readSignedVarint32);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed int32 field, which consists of a length header and a list of&quot;,&quot; * signed varints. Returns a list of strings.&quot;,&quot; * @return {!Array&lt;string&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedInt32String = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readSignedVarint32String);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed int64 field, which consists of a length header and a list of&quot;,&quot; * signed varints.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedInt64 = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readSignedVarint64);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed int64 field, which consists of a length header and a list of&quot;,&quot; * signed varints. Returns a list of strings.&quot;,&quot; * @return {!Array&lt;string&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedInt64String = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readSignedVarint64String);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed uint32 field, which consists of a length header and a list of&quot;,&quot; * unsigned varints.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedUint32 = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readUnsignedVarint32);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed uint32 field, which consists of a length header and a list of&quot;,&quot; * unsigned varints. Returns a list of strings.&quot;,&quot; * @return {!Array&lt;string&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedUint32String = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readUnsignedVarint32String);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed uint64 field, which consists of a length header and a list of&quot;,&quot; * unsigned varints.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedUint64 = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readUnsignedVarint64);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed uint64 field, which consists of a length header and a list of&quot;,&quot; * unsigned varints. Returns a list of strings.&quot;,&quot; * @return {!Array&lt;string&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedUint64String = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readUnsignedVarint64String);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed sint32 field, which consists of a length header and a list of&quot;,&quot; * zigzag varints.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedSint32 = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readZigzagVarint32);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed sint64 field, which consists of a length header and a list of&quot;,&quot; * zigzag varints.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedSint64 = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readZigzagVarint64);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed sint64 field, which consists of a length header and a list of&quot;,&quot; * zigzag varints.  Returns a list of strings.&quot;,&quot; * @return {!Array&lt;string&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedSint64String = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readZigzagVarint64String);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed fixed32 field, which consists of a length header and a list&quot;,&quot; * of unsigned 32-bit ints.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedFixed32 = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readUint32);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed fixed64 field, which consists of a length header and a list&quot;,&quot; * of unsigned 64-bit ints.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedFixed64 = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readUint64);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed fixed64 field, which consists of a length header and a list&quot;,&quot; * of unsigned 64-bit ints.  Returns a list of strings.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedFixed64String = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readUint64String);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed sfixed32 field, which consists of a length header and a list&quot;,&quot; * of 32-bit ints.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedSfixed32 = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readInt32);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed sfixed64 field, which consists of a length header and a list&quot;,&quot; * of 64-bit ints.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedSfixed64 = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readInt64);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed sfixed64 field, which consists of a length header and a list&quot;,&quot; * of 64-bit ints.  Returns a list of strings.&quot;,&quot; * @return {!Array&lt;string&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedSfixed64String = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readInt64String);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed float field, which consists of a length header and a list of&quot;,&quot; * floats.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedFloat = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readFloat);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed double field, which consists of a length header and a list of&quot;,&quot; * doubles.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedDouble = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readDouble);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed bool field, which consists of a length header and a list of&quot;,&quot; * unsigned varints.&quot;,&quot; * @return {!Array&lt;boolean&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedBool = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readBool);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed enum field, which consists of a length header and a list of&quot;,&quot; * unsigned varints.&quot;,&quot; * @return {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedEnum = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readEnum);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed varint hash64 field, which consists of a length header and a&quot;,&quot; * list of varint hash64s.&quot;,&quot; * @return {!Array&lt;string&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedVarintHash64 = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readVarintHash64);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads a packed fixed hash64 field, which consists of a length header and a&quot;,&quot; * list of fixed hash64s.&quot;,&quot; * @return {!Array&lt;string&gt;}&quot;,&quot; */&quot;,&quot;jspb.BinaryReader.prototype.readPackedFixedHash64 = function() {&quot;,&quot;  return this.readPackedField_(this.decoder_.readFixedHash64);&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../dossier.js" defer></script>