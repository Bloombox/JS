<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>message.js</title><link href="../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;message.js&quot;,&quot;protobuf/js/message.js&quot;,[&quot;// Protocol Buffers - Google&#39;s data interchange format&quot;,&quot;// Copyright 2008 Google Inc.  All rights reserved.&quot;,&quot;// https://developers.google.com/protocol-buffers/&quot;,&quot;//&quot;,&quot;// Redistribution and use in source and binary forms, with or without&quot;,&quot;// modification, are permitted provided that the following conditions are&quot;,&quot;// met:&quot;,&quot;//&quot;,&quot;//     * Redistributions of source code must retain the above copyright&quot;,&quot;// notice, this list of conditions and the following disclaimer.&quot;,&quot;//     * Redistributions in binary form must reproduce the above&quot;,&quot;// copyright notice, this list of conditions and the following disclaimer&quot;,&quot;// in the documentation and/or other materials provided with the&quot;,&quot;// distribution.&quot;,&quot;//     * Neither the name of Google Inc. nor the names of its&quot;,&quot;// contributors may be used to endorse or promote products derived from&quot;,&quot;// this software without specific prior written permission.&quot;,&quot;//&quot;,&quot;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;,&quot;// \&quot;AS IS\&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR&quot;,&quot;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&quot;,&quot;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&quot;,&quot;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,&quot;,&quot;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY&quot;,&quot;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&quot;,&quot;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&quot;,&quot;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Definition of jspb.Message.&quot;,&quot; *&quot;,&quot; * @author mwr@google.com (Mark Rawling)&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;jspb.ExtensionFieldBinaryInfo&#39;);&quot;,&quot;goog.provide(&#39;jspb.ExtensionFieldInfo&#39;);&quot;,&quot;goog.provide(&#39;jspb.Message&#39;);&quot;,null,&quot;goog.require(&#39;goog.array&#39;);&quot;,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;goog.crypt.base64&#39;);&quot;,&quot;goog.require(&#39;jspb.Map&#39;);&quot;,null,&quot;// Not needed in compilation units that have no protos with xids.&quot;,&quot;goog.forwardDeclare(&#39;xid.String&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * Stores information for a single extension field.&quot;,&quot; *&quot;,&quot; * For example, an extension field defined like so:&quot;,&quot; *&quot;,&quot; *     extend BaseMessage {&quot;,&quot; *       optional MyMessage my_field = 123;&quot;,&quot; *     }&quot;,&quot; *&quot;,&quot; * will result in an ExtensionFieldInfo object with these properties:&quot;,&quot; *&quot;,&quot; *     {&quot;,&quot; *       fieldIndex: 123,&quot;,&quot; *       fieldName: {my_field_renamed: 0},&quot;,&quot; *       ctor: proto.example.MyMessage,&quot;,&quot; *       toObjectFn: proto.example.MyMessage.toObject,&quot;,&quot; *       isRepeated: 0&quot;,&quot; *     }&quot;,&quot; *&quot;,&quot; * We include `toObjectFn` to allow the JSCompiler to perform dead-code removal&quot;,&quot; * on unused toObject() methods.&quot;,&quot; *&quot;,&quot; * If an extension field is primitive, ctor and toObjectFn will be null.&quot;,&quot; * isRepeated should be 0 or 1.&quot;,&quot; *&quot;,&quot; * binary{Reader,Writer}Fn and (if message type) binaryMessageSerializeFn are&quot;,&quot; * always provided. binaryReaderFn and binaryWriterFn are references to the&quot;,&quot; * appropriate methods on BinaryReader/BinaryWriter to read/write the value of&quot;,&quot; * this extension, and binaryMessageSerializeFn is a reference to the message&quot;,&quot; * class&#39;s .serializeBinary method, if available.&quot;,&quot; *&quot;,&quot; * @param {number} fieldNumber&quot;,&quot; * @param {Object} fieldName This has the extension field name as a property.&quot;,&quot; * @param {?function(new: jspb.Message, Array=)} ctor&quot;,&quot; * @param {?function((boolean|undefined),!jspb.Message):!Object} toObjectFn&quot;,&quot; * @param {number} isRepeated&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;jspb.ExtensionFieldInfo = function(fieldNumber, fieldName, ctor, toObjectFn,&quot;,&quot;    isRepeated) {&quot;,&quot;  /** @const */&quot;,&quot;  this.fieldIndex = fieldNumber;&quot;,&quot;  /** @const */&quot;,&quot;  this.fieldName = fieldName;&quot;,&quot;  /** @const */&quot;,&quot;  this.ctor = ctor;&quot;,&quot;  /** @const */&quot;,&quot;  this.toObjectFn = toObjectFn;&quot;,&quot;  /** @const */&quot;,&quot;  this.isRepeated = isRepeated;&quot;,&quot;};&quot;,null,&quot;/**&quot;,&quot; * Stores binary-related information for a single extension field.&quot;,&quot; * @param {!jspb.ExtensionFieldInfo&lt;T&gt;} fieldInfo&quot;,&quot; * @param {function(this:jspb.BinaryReader,number,?)} binaryReaderFn&quot;,&quot; * @param {function(this:jspb.BinaryWriter,number,?)&quot;,&quot; *        |function(this:jspb.BinaryWriter,number,?,?,?,?,?)} binaryWriterFn&quot;,&quot; * @param {function(?,?)=} opt_binaryMessageSerializeFn&quot;,&quot; * @param {function(?,?)=} opt_binaryMessageDeserializeFn&quot;,&quot; * @param {boolean=} opt_isPacked&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;jspb.ExtensionFieldBinaryInfo = function(fieldInfo, binaryReaderFn, binaryWriterFn,&quot;,&quot;    opt_binaryMessageSerializeFn, opt_binaryMessageDeserializeFn, opt_isPacked) {&quot;,&quot;  /** @const */&quot;,&quot;  this.fieldInfo = fieldInfo;&quot;,&quot;  /** @const */&quot;,&quot;  this.binaryReaderFn = binaryReaderFn;&quot;,&quot;  /** @const */&quot;,&quot;  this.binaryWriterFn = binaryWriterFn;&quot;,&quot;  /** @const */&quot;,&quot;  this.binaryMessageSerializeFn = opt_binaryMessageSerializeFn;&quot;,&quot;  /** @const */&quot;,&quot;  this.binaryMessageDeserializeFn = opt_binaryMessageDeserializeFn;&quot;,&quot;  /** @const */&quot;,&quot;  this.isPacked = opt_isPacked;&quot;,&quot;};&quot;,null,&quot;/**&quot;,&quot; * @return {boolean} Does this field represent a sub Message?&quot;,&quot; */&quot;,&quot;jspb.ExtensionFieldInfo.prototype.isMessageType = function() {&quot;,&quot;  return !!this.ctor;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Base class for all JsPb messages.&quot;,&quot; *&quot;,&quot; * Several common methods (toObject, serializeBinary, in particular) are not&quot;,&quot; * defined on the prototype to encourage code patterns that minimize code bloat&quot;,&quot; * due to otherwise unused code on all protos contained in the project.&quot;,&quot; *&quot;,&quot; * If you want to call these methods on a generic message, either&quot;,&quot; * pass in your instance of method as a parameter:&quot;,&quot; *     someFunction(instanceOfKnownProto,&quot;,&quot; *                  KnownProtoClass.prototype.serializeBinary);&quot;,&quot; * or use a lambda that knows the type:&quot;,&quot; *     someFunction(()=&gt;instanceOfKnownProto.serializeBinary());&quot;,&quot; * or, if you don&#39;t care about code size, just suppress the&quot;,&quot; *     WARNING - Property serializeBinary never defined on jspb.Message&quot;,&quot; * and call it the intuitive way.&quot;,&quot; *&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; */&quot;,&quot;jspb.Message = function() {&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether to generate toObject methods for objects. Turn&quot;,&quot; *     this off, if you do not want toObject to be ever used in your project.&quot;,&quot; *     When turning off this flag, consider adding a conformance test that bans&quot;,&quot; *     calling toObject. Enabling this will disable the JSCompiler&#39;s ability to&quot;,&quot; *     dead code eliminate fields used in protocol buffers that are never used&quot;,&quot; *     in an application.&quot;,&quot; */&quot;,&quot;goog.define(&#39;jspb.Message.GENERATE_TO_OBJECT&#39;, true);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether to generate fromObject methods for objects. Turn&quot;,&quot; *     this off, if you do not want fromObject to be ever used in your project.&quot;,&quot; *     When turning off this flag, consider adding a conformance test that bans&quot;,&quot; *     calling fromObject. Enabling this might disable the JSCompiler&#39;s ability&quot;,&quot; *     to dead code eliminate fields used in protocol buffers that are never&quot;,&quot; *     used in an application.&quot;,&quot; *     NOTE: By default no protos actually have a fromObject method. You need to&quot;,&quot; *     add the jspb.generate_from_object options to the proto definition to&quot;,&quot; *     activate the feature.&quot;,&quot; *     By default this is enabled for test code only.&quot;,&quot; */&quot;,&quot;goog.define(&#39;jspb.Message.GENERATE_FROM_OBJECT&#39;, !goog.DISALLOW_TEST_ONLY_CODE);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether to generate toString methods for objects. Turn&quot;,&quot; *     this off if you do not use toString in your project and want to trim it&quot;,&quot; *     from the compiled JS.&quot;,&quot; */&quot;,&quot;goog.define(&#39;jspb.Message.GENERATE_TO_STRING&#39;, true);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether arrays passed to initialize() can be assumed to be&quot;,&quot; *     local (e.g. not from another iframe) and thus safely classified with&quot;,&quot; *     instanceof Array.&quot;,&quot; */&quot;,&quot;goog.define(&#39;jspb.Message.ASSUME_LOCAL_ARRAYS&#39;, false);&quot;,null,null,&quot;// TODO(jakubvrana): Turn this off by default.&quot;,&quot;/**&quot;,&quot; * @define {boolean} Disabling the serialization of empty trailing fields&quot;,&quot; *     reduces the size of serialized protos. The price is an extra iteration of&quot;,&quot; *     the proto before serialization. This is enabled by default to be&quot;,&quot; *     backwards compatible. Projects are advised to turn this flag always off.&quot;,&quot; */&quot;,&quot;goog.define(&#39;jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS&#39;, true);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Turning on this flag does NOT change the behavior of JSPB&quot;,&quot; *     and only affects private internal state. It may, however, break some&quot;,&quot; *     tests that use naive deeply-equals algorithms, because using a proto&quot;,&quot; *     mutates its internal state.&quot;,&quot; *     Projects are advised to turn this flag always on.&quot;,&quot; */&quot;,&quot;goog.define(&#39;jspb.Message.MINIMIZE_MEMORY_ALLOCATIONS&#39;, true);&quot;,&quot;// TODO(b/19419436): Delete this flag.&quot;,null,null,&quot;/**&quot;,&quot; * Does this JavaScript environment support Uint8Aray typed arrays?&quot;,&quot; * @type {boolean}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.SUPPORTS_UINT8ARRAY_ = (typeof Uint8Array == &#39;function&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * The internal data array.&quot;,&quot; * @type {!Array}&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.array;&quot;,null,null,&quot;/**&quot;,&quot; * Wrappers are the constructed instances of message-type fields. They are built&quot;,&quot; * on demand from the raw array data. Includes message fields, repeated message&quot;,&quot; * fields and extension message fields. Indexed by field number.&quot;,&quot; * @type {Object}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.wrappers_;&quot;,null,null,&quot;/**&quot;,&quot; * The object that contains extension fields, if any. This is an object that&quot;,&quot; * maps from a proto field number to the field&#39;s value.&quot;,&quot; * @type {Object}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.extensionObject_;&quot;,null,null,&quot;/**&quot;,&quot; * Non-extension fields with a field number at or above the pivot are&quot;,&quot; * stored in the extension object (in addition to all extension fields).&quot;,&quot; * @type {number}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.pivot_;&quot;,null,null,&quot;/**&quot;,&quot; * The JsPb message_id of this proto.&quot;,&quot; * @type {string|undefined} the message id or undefined if this message&quot;,&quot; *     has no id.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.messageId_;&quot;,null,null,&quot;/**&quot;,&quot; * Repeated float or double fields which have been converted to include only&quot;,&quot; * numbers and not strings holding \&quot;NaN\&quot;, \&quot;Infinity\&quot; and \&quot;-Infinity\&quot;.&quot;,&quot; * @private {!Object&lt;number,boolean&gt;|undefined}&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.convertedFloatingPointFields_;&quot;,null,null,&quot;/**&quot;,&quot; * Repeated fields numbers.&quot;,&quot; * @protected {?Array&lt;number&gt;|undefined}&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.repeatedFields;&quot;,null,null,&quot;/**&quot;,&quot; * The xid of this proto type (The same for all instances of a proto). Provides&quot;,&quot; * a way to identify a proto by stable obfuscated name.&quot;,&quot; * @see {xid}.&quot;,&quot; * Available if {@link jspb.generate_xid} is added as a Message option to&quot;,&quot; * a protocol buffer.&quot;,&quot; * @const {!xid.String|undefined} The xid or undefined if message is&quot;,&quot; *     annotated to generate the xid.&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.messageXid;&quot;,null,null,null,&quot;/**&quot;,&quot; * Returns the JsPb message_id of this proto.&quot;,&quot; * @return {string|undefined} the message id or undefined if this message&quot;,&quot; *     has no id.&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.getJsPbMessageId = function() {&quot;,&quot;  return this.messageId_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * An offset applied to lookups into this.array to account for the presence or&quot;,&quot; * absence of a messageId at position 0. For response messages, this will be 0.&quot;,&quot; * Otherwise, it will be -1 so that the first array position is not wasted.&quot;,&quot; * @type {number}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.arrayIndexOffset_;&quot;,null,null,&quot;/**&quot;,&quot; * Returns the index into msg.array at which the proto field with tag number&quot;,&quot; * fieldNumber will be located.&quot;,&quot; * @param {!jspb.Message} msg Message for which we&#39;re calculating an index.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @return {number} The index.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.getIndex_ = function(msg, fieldNumber) {&quot;,&quot;  return fieldNumber + msg.arrayIndexOffset_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the tag number based on the index in msg.array.&quot;,&quot; * @param {!jspb.Message} msg Message for which we&#39;re calculating an index.&quot;,&quot; * @param {number} index The tag number.&quot;,&quot; * @return {number} The field number.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.getFieldNumber_ = function(msg, index) {&quot;,&quot;  return index - msg.arrayIndexOffset_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Initializes a JsPb Message.&quot;,&quot; * @param {!jspb.Message} msg The JsPb proto to modify.&quot;,&quot; * @param {Array|undefined} data An initial data array.&quot;,&quot; * @param {string|number} messageId For response messages, the message id or &#39;&#39;&quot;,&quot; *     if no message id is specified. For non-response messages, 0.&quot;,&quot; * @param {number} suggestedPivot The field number at which to start putting&quot;,&quot; *     fields into the extension object. This is only used if data does not&quot;,&quot; *     contain an extension object already. -1 if no extension object is&quot;,&quot; *     required for this message type.&quot;,&quot; * @param {Array&lt;number&gt;} repeatedFields The message&#39;s repeated fields.&quot;,&quot; * @param {Array&lt;!Array&lt;number&gt;&gt;=} opt_oneofFields The fields belonging to&quot;,&quot; *     each of the message&#39;s oneof unions.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.initialize = function(&quot;,&quot;    msg, data, messageId, suggestedPivot, repeatedFields, opt_oneofFields) {&quot;,&quot;  msg.wrappers_ = jspb.Message.MINIMIZE_MEMORY_ALLOCATIONS ? null : {};&quot;,&quot;  if (!data) {&quot;,&quot;    data = messageId ? [messageId] : [];&quot;,&quot;  }&quot;,&quot;  msg.messageId_ = messageId ? String(messageId) : undefined;&quot;,&quot;  // If the messageId is 0, this message is not a response message, so we shift&quot;,&quot;  // array indices down by 1 so as not to waste the first position in the array,&quot;,&quot;  // which would otherwise go unused.&quot;,&quot;  msg.arrayIndexOffset_ = messageId === 0 ? -1 : 0;&quot;,&quot;  msg.array = data;&quot;,&quot;  jspb.Message.initPivotAndExtensionObject_(msg, suggestedPivot);&quot;,&quot;  msg.convertedFloatingPointFields_ = {};&quot;,null,&quot;  if (!jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS) {&quot;,&quot;    // TODO(jakubvrana): This is same for all instances, move to prototype.&quot;,&quot;    // TODO(jakubvrana): There are indexOf calls on this in serializtion,&quot;,&quot;    // consider switching to a set.&quot;,&quot;    msg.repeatedFields = repeatedFields;&quot;,&quot;  }&quot;,null,&quot;  if (repeatedFields) {&quot;,&quot;    for (var i = 0; i &lt; repeatedFields.length; i++) {&quot;,&quot;      var fieldNumber = repeatedFields[i];&quot;,&quot;      if (fieldNumber &lt; msg.pivot_) {&quot;,&quot;        var index = jspb.Message.getIndex_(msg, fieldNumber);&quot;,&quot;        msg.array[index] = msg.array[index] ||&quot;,&quot;            (jspb.Message.MINIMIZE_MEMORY_ALLOCATIONS ?&quot;,&quot;                jspb.Message.EMPTY_LIST_SENTINEL_ :&quot;,&quot;                []);&quot;,&quot;      } else {&quot;,&quot;        jspb.Message.maybeInitEmptyExtensionObject_(msg);&quot;,&quot;        msg.extensionObject_[fieldNumber] =&quot;,&quot;            msg.extensionObject_[fieldNumber] ||&quot;,&quot;            (jspb.Message.MINIMIZE_MEMORY_ALLOCATIONS ?&quot;,&quot;                jspb.Message.EMPTY_LIST_SENTINEL_ :&quot;,&quot;                []);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  if (opt_oneofFields &amp;&amp; opt_oneofFields.length) {&quot;,&quot;    // Compute the oneof case for each union. This ensures only one value is&quot;,&quot;    // set in the union.&quot;,&quot;    for (var i = 0; i &lt; opt_oneofFields.length; i++) {&quot;,&quot;      jspb.Message.computeOneofCase(msg, opt_oneofFields[i]);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Used to mark empty repeated fields. Serializes to null when serialized&quot;,&quot; * to JSON.&quot;,&quot; * When reading a repeated field readers must check the return value against&quot;,&quot; * this value and return and replace it with a new empty array if it is&quot;,&quot; * present.&quot;,&quot; * @private @const {!Object}&quot;,&quot; */&quot;,&quot;jspb.Message.EMPTY_LIST_SENTINEL_ = goog.DEBUG &amp;&amp; Object.freeze ?&quot;,&quot;    Object.freeze([]) :&quot;,&quot;    [];&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if the provided argument is an array.&quot;,&quot; * @param {*} o The object to classify as array or not.&quot;,&quot; * @return {boolean} True if the provided object is an array.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.isArray_ = function(o) {&quot;,&quot;  return jspb.Message.ASSUME_LOCAL_ARRAYS ? o instanceof Array :&quot;,&quot;                                            goog.isArray(o);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * If the array contains an extension object in its last position, then the&quot;,&quot; * object is kept in place and its position is used as the pivot.  If not,&quot;,&quot; * decides the pivot of the message based on suggestedPivot without&quot;,&quot; * materializing the extension object.&quot;,&quot; *&quot;,&quot; * @param {!jspb.Message} msg The JsPb proto to modify.&quot;,&quot; * @param {number} suggestedPivot See description for initialize().&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.initPivotAndExtensionObject_ = function(msg, suggestedPivot) {&quot;,&quot;  if (msg.array.length) {&quot;,&quot;    var foundIndex = msg.array.length - 1;&quot;,&quot;    var obj = msg.array[foundIndex];&quot;,&quot;    // Normal fields are never objects, so we can be sure that if we find an&quot;,&quot;    // object here, then it&#39;s the extension object. However, we must ensure that&quot;,&quot;    // the object is not an array, since arrays are valid field values.&quot;,&quot;    // NOTE(lukestebbing): We avoid looking at .length to avoid a JIT bug&quot;,&quot;    // in Safari on iOS 8. See the description of CL/86511464 for details.&quot;,&quot;    if (obj &amp;&amp; typeof obj == &#39;object&#39; &amp;&amp; !jspb.Message.isArray_(obj) &amp;&amp;&quot;,&quot;        !(jspb.Message.SUPPORTS_UINT8ARRAY_ &amp;&amp; obj instanceof Uint8Array)) {&quot;,&quot;      msg.pivot_ = jspb.Message.getFieldNumber_(msg, foundIndex);&quot;,&quot;      msg.extensionObject_ = obj;&quot;,&quot;      return;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  if (suggestedPivot &gt; -1) {&quot;,&quot;    msg.pivot_ = suggestedPivot;&quot;,&quot;    // Avoid changing the shape of the proto with an empty extension object by&quot;,&quot;    // deferring the materialization of the extension object until the first&quot;,&quot;    // time a field set into it (may be due to getting a repeated proto field&quot;,&quot;    // from it, in which case a new empty array is set into it at first).&quot;,&quot;    msg.extensionObject_ = null;&quot;,&quot;  } else {&quot;,&quot;    // suggestedPivot is -1, which means that we don&#39;t have an extension object&quot;,&quot;    // at all, in which case all fields are stored in the array.&quot;,&quot;    msg.pivot_ = Number.MAX_VALUE;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates an empty extensionObject_ if non exists.&quot;,&quot; * @param {!jspb.Message} msg The JsPb proto to modify.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.maybeInitEmptyExtensionObject_ = function(msg) {&quot;,&quot;  var pivotIndex = jspb.Message.getIndex_(msg, msg.pivot_);&quot;,&quot;  if (!msg.array[pivotIndex]) {&quot;,&quot;    msg.extensionObject_ = msg.array[pivotIndex] = {};&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a JsPb repeated message field into an object list.&quot;,&quot; * @param {!Array&lt;T&gt;} field The repeated message field to be&quot;,&quot; *     converted.&quot;,&quot; * @param {?function(boolean=): Object|&quot;,&quot; *     function((boolean|undefined),T): Object} toObjectFn The toObject&quot;,&quot; *     function for this field.  We need to pass this for effective dead code&quot;,&quot; *     removal.&quot;,&quot; * @param {boolean=} opt_includeInstance Whether to include the JSPB instance&quot;,&quot; *     for transitional soy proto support: http://goto/soy-param-migration&quot;,&quot; * @return {!Array&lt;Object&gt;} An array of converted message objects.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;jspb.Message.toObjectList = function(field, toObjectFn, opt_includeInstance) {&quot;,&quot;  // Not using goog.array.map in the generated code to keep it small.&quot;,&quot;  // And not using it here to avoid a function call.&quot;,&quot;  var result = [];&quot;,&quot;  for (var i = 0; i &lt; field.length; i++) {&quot;,&quot;    result[i] = toObjectFn.call(field[i], opt_includeInstance,&quot;,&quot;      /** @type {!jspb.Message} */ (field[i]));&quot;,&quot;  }&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds a proto&#39;s extension data to a Soy rendering object.&quot;,&quot; * @param {!jspb.Message} proto The proto whose extensions to convert.&quot;,&quot; * @param {!Object} obj The Soy object to add converted extension data to.&quot;,&quot; * @param {!Object} extensions The proto class&#39; registered extensions.&quot;,&quot; * @param {function(this:?, jspb.ExtensionFieldInfo) : *} getExtensionFn&quot;,&quot; *     The proto class&#39; getExtension function. Passed for effective dead code&quot;,&quot; *     removal.&quot;,&quot; * @param {boolean=} opt_includeInstance Whether to include the JSPB instance&quot;,&quot; *     for transitional soy proto support: http://goto/soy-param-migration&quot;,&quot; */&quot;,&quot;jspb.Message.toObjectExtension = function(proto, obj, extensions,&quot;,&quot;    getExtensionFn, opt_includeInstance) {&quot;,&quot;  for (var fieldNumber in extensions) {&quot;,&quot;    var fieldInfo = extensions[fieldNumber];&quot;,&quot;    var value = getExtensionFn.call(proto, fieldInfo);&quot;,&quot;    if (value != null) {&quot;,&quot;      for (var name in fieldInfo.fieldName) {&quot;,&quot;        if (fieldInfo.fieldName.hasOwnProperty(name)) {&quot;,&quot;          break; // the compiled field name&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;      if (!fieldInfo.toObjectFn) {&quot;,&quot;        obj[name] = value;&quot;,&quot;      } else {&quot;,&quot;        if (fieldInfo.isRepeated) {&quot;,&quot;          obj[name] = jspb.Message.toObjectList(&quot;,&quot;              /** @type {!Array&lt;jspb.Message&gt;} */ (value),&quot;,&quot;              fieldInfo.toObjectFn, opt_includeInstance);&quot;,&quot;        } else {&quot;,&quot;          obj[name] = fieldInfo.toObjectFn(opt_includeInstance, value);&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Writes a proto&#39;s extension data to a binary-format output stream.&quot;,&quot; * @param {!jspb.Message} proto The proto whose extensions to convert.&quot;,&quot; * @param {*} writer The binary-format writer to write to.&quot;,&quot; * @param {!Object} extensions The proto class&#39; registered extensions.&quot;,&quot; * @param {function(this:jspb.Message,!jspb.ExtensionFieldInfo) : *} getExtensionFn The proto&quot;,&quot; *     class&#39; getExtension function. Passed for effective dead code removal.&quot;,&quot; */&quot;,&quot;jspb.Message.serializeBinaryExtensions = function(proto, writer, extensions,&quot;,&quot;    getExtensionFn) {&quot;,&quot;  for (var fieldNumber in extensions) {&quot;,&quot;    var binaryFieldInfo = extensions[fieldNumber];&quot;,&quot;    var fieldInfo = binaryFieldInfo.fieldInfo;&quot;,null,&quot;    // The old codegen doesn&#39;t add the extra fields to ExtensionFieldInfo, so we&quot;,&quot;    // need to gracefully error-out here rather than produce a null dereference&quot;,&quot;    // below.&quot;,&quot;    if (!binaryFieldInfo.binaryWriterFn) {&quot;,&quot;      throw new Error(&#39;Message extension present that was generated &#39; +&quot;,&quot;                      &#39;without binary serialization support&#39;);&quot;,&quot;    }&quot;,&quot;    var value = getExtensionFn.call(proto, fieldInfo);&quot;,&quot;    if (value != null) {&quot;,&quot;      if (fieldInfo.isMessageType()) {&quot;,&quot;        // If the message type of the extension was generated without binary&quot;,&quot;        // support, there may not be a binary message serializer function, and&quot;,&quot;        // we can&#39;t know when we codegen the extending message that the extended&quot;,&quot;        // message may require binary support, so we can *only* catch this error&quot;,&quot;        // here, at runtime (and this decoupled codegen is the whole point of&quot;,&quot;        // extensions!).&quot;,&quot;        if (binaryFieldInfo.binaryMessageSerializeFn) {&quot;,&quot;          binaryFieldInfo.binaryWriterFn.call(writer, fieldInfo.fieldIndex,&quot;,&quot;              value, binaryFieldInfo.binaryMessageSerializeFn);&quot;,&quot;        } else {&quot;,&quot;          throw new Error(&#39;Message extension present holding submessage &#39; +&quot;,&quot;                          &#39;without binary support enabled, and message is &#39; +&quot;,&quot;                          &#39;being serialized to binary format&#39;);&quot;,&quot;        }&quot;,&quot;      } else {&quot;,&quot;        binaryFieldInfo.binaryWriterFn.call(&quot;,&quot;            writer, fieldInfo.fieldIndex, value);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Reads an extension field from the given reader and, if a valid extension,&quot;,&quot; * sets the extension value.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {{&quot;,&quot; *   skipField:function(this:jspb.BinaryReader),&quot;,&quot; *   getFieldNumber:function(this:jspb.BinaryReader):number&quot;,&quot; * }} reader&quot;,&quot; * @param {!Object} extensions The extensions object.&quot;,&quot; * @param {function(this:jspb.Message,!jspb.ExtensionFieldInfo)} getExtensionFn&quot;,&quot; * @param {function(this:jspb.Message,!jspb.ExtensionFieldInfo, ?)} setExtensionFn&quot;,&quot; */&quot;,&quot;jspb.Message.readBinaryExtension = function(msg, reader, extensions,&quot;,&quot;    getExtensionFn, setExtensionFn) {&quot;,&quot;  var binaryFieldInfo = extensions[reader.getFieldNumber()];&quot;,&quot;  if (!binaryFieldInfo) {&quot;,&quot;    reader.skipField();&quot;,&quot;    return;&quot;,&quot;  }&quot;,&quot;  var fieldInfo = binaryFieldInfo.fieldInfo;&quot;,&quot;  if (!binaryFieldInfo.binaryReaderFn) {&quot;,&quot;    throw new Error(&#39;Deserializing extension whose generated code does not &#39; +&quot;,&quot;                    &#39;support binary format&#39;);&quot;,&quot;  }&quot;,null,&quot;  var value;&quot;,&quot;  if (fieldInfo.isMessageType()) {&quot;,&quot;    value = new fieldInfo.ctor();&quot;,&quot;    binaryFieldInfo.binaryReaderFn.call(&quot;,&quot;        reader, value, binaryFieldInfo.binaryMessageDeserializeFn);&quot;,&quot;  } else {&quot;,&quot;    // All other types.&quot;,&quot;    value = binaryFieldInfo.binaryReaderFn.call(reader);&quot;,&quot;  }&quot;,null,&quot;  if (fieldInfo.isRepeated &amp;&amp; !binaryFieldInfo.isPacked) {&quot;,&quot;    var currentList = getExtensionFn.call(msg, fieldInfo);&quot;,&quot;    if (!currentList) {&quot;,&quot;      setExtensionFn.call(msg, fieldInfo, [value]);&quot;,&quot;    } else {&quot;,&quot;      currentList.push(value);&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    setExtensionFn.call(msg, fieldInfo, value);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the value of a non-extension field.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @return {string|number|boolean|Uint8Array|Array|null|undefined}&quot;,&quot; * The field&#39;s value.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.getField = function(msg, fieldNumber) {&quot;,&quot;  if (fieldNumber &lt; msg.pivot_) {&quot;,&quot;    var index = jspb.Message.getIndex_(msg, fieldNumber);&quot;,&quot;    var val = msg.array[index];&quot;,&quot;    if (val === jspb.Message.EMPTY_LIST_SENTINEL_) {&quot;,&quot;      return msg.array[index] = [];&quot;,&quot;    }&quot;,&quot;    return val;&quot;,&quot;  } else {&quot;,&quot;    if (!msg.extensionObject_) {&quot;,&quot;      return undefined;&quot;,&quot;    }&quot;,&quot;    var val = msg.extensionObject_[fieldNumber];&quot;,&quot;    if (val === jspb.Message.EMPTY_LIST_SENTINEL_) {&quot;,&quot;      return msg.extensionObject_[fieldNumber] = [];&quot;,&quot;    }&quot;,&quot;    return val;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the value of a non-extension repeated field.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @return {!Array}&quot;,&quot; * The field&#39;s value.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.getRepeatedField = function(msg, fieldNumber) {&quot;,&quot;  if (fieldNumber &lt; msg.pivot_) {&quot;,&quot;    var index = jspb.Message.getIndex_(msg, fieldNumber);&quot;,&quot;    var val = msg.array[index];&quot;,&quot;    if (val === jspb.Message.EMPTY_LIST_SENTINEL_) {&quot;,&quot;      return msg.array[index] = [];&quot;,&quot;    }&quot;,&quot;    return val;&quot;,&quot;  }&quot;,null,&quot;  var val = msg.extensionObject_[fieldNumber];&quot;,&quot;  if (val === jspb.Message.EMPTY_LIST_SENTINEL_) {&quot;,&quot;    return msg.extensionObject_[fieldNumber] = [];&quot;,&quot;  }&quot;,&quot;  return val;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the value of an optional float or double field.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @return {?number|undefined} The field&#39;s value.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.getOptionalFloatingPointField = function(msg, fieldNumber) {&quot;,&quot;  var value = jspb.Message.getField(msg, fieldNumber);&quot;,&quot;  // Converts \&quot;NaN\&quot;, \&quot;Infinity\&quot; and \&quot;-Infinity\&quot; to their corresponding numbers.&quot;,&quot;  return value == null ? value : +value;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the value of a repeated float or double field.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @return {!Array&lt;number&gt;} The field&#39;s value.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.getRepeatedFloatingPointField = function(msg, fieldNumber) {&quot;,&quot;  var values = jspb.Message.getRepeatedField(msg, fieldNumber);&quot;,&quot;  if (!msg.convertedFloatingPointFields_) {&quot;,&quot;    msg.convertedFloatingPointFields_ = {};&quot;,&quot;  }&quot;,&quot;  if (!msg.convertedFloatingPointFields_[fieldNumber]) {&quot;,&quot;    for (var i = 0; i &lt; values.length; i++) {&quot;,&quot;      // Converts \&quot;NaN\&quot;, \&quot;Infinity\&quot; and \&quot;-Infinity\&quot; to their corresponding&quot;,&quot;      // numbers.&quot;,&quot;      values[i] = +values[i];&quot;,&quot;    }&quot;,&quot;    msg.convertedFloatingPointFields_[fieldNumber] = true;&quot;,&quot;  }&quot;,&quot;  return /** @type {!Array&lt;number&gt;} */ (values);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Coerce a &#39;bytes&#39; field to a base 64 string.&quot;,&quot; * @param {string|Uint8Array|null} value&quot;,&quot; * @return {?string} The field&#39;s coerced value.&quot;,&quot; */&quot;,&quot;jspb.Message.bytesAsB64 = function(value) {&quot;,&quot;  if (value == null || goog.isString(value)) {&quot;,&quot;    return value;&quot;,&quot;  }&quot;,&quot;  if (jspb.Message.SUPPORTS_UINT8ARRAY_ &amp;&amp; value instanceof Uint8Array) {&quot;,&quot;    return goog.crypt.base64.encodeByteArray(value);&quot;,&quot;  }&quot;,&quot;  goog.asserts.fail(&#39;Cannot coerce to b64 string: &#39; + goog.typeOf(value));&quot;,&quot;  return null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Coerce a &#39;bytes&#39; field to a Uint8Array byte buffer.&quot;,&quot; * Note that Uint8Array is not supported on IE versions before 10 nor on Opera&quot;,&quot; * Mini. @see http://caniuse.com/Uint8Array&quot;,&quot; * @param {string|Uint8Array|null} value&quot;,&quot; * @return {?Uint8Array} The field&#39;s coerced value.&quot;,&quot; */&quot;,&quot;jspb.Message.bytesAsU8 = function(value) {&quot;,&quot;  if (value == null || value instanceof Uint8Array) {&quot;,&quot;    return value;&quot;,&quot;  }&quot;,&quot;  if (goog.isString(value)) {&quot;,&quot;    return goog.crypt.base64.decodeStringToUint8Array(value);&quot;,&quot;  }&quot;,&quot;  goog.asserts.fail(&#39;Cannot coerce to Uint8Array: &#39; + goog.typeOf(value));&quot;,&quot;  return null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Coerce a repeated &#39;bytes&#39; field to an array of base 64 strings.&quot;,&quot; * Note: the returned array should be treated as immutable.&quot;,&quot; * @param {!Array&lt;string&gt;|!Array&lt;!Uint8Array&gt;} value&quot;,&quot; * @return {!Array&lt;string?&gt;} The field&#39;s coerced value.&quot;,&quot; */&quot;,&quot;jspb.Message.bytesListAsB64 = function(value) {&quot;,&quot;  jspb.Message.assertConsistentTypes_(value);&quot;,&quot;  if (!value.length || goog.isString(value[0])) {&quot;,&quot;    return /** @type {!Array&lt;string&gt;} */ (value);&quot;,&quot;  }&quot;,&quot;  return goog.array.map(value, jspb.Message.bytesAsB64);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Coerce a repeated &#39;bytes&#39; field to an array of Uint8Array byte buffers.&quot;,&quot; * Note: the returned array should be treated as immutable.&quot;,&quot; * Note that Uint8Array is not supported on IE versions before 10 nor on Opera&quot;,&quot; * Mini. @see http://caniuse.com/Uint8Array&quot;,&quot; * @param {!Array&lt;string&gt;|!Array&lt;!Uint8Array&gt;} value&quot;,&quot; * @return {!Array&lt;Uint8Array?&gt;} The field&#39;s coerced value.&quot;,&quot; */&quot;,&quot;jspb.Message.bytesListAsU8 = function(value) {&quot;,&quot;  jspb.Message.assertConsistentTypes_(value);&quot;,&quot;  if (!value.length || value[0] instanceof Uint8Array) {&quot;,&quot;    return /** @type {!Array&lt;!Uint8Array&gt;} */ (value);&quot;,&quot;  }&quot;,&quot;  return goog.array.map(value, jspb.Message.bytesAsU8);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Asserts that all elements of an array are of the same type.&quot;,&quot; * @param {Array?} array The array to test.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.assertConsistentTypes_ = function(array) {&quot;,&quot;  if (goog.DEBUG &amp;&amp; array &amp;&amp; array.length &gt; 1) {&quot;,&quot;    var expected = goog.typeOf(array[0]);&quot;,&quot;    goog.array.forEach(array, function(e) {&quot;,&quot;      if (goog.typeOf(e) != expected) {&quot;,&quot;        goog.asserts.fail(&#39;Inconsistent type in JSPB repeated field array. &#39; +&quot;,&quot;            &#39;Got &#39; + goog.typeOf(e) + &#39; expected &#39; + expected);&quot;,&quot;      }&quot;,&quot;    });&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the value of a non-extension primitive field, with proto3 (non-nullable&quot;,&quot; * primitives) semantics. Returns `defaultValue` if the field is not otherwise&quot;,&quot; * set.&quot;,&quot; * @template T&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {T} defaultValue The default value.&quot;,&quot; * @return {T} The field&#39;s value.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.getFieldWithDefault = function(msg, fieldNumber, defaultValue) {&quot;,&quot;  var value = jspb.Message.getField(msg, fieldNumber);&quot;,&quot;  if (value == null) {&quot;,&quot;    return defaultValue;&quot;,&quot;  } else {&quot;,&quot;    return value;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Alias for getFieldWithDefault used by older generated code.&quot;,&quot; * @template T&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {T} defaultValue The default value.&quot;,&quot; * @return {T} The field&#39;s value.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.getFieldProto3 = jspb.Message.getFieldWithDefault;&quot;,null,null,&quot;/**&quot;,&quot; * Gets the value of a map field, lazily creating the map container if&quot;,&quot; * necessary.&quot;,&quot; *&quot;,&quot; * This should only be called from generated code, because it requires knowledge&quot;,&quot; * of serialization/parsing callbacks (which are required by the map at&quot;,&quot; * construction time, and the map may be constructed here).&quot;,&quot; *&quot;,&quot; * @template K, V&quot;,&quot; * @param {!jspb.Message} msg&quot;,&quot; * @param {number} fieldNumber&quot;,&quot; * @param {boolean|undefined} noLazyCreate&quot;,&quot; * @param {?=} opt_valueCtor&quot;,&quot; * @return {!jspb.Map&lt;K, V&gt;|undefined}&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.getMapField = function(msg, fieldNumber, noLazyCreate,&quot;,&quot;    opt_valueCtor) {&quot;,&quot;  if (!msg.wrappers_) {&quot;,&quot;    msg.wrappers_ = {};&quot;,&quot;  }&quot;,&quot;  // If we already have a map in the map wrappers, return that.&quot;,&quot;  if (fieldNumber in msg.wrappers_) {&quot;,&quot;    return msg.wrappers_[fieldNumber];&quot;,&quot;  } else if (noLazyCreate) {&quot;,&quot;    return undefined;&quot;,&quot;  } else {&quot;,&quot;    // Wrap the underlying elements array with a Map.&quot;,&quot;    var arr = jspb.Message.getField(msg, fieldNumber);&quot;,&quot;    if (!arr) {&quot;,&quot;      arr = [];&quot;,&quot;      jspb.Message.setField(msg, fieldNumber, arr);&quot;,&quot;    }&quot;,&quot;    return msg.wrappers_[fieldNumber] =&quot;,&quot;        new jspb.Map(&quot;,&quot;            /** @type {!Array&lt;!Array&lt;!Object&gt;&gt;} */ (arr), opt_valueCtor);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the value of a non-extension field.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {string|number|boolean|Uint8Array|Array|undefined} value New value&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.setField = function(msg, fieldNumber, value) {&quot;,&quot;  if (fieldNumber &lt; msg.pivot_) {&quot;,&quot;    msg.array[jspb.Message.getIndex_(msg, fieldNumber)] = value;&quot;,&quot;  } else {&quot;,&quot;    jspb.Message.maybeInitEmptyExtensionObject_(msg);&quot;,&quot;    msg.extensionObject_[fieldNumber] = value;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the value of a non-extension integer field of a proto3&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {number} value New value&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.setProto3IntField = function(msg, fieldNumber, value) {&quot;,&quot;  jspb.Message.setFieldIgnoringDefault_(msg, fieldNumber, value, 0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the value of a non-extension floating point field of a proto3&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {number} value New value&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.setProto3FloatField = function(msg, fieldNumber, value) {&quot;,&quot;  jspb.Message.setFieldIgnoringDefault_(msg, fieldNumber, value, 0.0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the value of a non-extension boolean field of a proto3&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {boolean} value New value&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.setProto3BooleanField = function(msg, fieldNumber, value) {&quot;,&quot;  jspb.Message.setFieldIgnoringDefault_(msg, fieldNumber, value, false);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the value of a non-extension String field of a proto3&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {string} value New value&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.setProto3StringField = function(msg, fieldNumber, value) {&quot;,&quot;  jspb.Message.setFieldIgnoringDefault_(msg, fieldNumber, value, \&quot;\&quot;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the value of a non-extension Bytes field of a proto3&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {!Uint8Array|string} value New value&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.setProto3BytesField = function(msg, fieldNumber, value) {&quot;,&quot;  jspb.Message.setFieldIgnoringDefault_(msg, fieldNumber, value, \&quot;\&quot;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the value of a non-extension enum field of a proto3&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {number} value New value&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.setProto3EnumField = function(msg, fieldNumber, value) {&quot;,&quot;  jspb.Message.setFieldIgnoringDefault_(msg, fieldNumber, value, 0);&quot;,&quot;};&quot;,null,null,null,&quot;/**&quot;,&quot; * Sets the value of a non-extension primitive field, with proto3 (non-nullable&quot;,&quot; * primitives) semantics of ignoring values that are equal to the type&#39;s&quot;,&quot; * default.&quot;,&quot; * @template T&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {!Uint8Array|string|number|boolean|undefined} value New value&quot;,&quot; * @param {!Uint8Array|string|number|boolean} defaultValue The default value.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.setFieldIgnoringDefault_ = function(&quot;,&quot;    msg, fieldNumber, value, defaultValue) {&quot;,&quot;  if (value != defaultValue) {&quot;,&quot;    jspb.Message.setField(msg, fieldNumber, value);&quot;,&quot;  } else {&quot;,&quot;    msg.array[jspb.Message.getIndex_(msg, fieldNumber)] = null;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds a value to a repeated, primitive field.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {string|number|boolean|!Uint8Array} value New value&quot;,&quot; * @param {number=} opt_index Index where to put new value.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.addToRepeatedField = function(msg, fieldNumber, value, opt_index) {&quot;,&quot;  var arr = jspb.Message.getRepeatedField(msg, fieldNumber);&quot;,&quot;  if (opt_index != undefined) {&quot;,&quot;    arr.splice(opt_index, 0, value);&quot;,&quot;  } else {&quot;,&quot;    arr.push(value);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the value of a field in a oneof union and clears all other fields in&quot;,&quot; * the union.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {!Array&lt;number&gt;} oneof The fields belonging to the union.&quot;,&quot; * @param {string|number|boolean|Uint8Array|Array|undefined} value New value&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.setOneofField = function(msg, fieldNumber, oneof, value) {&quot;,&quot;  var currentCase = jspb.Message.computeOneofCase(msg, oneof);&quot;,&quot;  if (currentCase &amp;&amp; currentCase !== fieldNumber &amp;&amp; value !== undefined) {&quot;,&quot;    if (msg.wrappers_ &amp;&amp; currentCase in msg.wrappers_) {&quot;,&quot;      msg.wrappers_[currentCase] = undefined;&quot;,&quot;    }&quot;,&quot;    jspb.Message.setField(msg, currentCase, undefined);&quot;,&quot;  }&quot;,&quot;  jspb.Message.setField(msg, fieldNumber, value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Computes the selection in a oneof group for the given message, ensuring&quot;,&quot; * only one field is set in the process.&quot;,&quot; *&quot;,&quot; * According to the protobuf language guide (&quot;,&quot; * https://developers.google.com/protocol-buffers/docs/proto#oneof), \&quot;if the&quot;,&quot; * parser encounters multiple members of the same oneof on the wire, only the&quot;,&quot; * last member seen is used in the parsed message.\&quot; Since JSPB serializes&quot;,&quot; * messages to a JSON array, the \&quot;last member seen\&quot; will always be the field&quot;,&quot; * with the greatest field number (directly corresponding to the greatest&quot;,&quot; * array index).&quot;,&quot; *&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {!Array&lt;number&gt;} oneof The field numbers belonging to the union.&quot;,&quot; * @return {number} The field number currently set in the union, or 0 if none.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.computeOneofCase = function(msg, oneof) {&quot;,&quot;  var oneofField;&quot;,&quot;  var oneofValue;&quot;,null,&quot;  for (var i = 0; i &lt; oneof.length; i++) {&quot;,&quot;    var fieldNumber = oneof[i];&quot;,&quot;    var value = jspb.Message.getField(msg, fieldNumber);&quot;,&quot;    if (value != null) {&quot;,&quot;      oneofField = fieldNumber;&quot;,&quot;      oneofValue = value;&quot;,&quot;      jspb.Message.setField(msg, fieldNumber, undefined);&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  if (oneofField) {&quot;,&quot;    // NB: We know the value is unique, so we can call jspb.Message.setField&quot;,&quot;    // directly instead of jpsb.Message.setOneofField. Also, setOneofField&quot;,&quot;    // calls this function.&quot;,&quot;    jspb.Message.setField(msg, oneofField, oneofValue);&quot;,&quot;    return oneofField;&quot;,&quot;  }&quot;,null,&quot;  return 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets and wraps a proto field on access.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {function(new:jspb.Message, Array)} ctor Constructor for the field.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {number=} opt_required True (1) if this is a required field.&quot;,&quot; * @return {jspb.Message} The field as a jspb proto.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.getWrapperField = function(msg, ctor, fieldNumber, opt_required) {&quot;,&quot;  // TODO(mwr): Consider copying data and/or arrays.&quot;,&quot;  if (!msg.wrappers_) {&quot;,&quot;    msg.wrappers_ = {};&quot;,&quot;  }&quot;,&quot;  if (!msg.wrappers_[fieldNumber]) {&quot;,&quot;    var data = /** @type {Array} */ (jspb.Message.getField(msg, fieldNumber));&quot;,&quot;    if (opt_required || data) {&quot;,&quot;      // TODO(mwr): Remove existence test for always valid default protos.&quot;,&quot;      msg.wrappers_[fieldNumber] = new ctor(data);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return /** @type {jspb.Message} */ (msg.wrappers_[fieldNumber]);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets and wraps a repeated proto field on access.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {function(new:jspb.Message, Array)} ctor Constructor for the field.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @return {Array&lt;!jspb.Message&gt;} The repeated field as an array of protos.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.getRepeatedWrapperField = function(msg, ctor, fieldNumber) {&quot;,&quot;  jspb.Message.wrapRepeatedField_(msg, ctor, fieldNumber);&quot;,&quot;  var val = msg.wrappers_[fieldNumber];&quot;,&quot;  if (val == jspb.Message.EMPTY_LIST_SENTINEL_) {&quot;,&quot;    val = msg.wrappers_[fieldNumber] = [];&quot;,&quot;  }&quot;,&quot;  return /** @type {!Array&lt;!jspb.Message&gt;} */ (val);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Wraps underlying array into proto message representation if it wasn&#39;t done&quot;,&quot; * before.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {function(new:jspb.Message, ?Array)} ctor Constructor for the field.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.wrapRepeatedField_ = function(msg, ctor, fieldNumber) {&quot;,&quot;  if (!msg.wrappers_) {&quot;,&quot;    msg.wrappers_ = {};&quot;,&quot;  }&quot;,&quot;  if (!msg.wrappers_[fieldNumber]) {&quot;,&quot;    var data = jspb.Message.getRepeatedField(msg, fieldNumber);&quot;,&quot;    for (var wrappers = [], i = 0; i &lt; data.length; i++) {&quot;,&quot;      wrappers[i] = new ctor(data[i]);&quot;,&quot;    }&quot;,&quot;    msg.wrappers_[fieldNumber] = wrappers;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets a proto field and syncs it to the backing array.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {?jspb.Message|?jspb.Map|undefined} value A new value for this proto&quot;,&quot; * field.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.setWrapperField = function(msg, fieldNumber, value) {&quot;,&quot;  if (!msg.wrappers_) {&quot;,&quot;    msg.wrappers_ = {};&quot;,&quot;  }&quot;,&quot;  var data = value ? value.toArray() : value;&quot;,&quot;  msg.wrappers_[fieldNumber] = value;&quot;,&quot;  jspb.Message.setField(msg, fieldNumber, data);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets a proto field in a oneof union and syncs it to the backing array.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {!Array&lt;number&gt;} oneof The fields belonging to the union.&quot;,&quot; * @param {jspb.Message|undefined} value A new value for this proto field.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.setOneofWrapperField = function(msg, fieldNumber, oneof, value) {&quot;,&quot;  if (!msg.wrappers_) {&quot;,&quot;    msg.wrappers_ = {};&quot;,&quot;  }&quot;,&quot;  var data = value ? value.toArray() : value;&quot;,&quot;  msg.wrappers_[fieldNumber] = value;&quot;,&quot;  jspb.Message.setOneofField(msg, fieldNumber, oneof, data);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets a repeated proto field and syncs it to the backing array.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {Array&lt;!jspb.Message&gt;|undefined} value An array of protos.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.setRepeatedWrapperField = function(msg, fieldNumber, value) {&quot;,&quot;  if (!msg.wrappers_) {&quot;,&quot;    msg.wrappers_ = {};&quot;,&quot;  }&quot;,&quot;  value = value || [];&quot;,&quot;  for (var data = [], i = 0; i &lt; value.length; i++) {&quot;,&quot;    data[i] = value[i].toArray();&quot;,&quot;  }&quot;,&quot;  msg.wrappers_[fieldNumber] = value;&quot;,&quot;  jspb.Message.setField(msg, fieldNumber, data);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Add a message to a repeated proto field.&quot;,&quot; * @param {!jspb.Message} msg A jspb proto.&quot;,&quot; * @param {number} fieldNumber The field number.&quot;,&quot; * @param {T_CHILD|undefined} value Proto that will be added to the&quot;,&quot; *     repeated field.&quot;,&quot; * @param {function(new:T_CHILD, ?Array=)} ctor The constructor of the&quot;,&quot; *     message type.&quot;,&quot; * @param {number|undefined} index Index at which to insert the value.&quot;,&quot; * @return {T_CHILD_NOT_UNDEFINED} proto that was inserted to the repeated field&quot;,&quot; * @template MessageType&quot;,&quot; * Use go/closure-ttl to declare a non-undefined version of T_CHILD. Replace the&quot;,&quot; * undefined in blah|undefined with none. This is necessary because the compiler&quot;,&quot; * will infer T_CHILD to be |undefined.&quot;,&quot; * @template T_CHILD&quot;,&quot; * @template T_CHILD_NOT_UNDEFINED :=&quot;,&quot; *     cond(isUnknown(T_CHILD), unknown(),&quot;,&quot; *       mapunion(T_CHILD, (X) =&gt;&quot;,&quot; *         cond(eq(X, &#39;undefined&#39;), none(), X)))&quot;,&quot; * =:&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.addToRepeatedWrapperField = function(&quot;,&quot;    msg, fieldNumber, value, ctor, index) {&quot;,&quot;  jspb.Message.wrapRepeatedField_(msg, ctor, fieldNumber);&quot;,&quot;  var wrapperArray = msg.wrappers_[fieldNumber];&quot;,&quot;  if (!wrapperArray) {&quot;,&quot;    wrapperArray = msg.wrappers_[fieldNumber] = [];&quot;,&quot;  }&quot;,&quot;  var insertedValue = value ? value : new ctor();&quot;,&quot;  var array = jspb.Message.getRepeatedField(msg, fieldNumber);&quot;,&quot;  if (index != undefined) {&quot;,&quot;    wrapperArray.splice(index, 0, insertedValue);&quot;,&quot;    array.splice(index, 0, insertedValue.toArray());&quot;,&quot;  } else {&quot;,&quot;    wrapperArray.push(insertedValue);&quot;,&quot;    array.push(insertedValue.toArray());&quot;,&quot;  }&quot;,&quot;  return insertedValue;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a JsPb repeated message field into a map. The map will contain&quot;,&quot; * protos unless an optional toObject function is given, in which case it will&quot;,&quot; * contain objects suitable for Soy rendering.&quot;,&quot; * @param {!Array&lt;T&gt;} field The repeated message field to be&quot;,&quot; *     converted.&quot;,&quot; * @param {function() : string?} mapKeyGetterFn The function to get the key of&quot;,&quot; *     the map.&quot;,&quot; * @param {?function(boolean=): Object|&quot;,&quot; *     function((boolean|undefined),T): Object} opt_toObjectFn The&quot;,&quot; *     toObject function for this field. We need to pass this for effective&quot;,&quot; *     dead code removal.&quot;,&quot; * @param {boolean=} opt_includeInstance Whether to include the JSPB instance&quot;,&quot; *     for transitional soy proto support: http://goto/soy-param-migration&quot;,&quot; * @return {!Object&lt;string, Object&gt;} A map of proto or Soy objects.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;jspb.Message.toMap = function(&quot;,&quot;    field, mapKeyGetterFn, opt_toObjectFn, opt_includeInstance) {&quot;,&quot;  var result = {};&quot;,&quot;  for (var i = 0; i &lt; field.length; i++) {&quot;,&quot;    result[mapKeyGetterFn.call(field[i])] = opt_toObjectFn ?&quot;,&quot;        opt_toObjectFn.call(field[i], opt_includeInstance,&quot;,&quot;            /** @type {!jspb.Message} */ (field[i])) : field[i];&quot;,&quot;  }&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Syncs all map fields&#39; contents back to their underlying arrays.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.syncMapFields_ = function() {&quot;,&quot;  // This iterates over submessage, map, and repeated fields, which is intended.&quot;,&quot;  // Submessages can contain maps which also need to be synced.&quot;,&quot;  //&quot;,&quot;  // There is a lot of opportunity for optimization here.  For example we could&quot;,&quot;  // statically determine that some messages have no submessages with maps and&quot;,&quot;  // optimize this method away for those just by generating one extra static&quot;,&quot;  // boolean per message type.&quot;,&quot;  if (this.wrappers_) {&quot;,&quot;    for (var fieldNumber in this.wrappers_) {&quot;,&quot;      var val = this.wrappers_[fieldNumber];&quot;,&quot;      if (goog.isArray(val)) {&quot;,&quot;        for (var i = 0; i &lt; val.length; i++) {&quot;,&quot;          if (val[i]) {&quot;,&quot;            val[i].toArray();&quot;,&quot;          }&quot;,&quot;        }&quot;,&quot;      } else {&quot;,&quot;        // Works for submessages and maps.&quot;,&quot;        if (val) {&quot;,&quot;          val.toArray();&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the internal array of this proto.&quot;,&quot; * &lt;p&gt;Note: If you use this array to construct a second proto, the content&quot;,&quot; * would then be partially shared between the two protos.&quot;,&quot; * @return {!Array} The proto represented as an array.&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.toArray = function() {&quot;,&quot;  this.syncMapFields_();&quot;,&quot;  return this.array;&quot;,&quot;};&quot;,null,null,null,&quot;if (jspb.Message.GENERATE_TO_STRING) {&quot;,null,&quot;/**&quot;,&quot; * Creates a string representation of the internal data array of this proto.&quot;,&quot; * &lt;p&gt;NOTE: This string is *not* suitable for use in server requests.&quot;,&quot; * @return {string} A string representation of this proto.&quot;,&quot; * @override&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.toString = function() {&quot;,&quot;  this.syncMapFields_();&quot;,&quot;  return this.array.toString();&quot;,&quot;};&quot;,null,&quot;}&quot;,null,&quot;/**&quot;,&quot; * Gets the value of the extension field from the extended object.&quot;,&quot; * @param {jspb.ExtensionFieldInfo&lt;T&gt;} fieldInfo Specifies the field to get.&quot;,&quot; * @return {T} The value of the field.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.getExtension = function(fieldInfo) {&quot;,&quot;  if (!this.extensionObject_) {&quot;,&quot;    return undefined;&quot;,&quot;  }&quot;,&quot;  if (!this.wrappers_) {&quot;,&quot;    this.wrappers_ = {};&quot;,&quot;  }&quot;,&quot;  var fieldNumber = fieldInfo.fieldIndex;&quot;,&quot;  if (fieldInfo.isRepeated) {&quot;,&quot;    if (fieldInfo.isMessageType()) {&quot;,&quot;      if (!this.wrappers_[fieldNumber]) {&quot;,&quot;        this.wrappers_[fieldNumber] =&quot;,&quot;            goog.array.map(this.extensionObject_[fieldNumber] || [],&quot;,&quot;                function(arr) {&quot;,&quot;                  return new fieldInfo.ctor(arr);&quot;,&quot;                });&quot;,&quot;      }&quot;,&quot;      return this.wrappers_[fieldNumber];&quot;,&quot;    } else {&quot;,&quot;      return this.extensionObject_[fieldNumber];&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    if (fieldInfo.isMessageType()) {&quot;,&quot;      if (!this.wrappers_[fieldNumber] &amp;&amp; this.extensionObject_[fieldNumber]) {&quot;,&quot;        this.wrappers_[fieldNumber] = new fieldInfo.ctor(&quot;,&quot;            /** @type {Array|undefined} */ (&quot;,&quot;                this.extensionObject_[fieldNumber]));&quot;,&quot;      }&quot;,&quot;      return this.wrappers_[fieldNumber];&quot;,&quot;    } else {&quot;,&quot;      return this.extensionObject_[fieldNumber];&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the value of the extension field in the extended object.&quot;,&quot; * @param {jspb.ExtensionFieldInfo} fieldInfo Specifies the field to set.&quot;,&quot; * @param {jspb.Message|string|Uint8Array|number|boolean|Array?} value The value&quot;,&quot; *     to set.&quot;,&quot; * @return {THIS} For chaining&quot;,&quot; * @this {THIS}&quot;,&quot; * @template THIS&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.setExtension = function(fieldInfo, value) {&quot;,&quot;  // Cast self, since the inferred THIS is unknown inside the function body.&quot;,&quot;  // https://github.com/google/closure-compiler/issues/1411#issuecomment-232442220&quot;,&quot;  var self = /** @type {!jspb.Message} */ (this);&quot;,&quot;  if (!self.wrappers_) {&quot;,&quot;    self.wrappers_ = {};&quot;,&quot;  }&quot;,&quot;  jspb.Message.maybeInitEmptyExtensionObject_(self);&quot;,&quot;  var fieldNumber = fieldInfo.fieldIndex;&quot;,&quot;  if (fieldInfo.isRepeated) {&quot;,&quot;    value = value || [];&quot;,&quot;    if (fieldInfo.isMessageType()) {&quot;,&quot;      self.wrappers_[fieldNumber] = value;&quot;,&quot;      self.extensionObject_[fieldNumber] = goog.array.map(&quot;,&quot;          /** @type {Array&lt;jspb.Message&gt;} */ (value), function(msg) {&quot;,&quot;        return msg.toArray();&quot;,&quot;      });&quot;,&quot;    } else {&quot;,&quot;      self.extensionObject_[fieldNumber] = value;&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    if (fieldInfo.isMessageType()) {&quot;,&quot;      self.wrappers_[fieldNumber] = value;&quot;,&quot;      self.extensionObject_[fieldNumber] = value ? value.toArray() : value;&quot;,&quot;    } else {&quot;,&quot;      self.extensionObject_[fieldNumber] = value;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return self;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a difference object between two messages.&quot;,&quot; *&quot;,&quot; * The result will contain the top-level fields of m2 that differ from those of&quot;,&quot; * m1 at any level of nesting. No data is cloned, the result object will&quot;,&quot; * share its top-level elements with m2 (but not with m1).&quot;,&quot; *&quot;,&quot; * Note that repeated fields should not have null/undefined elements, but if&quot;,&quot; * they do, this operation will treat repeated fields of different length as&quot;,&quot; * the same if the only difference between them is due to trailing&quot;,&quot; * null/undefined values.&quot;,&quot; *&quot;,&quot; * @param {!jspb.Message} m1 The first message object.&quot;,&quot; * @param {!jspb.Message} m2 The second message object.&quot;,&quot; * @return {!jspb.Message} The difference returned as a proto message.&quot;,&quot; *     Note that the returned message may be missing required fields. This is&quot;,&quot; *     currently tolerated in Js, but would cause an error if you tried to&quot;,&quot; *     send such a proto to the server. You can access the raw difference&quot;,&quot; *     array with result.toArray().&quot;,&quot; * @throws {Error} If the messages are responses with different types.&quot;,&quot; */&quot;,&quot;jspb.Message.difference = function(m1, m2) {&quot;,&quot;  if (!(m1 instanceof m2.constructor)) {&quot;,&quot;    throw new Error(&#39;Messages have different types.&#39;);&quot;,&quot;  }&quot;,&quot;  var arr1 = m1.toArray();&quot;,&quot;  var arr2 = m2.toArray();&quot;,&quot;  var res = [];&quot;,&quot;  var start = 0;&quot;,&quot;  var length = arr1.length &gt; arr2.length ? arr1.length : arr2.length;&quot;,&quot;  if (m1.getJsPbMessageId()) {&quot;,&quot;    res[0] = m1.getJsPbMessageId();&quot;,&quot;    start = 1;&quot;,&quot;  }&quot;,&quot;  for (var i = start; i &lt; length; i++) {&quot;,&quot;    if (!jspb.Message.compareFields(arr1[i], arr2[i])) {&quot;,&quot;      res[i] = arr2[i];&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return new m1.constructor(res);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Tests whether two messages are equal.&quot;,&quot; * @param {jspb.Message|undefined} m1 The first message object.&quot;,&quot; * @param {jspb.Message|undefined} m2 The second message object.&quot;,&quot; * @return {boolean} true if both messages are null/undefined, or if both are&quot;,&quot; *     of the same type and have the same field values.&quot;,&quot; */&quot;,&quot;jspb.Message.equals = function(m1, m2) {&quot;,&quot;  return m1 == m2 || (!!(m1 &amp;&amp; m2) &amp;&amp; (m1 instanceof m2.constructor) &amp;&amp;&quot;,&quot;      jspb.Message.compareFields(m1.toArray(), m2.toArray()));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Compares two message extension fields recursively.&quot;,&quot; * @param {!Object} extension1 The first field.&quot;,&quot; * @param {!Object} extension2 The second field.&quot;,&quot; * @return {boolean} true if the extensions are null/undefined, or otherwise&quot;,&quot; *     equal.&quot;,&quot; */&quot;,&quot;jspb.Message.compareExtensions = function(extension1, extension2) {&quot;,&quot;  extension1 = extension1 || {};&quot;,&quot;  extension2 = extension2 || {};&quot;,null,&quot;  var keys = {};&quot;,&quot;  for (var name in extension1) {&quot;,&quot;    keys[name] = 0;&quot;,&quot;  }&quot;,&quot;  for (var name in extension2) {&quot;,&quot;    keys[name] = 0;&quot;,&quot;  }&quot;,&quot;  for (name in keys) {&quot;,&quot;    if (!jspb.Message.compareFields(extension1[name], extension2[name])) {&quot;,&quot;      return false;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return true;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Compares two message fields recursively.&quot;,&quot; * @param {*} field1 The first field.&quot;,&quot; * @param {*} field2 The second field.&quot;,&quot; * @return {boolean} true if the fields are null/undefined, or otherwise equal.&quot;,&quot; */&quot;,&quot;jspb.Message.compareFields = function(field1, field2) {&quot;,&quot;  // If the fields are trivially equal, they&#39;re equal.&quot;,&quot;  if (field1 == field2) return true;&quot;,null,&quot;  // If the fields aren&#39;t trivially equal and one of them isn&#39;t an object,&quot;,&quot;  // they can&#39;t possibly be equal.&quot;,&quot;  if (!goog.isObject(field1) || !goog.isObject(field2)) {&quot;,&quot;    return false;&quot;,&quot;  }&quot;,null,&quot;  // We have two objects. If they&#39;re different types, they&#39;re not equal.&quot;,&quot;  field1 = /** @type {!Object} */(field1);&quot;,&quot;  field2 = /** @type {!Object} */(field2);&quot;,&quot;  if (field1.constructor != field2.constructor) return false;&quot;,null,&quot;  // If both are Uint8Arrays, compare them element-by-element.&quot;,&quot;  if (jspb.Message.SUPPORTS_UINT8ARRAY_ &amp;&amp; field1.constructor === Uint8Array) {&quot;,&quot;    var bytes1 = /** @type {!Uint8Array} */(field1);&quot;,&quot;    var bytes2 = /** @type {!Uint8Array} */(field2);&quot;,&quot;    if (bytes1.length != bytes2.length) return false;&quot;,&quot;    for (var i = 0; i &lt; bytes1.length; i++) {&quot;,&quot;      if (bytes1[i] != bytes2[i]) return false;&quot;,&quot;    }&quot;,&quot;    return true;&quot;,&quot;  }&quot;,null,&quot;  // If they&#39;re both Arrays, compare them element by element except for the&quot;,&quot;  // optional extension objects at the end, which we compare separately.&quot;,&quot;  if (field1.constructor === Array) {&quot;,&quot;    var extension1 = undefined;&quot;,&quot;    var extension2 = undefined;&quot;,null,&quot;    var length = Math.max(field1.length, field2.length);&quot;,&quot;    for (var i = 0; i &lt; length; i++) {&quot;,&quot;      var val1 = field1[i];&quot;,&quot;      var val2 = field2[i];&quot;,null,&quot;      if (val1 &amp;&amp; (val1.constructor == Object)) {&quot;,&quot;        goog.asserts.assert(extension1 === undefined);&quot;,&quot;        goog.asserts.assert(i === field1.length - 1);&quot;,&quot;        extension1 = val1;&quot;,&quot;        val1 = undefined;&quot;,&quot;      }&quot;,null,&quot;      if (val2 &amp;&amp; (val2.constructor == Object)) {&quot;,&quot;        goog.asserts.assert(extension2 === undefined);&quot;,&quot;        goog.asserts.assert(i === field2.length - 1);&quot;,&quot;        extension2 = val2;&quot;,&quot;        val2 = undefined;&quot;,&quot;      }&quot;,null,&quot;      if (!jspb.Message.compareFields(val1, val2)) {&quot;,&quot;        return false;&quot;,&quot;      }&quot;,&quot;    }&quot;,null,&quot;    if (extension1 || extension2) {&quot;,&quot;      extension1 = extension1 || {};&quot;,&quot;      extension2 = extension2 || {};&quot;,&quot;      return jspb.Message.compareExtensions(extension1, extension2);&quot;,&quot;    }&quot;,null,&quot;    return true;&quot;,&quot;  }&quot;,null,&quot;  // If they&#39;re both plain Objects (i.e. extensions), compare them as&quot;,&quot;  // extensions.&quot;,&quot;  if (field1.constructor === Object) {&quot;,&quot;    return jspb.Message.compareExtensions(field1, field2);&quot;,&quot;  }&quot;,null,&quot;  throw new Error(&#39;Invalid type in JSPB array&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Templated, type-safe cloneMessage definition.&quot;,&quot; * @return {THIS}&quot;,&quot; * @this {THIS}&quot;,&quot; * @template THIS&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.cloneMessage = function() {&quot;,&quot;  return jspb.Message.cloneMessage(/** @type {!jspb.Message} */ (this));&quot;,&quot;};&quot;,null,&quot;/**&quot;,&quot; * Alias clone to cloneMessage. goog.object.unsafeClone uses clone to&quot;,&quot; * efficiently copy objects. Without this alias, copying jspb messages comes&quot;,&quot; * with a large performance penalty.&quot;,&quot; * @return {THIS}&quot;,&quot; * @this {THIS}&quot;,&quot; * @template THIS&quot;,&quot; */&quot;,&quot;jspb.Message.prototype.clone = function() {&quot;,&quot;  return jspb.Message.cloneMessage(/** @type {!jspb.Message} */ (this));&quot;,&quot;};&quot;,null,&quot;/**&quot;,&quot; * Static clone function. NOTE: A type-safe method called \&quot;cloneMessage\&quot;&quot;,&quot; * exists&quot;,&quot; * on each generated JsPb class. Do not call this function directly.&quot;,&quot; * @param {!jspb.Message} msg A message to clone.&quot;,&quot; * @return {!jspb.Message} A deep clone of the given message.&quot;,&quot; */&quot;,&quot;jspb.Message.clone = function(msg) {&quot;,&quot;  // Although we could include the wrappers, we leave them out here.&quot;,&quot;  return jspb.Message.cloneMessage(msg);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {!jspb.Message} msg A message to clone.&quot;,&quot; * @return {!jspb.Message} A deep clone of the given message.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;jspb.Message.cloneMessage = function(msg) {&quot;,&quot;  // Although we could include the wrappers, we leave them out here.&quot;,&quot;  return new msg.constructor(jspb.Message.clone_(msg.toArray()));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Takes 2 messages of the same type and copies the contents of the first&quot;,&quot; * message into the second. After this the 2 messages will equals in terms of&quot;,&quot; * value semantics but share no state. All data in the destination message will&quot;,&quot; * be overridden.&quot;,&quot; *&quot;,&quot; * @param {MESSAGE} fromMessage Message that will be copied into toMessage.&quot;,&quot; * @param {MESSAGE} toMessage Message which will receive a copy of fromMessage&quot;,&quot; *     as its contents.&quot;,&quot; * @template MESSAGE&quot;,&quot; */&quot;,&quot;jspb.Message.copyInto = function(fromMessage, toMessage) {&quot;,&quot;  goog.asserts.assertInstanceof(fromMessage, jspb.Message);&quot;,&quot;  goog.asserts.assertInstanceof(toMessage, jspb.Message);&quot;,&quot;  goog.asserts.assert(fromMessage.constructor == toMessage.constructor,&quot;,&quot;      &#39;Copy source and target message should have the same type.&#39;);&quot;,&quot;  var copyOfFrom = jspb.Message.clone(fromMessage);&quot;,null,&quot;  var to = toMessage.toArray();&quot;,&quot;  var from = copyOfFrom.toArray();&quot;,null,&quot;  // Empty destination in case it has more values at the end of the array.&quot;,&quot;  to.length = 0;&quot;,&quot;  // and then copy everything from the new to the existing message.&quot;,&quot;  for (var i = 0; i &lt; from.length; i++) {&quot;,&quot;    to[i] = from[i];&quot;,&quot;  }&quot;,null,&quot;  // This is either null or empty for a fresh copy.&quot;,&quot;  toMessage.wrappers_ = copyOfFrom.wrappers_;&quot;,&quot;  // Just a reference into the shared array.&quot;,&quot;  toMessage.extensionObject_ = copyOfFrom.extensionObject_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Helper for cloning an internal JsPb object.&quot;,&quot; * @param {!Object} obj A JsPb object, eg, a field, to be cloned.&quot;,&quot; * @return {!Object} A clone of the input object.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.clone_ = function(obj) {&quot;,&quot;  var o;&quot;,&quot;  if (goog.isArray(obj)) {&quot;,&quot;    // Allocate array of correct size.&quot;,&quot;    var clonedArray = new Array(obj.length);&quot;,&quot;    // Use array iteration where possible because it is faster than for-in.&quot;,&quot;    for (var i = 0; i &lt; obj.length; i++) {&quot;,&quot;      if ((o = obj[i]) != null) {&quot;,&quot;        clonedArray[i] = typeof o == &#39;object&#39; ? jspb.Message.clone_(o) : o;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    return clonedArray;&quot;,&quot;  }&quot;,&quot;  if (jspb.Message.SUPPORTS_UINT8ARRAY_ &amp;&amp; obj instanceof Uint8Array) {&quot;,&quot;    return new Uint8Array(obj);&quot;,&quot;  }&quot;,&quot;  var clone = {};&quot;,&quot;  for (var key in obj) {&quot;,&quot;    if ((o = obj[key]) != null) {&quot;,&quot;      clone[key] = typeof o == &#39;object&#39; ? jspb.Message.clone_(o) : o;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return clone;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Registers a JsPb message type id with its constructor.&quot;,&quot; * @param {string} id The id for this type of message.&quot;,&quot; * @param {Function} constructor The message constructor.&quot;,&quot; */&quot;,&quot;jspb.Message.registerMessageType = function(id, constructor) {&quot;,&quot;  jspb.Message.registry_[id] = constructor;&quot;,&quot;  // This is needed so we can later access messageId directly on the contructor,&quot;,&quot;  // otherwise it is not available due to &#39;property collapsing&#39; by the compiler.&quot;,&quot;  constructor.messageId = id;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * The registry of message ids to message constructors.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Message.registry_ = {};&quot;,null,null,&quot;/**&quot;,&quot; * The extensions registered on MessageSet. This is a map of extension&quot;,&quot; * field number to field info object. This should be considered as a&quot;,&quot; * private API.&quot;,&quot; *&quot;,&quot; * This is similar to [jspb class name].extensions object for&quot;,&quot; * non-MessageSet. We special case MessageSet so that we do not need&quot;,&quot; * to goog.require MessageSet from classes that extends MessageSet.&quot;,&quot; *&quot;,&quot; * @type {!Object&lt;number, jspb.ExtensionFieldInfo&gt;}&quot;,&quot; */&quot;,&quot;jspb.Message.messageSetExtensions = {};&quot;,null,&quot;/**&quot;,&quot; * @type {!Object&lt;number, jspb.ExtensionFieldBinaryInfo&gt;}&quot;,&quot; */&quot;,&quot;jspb.Message.messageSetExtensionsBinary = {};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../dossier.js" defer></script>