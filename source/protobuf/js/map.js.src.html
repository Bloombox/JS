<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>map.js</title><link href="../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;map.js&quot;,&quot;protobuf/js/map.js&quot;,[&quot;// Protocol Buffers - Google&#39;s data interchange format&quot;,&quot;// Copyright 2008 Google Inc.  All rights reserved.&quot;,&quot;// https://developers.google.com/protocol-buffers/&quot;,&quot;//&quot;,&quot;// Redistribution and use in source and binary forms, with or without&quot;,&quot;// modification, are permitted provided that the following conditions are&quot;,&quot;// met:&quot;,&quot;//&quot;,&quot;//     * Redistributions of source code must retain the above copyright&quot;,&quot;// notice, this list of conditions and the following disclaimer.&quot;,&quot;//     * Redistributions in binary form must reproduce the above&quot;,&quot;// copyright notice, this list of conditions and the following disclaimer&quot;,&quot;// in the documentation and/or other materials provided with the&quot;,&quot;// distribution.&quot;,&quot;//     * Neither the name of Google Inc. nor the names of its&quot;,&quot;// contributors may be used to endorse or promote products derived from&quot;,&quot;// this software without specific prior written permission.&quot;,&quot;//&quot;,&quot;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS&quot;,&quot;// \&quot;AS IS\&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR&quot;,&quot;// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT&quot;,&quot;// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,&quot;,&quot;// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT&quot;,&quot;// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,&quot;,&quot;// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY&quot;,&quot;// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT&quot;,&quot;// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE&quot;,&quot;// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&quot;,null,&quot;goog.provide(&#39;jspb.Map&#39;);&quot;,null,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,null,&quot;goog.forwardDeclare(&#39;jspb.BinaryReader&#39;);&quot;,&quot;goog.forwardDeclare(&#39;jspb.BinaryWriter&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * Constructs a new Map. A Map is a container that is used to implement map&quot;,&quot; * fields on message objects. It closely follows the ES6 Map API; however,&quot;,&quot; * it is distinct because we do not want to depend on external polyfills or&quot;,&quot; * on ES6 itself.&quot;,&quot; *&quot;,&quot; * This constructor should only be called from generated message code. It is not&quot;,&quot; * intended for general use by library consumers.&quot;,&quot; *&quot;,&quot; * @template K, V&quot;,&quot; *&quot;,&quot; * @param {!Array&lt;!Array&lt;!Object&gt;&gt;} arr&quot;,&quot; *&quot;,&quot; * @param {?function(new:V)|function(new:V,?)=} opt_valueCtor&quot;,&quot; *    The constructor for type V, if type V is a message type.&quot;,&quot; *&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; */&quot;,&quot;jspb.Map = function(arr, opt_valueCtor) {&quot;,&quot;  /** @const @private */&quot;,&quot;  this.arr_ = arr;&quot;,&quot;  /** @const @private */&quot;,&quot;  this.valueCtor_ = opt_valueCtor;&quot;,null,&quot;  /** @type {!Object&lt;string, !jspb.Map.Entry_&lt;K,V&gt;&gt;} @private */&quot;,&quot;  this.map_ = {};&quot;,null,&quot;  /**&quot;,&quot;   * Is `this.arr_ updated with respect to `this.map_`?&quot;,&quot;   * @type {boolean}&quot;,&quot;   */&quot;,&quot;  this.arrClean = true;&quot;,null,&quot;  if (this.arr_.length &gt; 0) {&quot;,&quot;    this.loadFromArray_();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Load initial content from underlying array.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.loadFromArray_ = function() {&quot;,&quot;  for (var i = 0; i &lt; this.arr_.length; i++) {&quot;,&quot;    var record = this.arr_[i];&quot;,&quot;    var key = record[0];&quot;,&quot;    var value = record[1];&quot;,&quot;    this.map_[key.toString()] = new jspb.Map.Entry_(key, value);&quot;,&quot;  }&quot;,&quot;  this.arrClean = true;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Synchronize content to underlying array, if needed, and return it.&quot;,&quot; * @return {!Array&lt;!Array&lt;!Object&gt;&gt;}&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.toArray = function() {&quot;,&quot;  if (this.arrClean) {&quot;,&quot;    if (this.valueCtor_) {&quot;,&quot;      // We need to recursively sync maps in submessages to their arrays.&quot;,&quot;      var m = this.map_;&quot;,&quot;      for (var p in m) {&quot;,&quot;        if (Object.prototype.hasOwnProperty.call(m, p)) {&quot;,&quot;          var valueWrapper = /** @type {?jspb.Message} */ (m[p].valueWrapper);&quot;,&quot;          if (valueWrapper) {&quot;,&quot;            valueWrapper.toArray();&quot;,&quot;          }&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    // Delete all elements.&quot;,&quot;    this.arr_.length = 0;&quot;,&quot;    var strKeys = this.stringKeys_();&quot;,&quot;    // Output keys in deterministic (sorted) order.&quot;,&quot;    strKeys.sort();&quot;,&quot;    for (var i = 0; i &lt; strKeys.length; i++) {&quot;,&quot;      var entry = this.map_[strKeys[i]];&quot;,&quot;      var valueWrapper = /** @type {!Object} */ (entry.valueWrapper);&quot;,&quot;      if (valueWrapper) {&quot;,&quot;        valueWrapper.toArray();&quot;,&quot;      }&quot;,&quot;      this.arr_.push([entry.key, entry.value]);&quot;,&quot;    }&quot;,&quot;    this.arrClean = true;&quot;,&quot;  }&quot;,&quot;  return this.arr_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the map formatted as an array of key-value pairs, suitable for the&quot;,&quot; * toObject() form of a message.&quot;,&quot; *&quot;,&quot; * @param {boolean=} includeInstance Whether to include the JSPB instance for&quot;,&quot; *    transitional soy proto support: http://goto/soy-param-migration&quot;,&quot; * @param {!function((boolean|undefined),V):!Object=} valueToObject&quot;,&quot; *    The static toObject() method, if V is a message type.&quot;,&quot; * @return {!Array&lt;!Array&lt;!Object&gt;&gt;}&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.toObject = function(includeInstance, valueToObject) {&quot;,&quot;  var rawArray = this.toArray();&quot;,&quot;  var entries = [];&quot;,&quot;  for (var i = 0; i &lt; rawArray.length; i++) {&quot;,&quot;    var entry = this.map_[rawArray[i][0].toString()];&quot;,&quot;    this.wrapEntry_(entry);&quot;,&quot;    var valueWrapper = /** @type {V|undefined} */ (entry.valueWrapper);&quot;,&quot;    if (valueWrapper) {&quot;,&quot;      goog.asserts.assert(valueToObject);&quot;,&quot;      entries.push([entry.key, valueToObject(includeInstance, valueWrapper)]);&quot;,&quot;    } else {&quot;,&quot;      entries.push([entry.key, entry.value]);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return entries;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns a Map from the given array of key-value pairs when the values are of&quot;,&quot; * message type. The values in the array must match the format returned by their&quot;,&quot; * message type&#39;s toObject() method.&quot;,&quot; *&quot;,&quot; * @template K, V&quot;,&quot; * @param {!Array&lt;!Array&lt;!Object&gt;&gt;} entries&quot;,&quot; * @param {!function(new:V)|function(new:V,?)} valueCtor&quot;,&quot; *    The constructor for type V.&quot;,&quot; * @param {!function(!Object):V} valueFromObject&quot;,&quot; *    The fromObject function for type V.&quot;,&quot; * @return {!jspb.Map&lt;K, V&gt;}&quot;,&quot; */&quot;,&quot;jspb.Map.fromObject = function(entries, valueCtor, valueFromObject) {&quot;,&quot;  var result = new jspb.Map([], valueCtor);&quot;,&quot;  for (var i = 0; i &lt; entries.length; i++) {&quot;,&quot;    var key = entries[i][0];&quot;,&quot;    var value = valueFromObject(entries[i][1]);&quot;,&quot;    result.set(key, value);&quot;,&quot;  }&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Helper: an IteratorIterable over an array.&quot;,&quot; * @template T&quot;,&quot; * @param {!Array&lt;T&gt;} arr the array&quot;,&quot; * @implements {IteratorIterable&lt;T&gt;}&quot;,&quot; * @constructor @struct&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Map.ArrayIteratorIterable_ = function(arr) {&quot;,&quot;  /** @type {number} @private */&quot;,&quot;  this.idx_ = 0;&quot;,null,&quot;  /** @const @private */&quot;,&quot;  this.arr_ = arr;&quot;,&quot;};&quot;,null,null,&quot;/** @override @final */&quot;,&quot;jspb.Map.ArrayIteratorIterable_.prototype.next = function() {&quot;,&quot;  if (this.idx_ &lt; this.arr_.length) {&quot;,&quot;    return {done: false, value: this.arr_[this.idx_++]};&quot;,&quot;  } else {&quot;,&quot;    return {done: true, value: undefined};&quot;,&quot;  }&quot;,&quot;};&quot;,null,&quot;if (typeof(Symbol) != &#39;undefined&#39;) {&quot;,&quot;  /** @override */&quot;,&quot;  jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator] = function() {&quot;,&quot;    return this;&quot;,&quot;  };&quot;,&quot;}&quot;,null,null,&quot;/**&quot;,&quot; * Returns the map&#39;s length (number of key/value pairs).&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.getLength = function() {&quot;,&quot;  return this.stringKeys_().length;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Clears the map.&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.clear = function() {&quot;,&quot;  this.map_ = {};&quot;,&quot;  this.arrClean = false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Deletes a particular key from the map.&quot;,&quot; * N.B.: differs in name from ES6 Map&#39;s `delete` because IE8 does not support&quot;,&quot; * reserved words as property names.&quot;,&quot; * @this {jspb.Map}&quot;,&quot; * @param {K} key&quot;,&quot; * @return {boolean} Whether any entry with this key was deleted.&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.del = function(key) {&quot;,&quot;  var keyValue = key.toString();&quot;,&quot;  var hadKey = this.map_.hasOwnProperty(keyValue);&quot;,&quot;  delete this.map_[keyValue];&quot;,&quot;  this.arrClean = false;&quot;,&quot;  return hadKey;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns an array of [key, value] pairs in the map.&quot;,&quot; *&quot;,&quot; * This is redundant compared to the plain entries() method, but we provide this&quot;,&quot; * to help out Angular 1.x users.  Still evaluating whether this is the best&quot;,&quot; * option.&quot;,&quot; *&quot;,&quot; * @return {!Array&lt;!Array&lt;K|V&gt;&gt;}&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.getEntryList = function() {&quot;,&quot;  var entries = [];&quot;,&quot;  var strKeys = this.stringKeys_();&quot;,&quot;  strKeys.sort();&quot;,&quot;  for (var i = 0; i &lt; strKeys.length; i++) {&quot;,&quot;    var entry = this.map_[strKeys[i]];&quot;,&quot;    entries.push([entry.key, entry.value]);&quot;,&quot;  }&quot;,&quot;  return entries;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns an iterator-iterable over [key, value] pairs in the map.&quot;,&quot; * Closure compiler sadly doesn&#39;t support tuples, ie. Iterator&lt;[K,V]&gt;.&quot;,&quot; * @return {!IteratorIterable&lt;!Array&lt;K|V&gt;&gt;} The iterator-iterable.&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.entries = function() {&quot;,&quot;  var entries = [];&quot;,&quot;  var strKeys = this.stringKeys_();&quot;,&quot;  strKeys.sort();&quot;,&quot;  for (var i = 0; i &lt; strKeys.length; i++) {&quot;,&quot;    var entry = this.map_[strKeys[i]];&quot;,&quot;    entries.push([entry.key, this.wrapEntry_(entry)]);&quot;,&quot;  }&quot;,&quot;  return new jspb.Map.ArrayIteratorIterable_(entries);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns an iterator-iterable over keys in the map.&quot;,&quot; * @return {!IteratorIterable&lt;K&gt;} The iterator-iterable.&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.keys = function() {&quot;,&quot;  var keys = [];&quot;,&quot;  var strKeys = this.stringKeys_();&quot;,&quot;  strKeys.sort();&quot;,&quot;  for (var i = 0; i &lt; strKeys.length; i++) {&quot;,&quot;    var entry = this.map_[strKeys[i]];&quot;,&quot;    keys.push(entry.key);&quot;,&quot;  }&quot;,&quot;  return new jspb.Map.ArrayIteratorIterable_(keys);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns an iterator-iterable over values in the map.&quot;,&quot; * @return {!IteratorIterable&lt;V&gt;} The iterator-iterable.&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.values = function() {&quot;,&quot;  var values = [];&quot;,&quot;  var strKeys = this.stringKeys_();&quot;,&quot;  strKeys.sort();&quot;,&quot;  for (var i = 0; i &lt; strKeys.length; i++) {&quot;,&quot;    var entry = this.map_[strKeys[i]];&quot;,&quot;    values.push(this.wrapEntry_(entry));&quot;,&quot;  }&quot;,&quot;  return new jspb.Map.ArrayIteratorIterable_(values);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Iterates over entries in the map, calling a function on each.&quot;,&quot; * @template T&quot;,&quot; * @param {function(this:T, V, K, ?jspb.Map&lt;K, V&gt;)} cb&quot;,&quot; * @param {T=} opt_thisArg&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.forEach = function(cb, opt_thisArg) {&quot;,&quot;  var strKeys = this.stringKeys_();&quot;,&quot;  strKeys.sort();&quot;,&quot;  for (var i = 0; i &lt; strKeys.length; i++) {&quot;,&quot;    var entry = this.map_[strKeys[i]];&quot;,&quot;    cb.call(opt_thisArg, this.wrapEntry_(entry), entry.key, this);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets a key in the map to the given value.&quot;,&quot; * @param {K} key The key&quot;,&quot; * @param {V} value The value&quot;,&quot; * @return {!jspb.Map&lt;K,V&gt;}&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.set = function(key, value) {&quot;,&quot;  var entry = new jspb.Map.Entry_(key);&quot;,&quot;  if (this.valueCtor_) {&quot;,&quot;    entry.valueWrapper = value;&quot;,&quot;    // .toArray() on a message returns a reference to the underlying array&quot;,&quot;    // rather than a copy.&quot;,&quot;    entry.value = value.toArray();&quot;,&quot;  } else {&quot;,&quot;    entry.value = value;&quot;,&quot;  }&quot;,&quot;  this.map_[key.toString()] = entry;&quot;,&quot;  this.arrClean = false;&quot;,&quot;  return this;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Helper: lazily construct a wrapper around an entry, if needed, and return the&quot;,&quot; * user-visible type.&quot;,&quot; * @param {!jspb.Map.Entry_&lt;K,V&gt;} entry&quot;,&quot; * @return {V}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.wrapEntry_ = function(entry) {&quot;,&quot;  if (this.valueCtor_) {&quot;,&quot;    if (!entry.valueWrapper) {&quot;,&quot;      entry.valueWrapper = new this.valueCtor_(entry.value);&quot;,&quot;    }&quot;,&quot;    return /** @type {V} */ (entry.valueWrapper);&quot;,&quot;  } else {&quot;,&quot;    return entry.value;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the value corresponding to a key in the map.&quot;,&quot; * @param {K} key&quot;,&quot; * @return {V|undefined} The value, or `undefined` if key not present&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.get = function(key) {&quot;,&quot;  var keyValue = key.toString();&quot;,&quot;  var entry = this.map_[keyValue];&quot;,&quot;  if (entry) {&quot;,&quot;    return this.wrapEntry_(entry);&quot;,&quot;  } else {&quot;,&quot;    return undefined;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Determines whether the given key is present in the map.&quot;,&quot; * @param {K} key&quot;,&quot; * @return {boolean} `true` if the key is present&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.has = function(key) {&quot;,&quot;  var keyValue = key.toString();&quot;,&quot;  return (keyValue in this.map_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Write this Map field in wire format to a BinaryWriter, using the given field&quot;,&quot; * number.&quot;,&quot; * @param {number} fieldNumber&quot;,&quot; * @param {!jspb.BinaryWriter} writer&quot;,&quot; * @param {!function(this:jspb.BinaryWriter,number,K)} keyWriterFn&quot;,&quot; *     The method on BinaryWriter that writes type K to the stream.&quot;,&quot; * @param {!function(this:jspb.BinaryWriter,number,V,?=)|&quot;,&quot; *          function(this:jspb.BinaryWriter,number,V,?)} valueWriterFn&quot;,&quot; *     The method on BinaryWriter that writes type V to the stream.  May be&quot;,&quot; *     writeMessage, in which case the second callback arg form is used.&quot;,&quot; * @param {function(V,!jspb.BinaryWriter)=} opt_valueWriterCallback&quot;,&quot; *    The BinaryWriter serialization callback for type V, if V is a message&quot;,&quot; *    type.&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.serializeBinary = function(&quot;,&quot;    fieldNumber, writer, keyWriterFn, valueWriterFn, opt_valueWriterCallback) {&quot;,&quot;  var strKeys = this.stringKeys_();&quot;,&quot;  strKeys.sort();&quot;,&quot;  for (var i = 0; i &lt; strKeys.length; i++) {&quot;,&quot;    var entry = this.map_[strKeys[i]];&quot;,&quot;    writer.beginSubMessage(fieldNumber);&quot;,&quot;    keyWriterFn.call(writer, 1, entry.key);&quot;,&quot;    if (this.valueCtor_) {&quot;,&quot;      valueWriterFn.call(writer, 2, this.wrapEntry_(entry),&quot;,&quot;                         opt_valueWriterCallback);&quot;,&quot;    } else {&quot;,&quot;      valueWriterFn.call(writer, 2, entry.value);&quot;,&quot;    }&quot;,&quot;    writer.endSubMessage();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Read one key/value message from the given BinaryReader. Compatible as the&quot;,&quot; * `reader` callback parameter to jspb.BinaryReader.readMessage, to be called&quot;,&quot; * when a key/value pair submessage is encountered.&quot;,&quot; * @template K, V&quot;,&quot; * @param {!jspb.Map} map&quot;,&quot; * @param {!jspb.BinaryReader} reader&quot;,&quot; * @param {!function(this:jspb.BinaryReader):K} keyReaderFn&quot;,&quot; *     The method on BinaryReader that reads type K from the stream.&quot;,&quot; *&quot;,&quot; * @param {!function(this:jspb.BinaryReader):V|&quot;,&quot; *          function(this:jspb.BinaryReader,V,&quot;,&quot; *                  function(V,!jspb.BinaryReader))} valueReaderFn&quot;,&quot; *    The method on BinaryReader that reads type V from the stream. May be&quot;,&quot; *    readMessage, in which case the second callback arg form is used.&quot;,&quot; *&quot;,&quot; * @param {?function(V,!jspb.BinaryReader)=} opt_valueReaderCallback&quot;,&quot; *    The BinaryReader parsing callback for type V, if V is a message type.&quot;,&quot; *&quot;,&quot; */&quot;,&quot;jspb.Map.deserializeBinary = function(map, reader, keyReaderFn, valueReaderFn,&quot;,&quot;                                      opt_valueReaderCallback) {&quot;,&quot;  var key = undefined;&quot;,&quot;  var value = undefined;&quot;,null,&quot;  while (reader.nextField()) {&quot;,&quot;    if (reader.isEndGroup()) {&quot;,&quot;      break;&quot;,&quot;    }&quot;,&quot;    var field = reader.getFieldNumber();&quot;,&quot;    if (field == 1) {&quot;,&quot;      // Key.&quot;,&quot;      key = keyReaderFn.call(reader);&quot;,&quot;    } else if (field == 2) {&quot;,&quot;      // Value.&quot;,&quot;      if (map.valueCtor_) {&quot;,&quot;        value = new map.valueCtor_();&quot;,&quot;        valueReaderFn.call(reader, value, opt_valueReaderCallback);&quot;,&quot;      } else {&quot;,&quot;        value = valueReaderFn.call(reader);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  goog.asserts.assert(key != undefined);&quot;,&quot;  goog.asserts.assert(value != undefined);&quot;,&quot;  map.set(key, value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Helper: compute the list of all stringified keys in the underlying Object&quot;,&quot; * map.&quot;,&quot; * @return {!Array&lt;string&gt;}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Map.prototype.stringKeys_ = function() {&quot;,&quot;  var m = this.map_;&quot;,&quot;  var ret = [];&quot;,&quot;  for (var p in m) {&quot;,&quot;    if (Object.prototype.hasOwnProperty.call(m, p)) {&quot;,&quot;      ret.push(p);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return ret;&quot;,&quot;};&quot;,null,null,null,&quot;/**&quot;,&quot; * @param {K} key The entry&#39;s key.&quot;,&quot; * @param {V=} opt_value The entry&#39;s value wrapper.&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; * @template K, V&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;jspb.Map.Entry_ = function(key, opt_value) {&quot;,&quot;  /** @const {K} */&quot;,&quot;  this.key = key;&quot;,null,&quot;  // The JSPB-serializable value.  For primitive types this will be of type V.&quot;,&quot;  // For message types it will be an array.&quot;,&quot;  /** @type {V} */&quot;,&quot;  this.value = opt_value;&quot;,null,&quot;  // Only used for submessage values.&quot;,&quot;  /** @type {V} */&quot;,&quot;  this.valueWrapper = undefined;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../dossier.js" defer></script>