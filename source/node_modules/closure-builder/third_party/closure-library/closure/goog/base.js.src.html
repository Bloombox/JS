<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>base.js</title><link href="../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;base.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/base.js&quot;,[&quot;// Copyright 2006 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Bootstrap for the Google JS Library (Closure).&quot;,&quot; *&quot;,&quot; * In uncompiled mode base.js will attempt to load Closure&#39;s deps file, unless&quot;,&quot; * the global &lt;code&gt;CLOSURE_NO_DEPS&lt;/code&gt; is set to true.  This allows projects&quot;,&quot; * to include their own deps file(s) from different locations.&quot;,&quot; *&quot;,&quot; * Avoid including base.js more than once. This is strictly discouraged and not&quot;,&quot; * supported. goog.require(...) won&#39;t work properly in that case.&quot;,&quot; *&quot;,&quot; * @provideGoog&quot;,&quot; */&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Overridden to true by the compiler.&quot;,&quot; */&quot;,&quot;var COMPILED = false;&quot;,null,null,&quot;/**&quot;,&quot; * Base namespace for the Closure library.  Checks to see goog is already&quot;,&quot; * defined in the current scope before assigning to prevent clobbering if&quot;,&quot; * base.js is loaded more than once.&quot;,&quot; *&quot;,&quot; * @const&quot;,&quot; */&quot;,&quot;var goog = goog || {};&quot;,null,null,&quot;/**&quot;,&quot; * Reference to the global context.  In most cases this will be &#39;window&#39;.&quot;,&quot; */&quot;,&quot;goog.global = this;&quot;,null,null,&quot;/**&quot;,&quot; * A hook for overriding the define values in uncompiled mode.&quot;,&quot; *&quot;,&quot; * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before&quot;,&quot; * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},&quot;,&quot; * {@code goog.define} will use the value instead of the default value.  This&quot;,&quot; * allows flags to be overwritten without compilation (this is normally&quot;,&quot; * accomplished with the compiler&#39;s \&quot;define\&quot; flag).&quot;,&quot; *&quot;,&quot; * Example:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; *   var CLOSURE_UNCOMPILED_DEFINES = {&#39;goog.DEBUG&#39;: false};&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * @type {Object&lt;string, (string|number|boolean)&gt;|undefined}&quot;,&quot; */&quot;,&quot;goog.global.CLOSURE_UNCOMPILED_DEFINES;&quot;,null,null,&quot;/**&quot;,&quot; * A hook for overriding the define values in uncompiled or compiled mode,&quot;,&quot; * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In&quot;,&quot; * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.&quot;,&quot; *&quot;,&quot; * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or&quot;,&quot; * string literals or the compiler will emit an error.&quot;,&quot; *&quot;,&quot; * While any @define value may be set, only those set with goog.define will be&quot;,&quot; * effective for uncompiled code.&quot;,&quot; *&quot;,&quot; * Example:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; *   var CLOSURE_DEFINES = {&#39;goog.DEBUG&#39;: false} ;&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * @type {Object&lt;string, (string|number|boolean)&gt;|undefined}&quot;,&quot; */&quot;,&quot;goog.global.CLOSURE_DEFINES;&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if the specified value is not undefined.&quot;,&quot; *&quot;,&quot; * @param {?} val Variable to test.&quot;,&quot; * @return {boolean} Whether variable is defined.&quot;,&quot; */&quot;,&quot;goog.isDef = function(val) {&quot;,&quot;  // void 0 always evaluates to undefined and hence we do not need to depend on&quot;,&quot;  // the definition of the global variable named &#39;undefined&#39;.&quot;,&quot;  return val !== void 0;&quot;,&quot;};&quot;,null,&quot;/**&quot;,&quot; * Returns true if the specified value is a string.&quot;,&quot; * @param {?} val Variable to test.&quot;,&quot; * @return {boolean} Whether variable is a string.&quot;,&quot; */&quot;,&quot;goog.isString = function(val) {&quot;,&quot;  return typeof val == &#39;string&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if the specified value is a boolean.&quot;,&quot; * @param {?} val Variable to test.&quot;,&quot; * @return {boolean} Whether variable is boolean.&quot;,&quot; */&quot;,&quot;goog.isBoolean = function(val) {&quot;,&quot;  return typeof val == &#39;boolean&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if the specified value is a number.&quot;,&quot; * @param {?} val Variable to test.&quot;,&quot; * @return {boolean} Whether variable is a number.&quot;,&quot; */&quot;,&quot;goog.isNumber = function(val) {&quot;,&quot;  return typeof val == &#39;number&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Builds an object structure for the provided namespace path, ensuring that&quot;,&quot; * names that already exist are not overwritten. For example:&quot;,&quot; * \&quot;a.b.c\&quot; -&gt; a = {};a.b={};a.b.c={};&quot;,&quot; * Used by goog.provide and goog.exportSymbol.&quot;,&quot; * @param {string} name name of the object that this file defines.&quot;,&quot; * @param {*=} opt_object the object to expose at the end of the path.&quot;,&quot; * @param {Object=} opt_objectToExportTo The object to add the path to; default&quot;,&quot; *     is `goog.global`.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {&quot;,&quot;  var parts = name.split(&#39;.&#39;);&quot;,&quot;  var cur = opt_objectToExportTo || goog.global;&quot;,null,&quot;  // Internet Explorer exhibits strange behavior when throwing errors from&quot;,&quot;  // methods externed in this manner.  See the testExportSymbolExceptions in&quot;,&quot;  // base_test.html for an example.&quot;,&quot;  if (!(parts[0] in cur) &amp;&amp; cur.execScript) {&quot;,&quot;    cur.execScript(&#39;var &#39; + parts[0]);&quot;,&quot;  }&quot;,null,&quot;  for (var part; parts.length &amp;&amp; (part = parts.shift());) {&quot;,&quot;    if (!parts.length &amp;&amp; goog.isDef(opt_object)) {&quot;,&quot;      // last part and we have an object; use it&quot;,&quot;      cur[part] = opt_object;&quot;,&quot;    } else if (cur[part] &amp;&amp; cur[part] !== Object.prototype[part]) {&quot;,&quot;      cur = cur[part];&quot;,&quot;    } else {&quot;,&quot;      cur = cur[part] = {};&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Defines a named value. In uncompiled mode, the value is retrieved from&quot;,&quot; * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and&quot;,&quot; * has the property specified, and otherwise used the defined defaultValue.&quot;,&quot; * When compiled the default can be overridden using the compiler&quot;,&quot; * options or the value set in the CLOSURE_DEFINES object.&quot;,&quot; *&quot;,&quot; * @param {string} name The distinguished name to provide.&quot;,&quot; * @param {string|number|boolean} defaultValue&quot;,&quot; */&quot;,&quot;goog.define = function(name, defaultValue) {&quot;,&quot;  var value = defaultValue;&quot;,&quot;  if (!COMPILED) {&quot;,&quot;    if (goog.global.CLOSURE_UNCOMPILED_DEFINES &amp;&amp;&quot;,&quot;        // Anti DOM-clobbering runtime check (b/37736576).&quot;,&quot;        /** @type {?} */ (goog.global.CLOSURE_UNCOMPILED_DEFINES).nodeType ===&quot;,&quot;            undefined &amp;&amp;&quot;,&quot;        Object.prototype.hasOwnProperty.call(&quot;,&quot;            goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {&quot;,&quot;      value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];&quot;,&quot;    } else if (&quot;,&quot;        goog.global.CLOSURE_DEFINES &amp;&amp;&quot;,&quot;        // Anti DOM-clobbering runtime check (b/37736576).&quot;,&quot;        /** @type {?} */ (goog.global.CLOSURE_DEFINES).nodeType === undefined &amp;&amp;&quot;,&quot;        Object.prototype.hasOwnProperty.call(&quot;,&quot;            goog.global.CLOSURE_DEFINES, name)) {&quot;,&quot;      value = goog.global.CLOSURE_DEFINES[name];&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  goog.exportPath_(name, value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} DEBUG is provided as a convenience so that debugging code&quot;,&quot; * that should not be included in a production. It can be easily stripped&quot;,&quot; * by specifying --define goog.DEBUG=false to the Closure Compiler aka&quot;,&quot; * JSCompiler. For example, most toString() methods should be declared inside an&quot;,&quot; * \&quot;if (goog.DEBUG)\&quot; conditional because they are generally used for debugging&quot;,&quot; * purposes and it is difficult for the JSCompiler to statically determine&quot;,&quot; * whether they are used.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.DEBUG&#39;, true);&quot;,null,null,&quot;/**&quot;,&quot; * @define {string} LOCALE defines the locale being used for compilation. It is&quot;,&quot; * used to select locale specific data to be compiled in js binary. BUILD rule&quot;,&quot; * can specify this value by \&quot;--define goog.LOCALE=&lt;locale_name&gt;\&quot; as a compiler&quot;,&quot; * option.&quot;,&quot; *&quot;,&quot; * Take into account that the locale code format is important. You should use&quot;,&quot; * the canonical Unicode format with hyphen as a delimiter. Language must be&quot;,&quot; * lowercase, Language Script - Capitalized, Region - UPPERCASE.&quot;,&quot; * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.&quot;,&quot; *&quot;,&quot; * See more info about locale codes here:&quot;,&quot; * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers&quot;,&quot; *&quot;,&quot; * For language codes you should use values defined by ISO 693-1. See it here&quot;,&quot; * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from&quot;,&quot; * this rule: the Hebrew language. For legacy reasons the old code (iw) should&quot;,&quot; * be used instead of the new code (he).&quot;,&quot; *&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.LOCALE&#39;, &#39;en&#39;);  // default to en&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether this code is running on trusted sites.&quot;,&quot; *&quot;,&quot; * On untrusted sites, several native functions can be defined or overridden by&quot;,&quot; * external libraries like Prototype, Datejs, and JQuery and setting this flag&quot;,&quot; * to false forces closure to use its own implementations when possible.&quot;,&quot; *&quot;,&quot; * If your JavaScript can be loaded by a third party site and you are wary about&quot;,&quot; * relying on non-standard implementations, specify&quot;,&quot; * \&quot;--define goog.TRUSTED_SITE=false\&quot; to the compiler.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.TRUSTED_SITE&#39;, true);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether a project is expected to be running in strict mode.&quot;,&quot; *&quot;,&quot; * This define can be used to trigger alternate implementations compatible with&quot;,&quot; * running in EcmaScript Strict mode or warn about unavailable functionality.&quot;,&quot; * @see https://goo.gl/PudQ4y&quot;,&quot; *&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.STRICT_MODE_COMPATIBLE&#39;, false);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether code that calls {@link goog.setTestOnly} should&quot;,&quot; *     be disallowed in the compilation unit.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.DISALLOW_TEST_ONLY_CODE&#39;, COMPILED &amp;&amp; !goog.DEBUG);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether to use a Chrome app CSP-compliant method for&quot;,&quot; *     loading scripts via goog.require. @see appendScriptSrcNode_.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING&#39;, false);&quot;,null,null,&quot;/**&quot;,&quot; * Defines a namespace in Closure.&quot;,&quot; *&quot;,&quot; * A namespace may only be defined once in a codebase. It may be defined using&quot;,&quot; * goog.provide() or goog.module().&quot;,&quot; *&quot;,&quot; * The presence of one or more goog.provide() calls in a file indicates&quot;,&quot; * that the file defines the given objects/namespaces.&quot;,&quot; * Provided symbols must not be null or undefined.&quot;,&quot; *&quot;,&quot; * In addition, goog.provide() creates the object stubs for a namespace&quot;,&quot; * (for example, goog.provide(\&quot;goog.foo.bar\&quot;) will create the object&quot;,&quot; * goog.foo.bar if it does not already exist).&quot;,&quot; *&quot;,&quot; * Build tools also scan for provide/require/module statements&quot;,&quot; * to discern dependencies, build dependency files (see deps.js), etc.&quot;,&quot; *&quot;,&quot; * @see goog.require&quot;,&quot; * @see goog.module&quot;,&quot; * @param {string} name Namespace provided by this file in the form&quot;,&quot; *     \&quot;goog.package.part\&quot;.&quot;,&quot; */&quot;,&quot;goog.provide = function(name) {&quot;,&quot;  if (goog.isInModuleLoader_()) {&quot;,&quot;    throw new Error(&#39;goog.provide can not be used within a goog.module.&#39;);&quot;,&quot;  }&quot;,&quot;  if (!COMPILED) {&quot;,&quot;    // Ensure that the same namespace isn&#39;t provided twice.&quot;,&quot;    // A goog.module/goog.provide maps a goog.require to a specific file&quot;,&quot;    if (goog.isProvided_(name)) {&quot;,&quot;      throw new Error(&#39;Namespace \&quot;&#39; + name + &#39;\&quot; already declared.&#39;);&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  goog.constructNamespace_(name);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} name Namespace provided by this file in the form&quot;,&quot; *     \&quot;goog.package.part\&quot;.&quot;,&quot; * @param {Object=} opt_obj The object to embed in the namespace.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.constructNamespace_ = function(name, opt_obj) {&quot;,&quot;  if (!COMPILED) {&quot;,&quot;    delete goog.implicitNamespaces_[name];&quot;,null,&quot;    var namespace = name;&quot;,&quot;    while ((namespace = namespace.substring(0, namespace.lastIndexOf(&#39;.&#39;)))) {&quot;,&quot;      if (goog.getObjectByName(namespace)) {&quot;,&quot;        break;&quot;,&quot;      }&quot;,&quot;      goog.implicitNamespaces_[namespace] = true;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  goog.exportPath_(name, opt_obj);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Module identifier validation regexp.&quot;,&quot; * Note: This is a conservative check, it is very possible to be more lenient,&quot;,&quot; *   the primary exclusion here is \&quot;/\&quot; and \&quot;\\\&quot; and a leading \&quot;.\&quot;, these&quot;,&quot; *   restrictions are intended to leave the door open for using goog.require&quot;,&quot; *   with relative file paths rather than module identifiers.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;&quot;,null,null,&quot;/**&quot;,&quot; * Defines a module in Closure.&quot;,&quot; *&quot;,&quot; * Marks that this file must be loaded as a module and claims the namespace.&quot;,&quot; *&quot;,&quot; * A namespace may only be defined once in a codebase. It may be defined using&quot;,&quot; * goog.provide() or goog.module().&quot;,&quot; *&quot;,&quot; * goog.module() has three requirements:&quot;,&quot; * - goog.module may not be used in the same file as goog.provide.&quot;,&quot; * - goog.module must be the first statement in the file.&quot;,&quot; * - only one goog.module is allowed per file.&quot;,&quot; *&quot;,&quot; * When a goog.module annotated file is loaded, it is enclosed in&quot;,&quot; * a strict function closure. This means that:&quot;,&quot; * - any variables declared in a goog.module file are private to the file&quot;,&quot; * (not global), though the compiler is expected to inline the module.&quot;,&quot; * - The code must obey all the rules of \&quot;strict\&quot; JavaScript.&quot;,&quot; * - the file will be marked as \&quot;use strict\&quot;&quot;,&quot; *&quot;,&quot; * NOTE: unlike goog.provide, goog.module does not declare any symbols by&quot;,&quot; * itself. If declared symbols are desired, use&quot;,&quot; * goog.module.declareLegacyNamespace().&quot;,&quot; *&quot;,&quot; *&quot;,&quot; * See the public goog.module proposal: http://goo.gl/Va1hin&quot;,&quot; *&quot;,&quot; * @param {string} name Namespace provided by this file in the form&quot;,&quot; *     \&quot;goog.package.part\&quot;, is expected but not required.&quot;,&quot; * @return {void}&quot;,&quot; */&quot;,&quot;goog.module = function(name) {&quot;,&quot;  if (!goog.isString(name) || !name ||&quot;,&quot;      name.search(goog.VALID_MODULE_RE_) == -1) {&quot;,&quot;    throw new Error(&#39;Invalid module identifier&#39;);&quot;,&quot;  }&quot;,&quot;  if (!goog.isInModuleLoader_()) {&quot;,&quot;    throw new Error(&quot;,&quot;        &#39;Module &#39; + name + &#39; has been loaded incorrectly. Note, &#39; +&quot;,&quot;        &#39;modules cannot be loaded as normal scripts. They require some kind of &#39; +&quot;,&quot;        &#39;pre-processing step. You\\&#39;re likely trying to load a module via a &#39; +&quot;,&quot;        &#39;script tag or as a part of a concatenated bundle without rewriting the &#39; +&quot;,&quot;        &#39;module. For more info see: &#39; +&quot;,&quot;        &#39;https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.&#39;);&quot;,&quot;  }&quot;,&quot;  if (goog.moduleLoaderState_.moduleName) {&quot;,&quot;    throw new Error(&#39;goog.module may only be called once per module.&#39;);&quot;,&quot;  }&quot;,null,&quot;  // Store the module name for the loader.&quot;,&quot;  goog.moduleLoaderState_.moduleName = name;&quot;,&quot;  if (!COMPILED) {&quot;,&quot;    // Ensure that the same namespace isn&#39;t provided twice.&quot;,&quot;    // A goog.module/goog.provide maps a goog.require to a specific file&quot;,&quot;    if (goog.isProvided_(name)) {&quot;,&quot;      throw new Error(&#39;Namespace \&quot;&#39; + name + &#39;\&quot; already declared.&#39;);&quot;,&quot;    }&quot;,&quot;    delete goog.implicitNamespaces_[name];&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} name The module identifier.&quot;,&quot; * @return {?} The module exports for an already loaded module or null.&quot;,&quot; *&quot;,&quot; * Note: This is not an alternative to goog.require, it does not&quot;,&quot; * indicate a hard dependency, instead it is used to indicate&quot;,&quot; * an optional dependency or to access the exports of a module&quot;,&quot; * that has already been loaded.&quot;,&quot; * @suppress {missingProvide}&quot;,&quot; */&quot;,&quot;goog.module.get = function(name) {&quot;,&quot;  return goog.module.getInternal_(name);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} name The module identifier.&quot;,&quot; * @return {?} The module exports for an already loaded module or null.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.module.getInternal_ = function(name) {&quot;,&quot;  if (!COMPILED) {&quot;,&quot;    if (name in goog.loadedModules_) {&quot;,&quot;      return goog.loadedModules_[name];&quot;,&quot;    } else if (!goog.implicitNamespaces_[name]) {&quot;,&quot;      var ns = goog.getObjectByName(name);&quot;,&quot;      return ns != null ? ns : null;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @private {?{moduleName: (string|undefined), declareLegacyNamespace:boolean}}&quot;,&quot; */&quot;,&quot;goog.moduleLoaderState_ = null;&quot;,null,null,&quot;/**&quot;,&quot; * @private&quot;,&quot; * @return {boolean} Whether a goog.module is currently being initialized.&quot;,&quot; */&quot;,&quot;goog.isInModuleLoader_ = function() {&quot;,&quot;  return goog.moduleLoaderState_ != null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Provide the module&#39;s exports as a globally accessible object under the&quot;,&quot; * module&#39;s declared name.  This is intended to ease migration to goog.module&quot;,&quot; * for files that have existing usages.&quot;,&quot; * @suppress {missingProvide}&quot;,&quot; */&quot;,&quot;goog.module.declareLegacyNamespace = function() {&quot;,&quot;  if (!COMPILED &amp;&amp; !goog.isInModuleLoader_()) {&quot;,&quot;    throw new Error(&quot;,&quot;        &#39;goog.module.declareLegacyNamespace must be called from &#39; +&quot;,&quot;        &#39;within a goog.module&#39;);&quot;,&quot;  }&quot;,&quot;  if (!COMPILED &amp;&amp; !goog.moduleLoaderState_.moduleName) {&quot;,&quot;    throw new Error(&quot;,&quot;        &#39;goog.module must be called prior to &#39; +&quot;,&quot;        &#39;goog.module.declareLegacyNamespace.&#39;);&quot;,&quot;  }&quot;,&quot;  goog.moduleLoaderState_.declareLegacyNamespace = true;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Marks that the current file should only be used for testing, and never for&quot;,&quot; * live code in production.&quot;,&quot; *&quot;,&quot; * In the case of unit tests, the message may optionally be an exact namespace&quot;,&quot; * for the test (e.g. &#39;goog.stringTest&#39;). The linter will then ignore the extra&quot;,&quot; * provide (if not explicitly defined in the code).&quot;,&quot; *&quot;,&quot; * @param {string=} opt_message Optional message to add to the error that&#39;s&quot;,&quot; *     raised when used in production code.&quot;,&quot; */&quot;,&quot;goog.setTestOnly = function(opt_message) {&quot;,&quot;  if (goog.DISALLOW_TEST_ONLY_CODE) {&quot;,&quot;    opt_message = opt_message || &#39;&#39;;&quot;,&quot;    throw new Error(&quot;,&quot;        &#39;Importing test-only code into non-debug environment&#39; +&quot;,&quot;        (opt_message ? &#39;: &#39; + opt_message : &#39;.&#39;));&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Forward declares a symbol. This is an indication to the compiler that the&quot;,&quot; * symbol may be used in the source yet is not required and may not be provided&quot;,&quot; * in compilation.&quot;,&quot; *&quot;,&quot; * The most common usage of forward declaration is code that takes a type as a&quot;,&quot; * function parameter but does not need to require it. By forward declaring&quot;,&quot; * instead of requiring, no hard dependency is made, and (if not required&quot;,&quot; * elsewhere) the namespace may never be required and thus, not be pulled&quot;,&quot; * into the JavaScript binary. If it is required elsewhere, it will be type&quot;,&quot; * checked as normal.&quot;,&quot; *&quot;,&quot; * Before using goog.forwardDeclare, please read the documentation at&quot;,&quot; * https://github.com/google/closure-compiler/wiki/Bad-Type-Annotation to&quot;,&quot; * understand the options and tradeoffs when working with forward declarations.&quot;,&quot; *&quot;,&quot; * @param {string} name The namespace to forward declare in the form of&quot;,&quot; *     \&quot;goog.package.part\&quot;.&quot;,&quot; */&quot;,&quot;goog.forwardDeclare = function(name) {};&quot;,null,null,&quot;/**&quot;,&quot; * Forward declare type information. Used to assign types to goog.global&quot;,&quot; * referenced object that would otherwise result in unknown type references&quot;,&quot; * and thus block property disambiguation.&quot;,&quot; */&quot;,&quot;goog.forwardDeclare(&#39;Document&#39;);&quot;,&quot;goog.forwardDeclare(&#39;HTMLScriptElement&#39;);&quot;,&quot;goog.forwardDeclare(&#39;XMLHttpRequest&#39;);&quot;,null,null,&quot;if (!COMPILED) {&quot;,&quot;  /**&quot;,&quot;   * Check if the given name has been goog.provided. This will return false for&quot;,&quot;   * names that are available only as implicit namespaces.&quot;,&quot;   * @param {string} name name of the object to look for.&quot;,&quot;   * @return {boolean} Whether the name has been provided.&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.isProvided_ = function(name) {&quot;,&quot;    return (name in goog.loadedModules_) ||&quot;,&quot;        (!goog.implicitNamespaces_[name] &amp;&amp;&quot;,&quot;         goog.isDefAndNotNull(goog.getObjectByName(name)));&quot;,&quot;  };&quot;,null,&quot;  /**&quot;,&quot;   * Namespaces implicitly defined by goog.provide. For example,&quot;,&quot;   * goog.provide(&#39;goog.events.Event&#39;) implicitly declares that &#39;goog&#39; and&quot;,&quot;   * &#39;goog.events&#39; must be namespaces.&quot;,&quot;   *&quot;,&quot;   * @type {!Object&lt;string, (boolean|undefined)&gt;}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.implicitNamespaces_ = {&#39;goog.module&#39;: true};&quot;,null,&quot;  // NOTE: We add goog.module as an implicit namespace as goog.module is defined&quot;,&quot;  // here and because the existing module package has not been moved yet out of&quot;,&quot;  // the goog.module namespace. This satisifies both the debug loader and&quot;,&quot;  // ahead-of-time dependency management.&quot;,&quot;}&quot;,null,null,&quot;/**&quot;,&quot; * Returns an object based on its fully qualified external name.  The object&quot;,&quot; * is not found if null or undefined.  If you are using a compilation pass that&quot;,&quot; * renames property names beware that using this function will not find renamed&quot;,&quot; * properties.&quot;,&quot; *&quot;,&quot; * @param {string} name The fully qualified name.&quot;,&quot; * @param {Object=} opt_obj The object within which to look; default is&quot;,&quot; *     |goog.global|.&quot;,&quot; * @return {?} The value (object or primitive) or, if not found, null.&quot;,&quot; */&quot;,&quot;goog.getObjectByName = function(name, opt_obj) {&quot;,&quot;  var parts = name.split(&#39;.&#39;);&quot;,&quot;  var cur = opt_obj || goog.global;&quot;,&quot;  for (var i = 0; i &lt; parts.length; i++) {&quot;,&quot;    cur = cur[parts[i]];&quot;,&quot;    if (!goog.isDefAndNotNull(cur)) {&quot;,&quot;      return null;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return cur;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Globalizes a whole namespace, such as goog or goog.lang.&quot;,&quot; *&quot;,&quot; * @param {!Object} obj The namespace to globalize.&quot;,&quot; * @param {Object=} opt_global The object to add the properties to.&quot;,&quot; * @deprecated Properties may be explicitly exported to the global scope, but&quot;,&quot; *     this should no longer be done in bulk.&quot;,&quot; */&quot;,&quot;goog.globalize = function(obj, opt_global) {&quot;,&quot;  var global = opt_global || goog.global;&quot;,&quot;  for (var x in obj) {&quot;,&quot;    global[x] = obj[x];&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds a dependency from a file to the files it requires.&quot;,&quot; * @param {string} relPath The path to the js file.&quot;,&quot; * @param {!Array&lt;string&gt;} provides An array of strings with&quot;,&quot; *     the names of the objects this file provides.&quot;,&quot; * @param {!Array&lt;string&gt;} requires An array of strings with&quot;,&quot; *     the names of the objects this file requires.&quot;,&quot; * @param {boolean|!Object&lt;string&gt;=} opt_loadFlags Parameters indicating&quot;,&quot; *     how the file must be loaded.  The boolean &#39;true&#39; is equivalent&quot;,&quot; *     to {&#39;module&#39;: &#39;goog&#39;} for backwards-compatibility.  Valid properties&quot;,&quot; *     and values include {&#39;module&#39;: &#39;goog&#39;} and {&#39;lang&#39;: &#39;es6&#39;}.&quot;,&quot; */&quot;,&quot;goog.addDependency = function(relPath, provides, requires, opt_loadFlags) {&quot;,&quot;  if (goog.DEPENDENCIES_ENABLED) {&quot;,&quot;    var loader = goog.getLoader_();&quot;,&quot;    if (loader) {&quot;,&quot;      loader.addDependency(relPath, provides, requires, opt_loadFlags);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,null,null,&quot;// NOTE(nnaze): The debug DOM loader was included in base.js as an original way&quot;,&quot;// to do \&quot;debug-mode\&quot; development.  The dependency system can sometimes be&quot;,&quot;// confusing, as can the debug DOM loader&#39;s asynchronous nature.&quot;,&quot;//&quot;,&quot;// With the DOM loader, a call to goog.require() is not blocking -- the script&quot;,&quot;// will not load until some point after the current script.  If a namespace is&quot;,&quot;// needed at runtime, it needs to be defined in a previous script, or loaded via&quot;,&quot;// require() with its registered dependencies.&quot;,&quot;//&quot;,&quot;// User-defined namespaces may need their own deps file. For a reference on&quot;,&quot;// creating a deps file, see:&quot;,&quot;// Externally: https://developers.google.com/closure/library/docs/depswriter&quot;,&quot;//&quot;,&quot;// Because of legacy clients, the DOM loader can&#39;t be easily removed from&quot;,&quot;// base.js.  Work was done to make it disableable or replaceable for&quot;,&quot;// different environments (DOM-less JavaScript interpreters like Rhino or V8,&quot;,&quot;// for example). See bootstrap/ for more information.&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether to enable the debug loader.&quot;,&quot; *&quot;,&quot; * If enabled, a call to goog.require() will attempt to load the namespace by&quot;,&quot; * appending a script tag to the DOM (if the namespace has been registered).&quot;,&quot; *&quot;,&quot; * If disabled, goog.require() will simply assert that the namespace has been&quot;,&quot; * provided (and depend on the fact that some outside tool correctly ordered&quot;,&quot; * the script).&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.ENABLE_DEBUG_LOADER&#39;, true);&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} msg&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.logToConsole_ = function(msg) {&quot;,&quot;  if (goog.global.console) {&quot;,&quot;    goog.global.console[&#39;error&#39;](msg);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Implements a system for the dynamic resolution of dependencies that works in&quot;,&quot; * parallel with the BUILD system. Note that all calls to goog.require will be&quot;,&quot; * stripped by the compiler.&quot;,&quot; * @see goog.provide&quot;,&quot; * @param {string} name Namespace to include (as was given in goog.provide()) in&quot;,&quot; *     the form \&quot;goog.package.part\&quot;.&quot;,&quot; * @return {?} If called within a goog.module file, the associated namespace or&quot;,&quot; *     module otherwise null.&quot;,&quot; */&quot;,&quot;goog.require = function(name) {&quot;,&quot;  if (goog.ENABLE_DEBUG_LOADER &amp;&amp; goog.debugLoader_) {&quot;,&quot;    goog.getLoader_().earlyProcessLoad(name);&quot;,&quot;  }&quot;,null,&quot;  // If the object already exists we do not need to do anything.&quot;,&quot;  if (!COMPILED) {&quot;,&quot;    if (goog.isProvided_(name)) {&quot;,&quot;      if (goog.isInModuleLoader_()) {&quot;,&quot;        return goog.module.getInternal_(name);&quot;,&quot;      }&quot;,&quot;    } else if (goog.ENABLE_DEBUG_LOADER) {&quot;,&quot;      var moduleLoaderState = goog.moduleLoaderState_;&quot;,&quot;      goog.moduleLoaderState_ = null;&quot;,&quot;      try {&quot;,&quot;        var loader = goog.getLoader_();&quot;,&quot;        if (loader) {&quot;,&quot;          loader.load(name);&quot;,&quot;        } else {&quot;,&quot;          goog.logToConsole_(&quot;,&quot;              &#39;Could not load &#39; + name + &#39; because there is no debug loader.&#39;);&quot;,&quot;        }&quot;,&quot;      } finally {&quot;,&quot;        goog.moduleLoaderState_ = moduleLoaderState;&quot;,&quot;      }&quot;,&quot;    }&quot;,null,&quot;    return null;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Path for included scripts.&quot;,&quot; * @type {string}&quot;,&quot; */&quot;,&quot;goog.basePath = &#39;&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * A hook for overriding the base path.&quot;,&quot; * @type {string|undefined}&quot;,&quot; */&quot;,&quot;goog.global.CLOSURE_BASE_PATH;&quot;,null,null,&quot;/**&quot;,&quot; * Whether to attempt to load Closure&#39;s deps file. By default, when uncompiled,&quot;,&quot; * deps files will attempt to be loaded.&quot;,&quot; * @type {boolean|undefined}&quot;,&quot; */&quot;,&quot;goog.global.CLOSURE_NO_DEPS;&quot;,null,null,&quot;/**&quot;,&quot; * A function to import a single script. This is meant to be overridden when&quot;,&quot; * Closure is being run in non-HTML contexts, such as web workers. It&#39;s defined&quot;,&quot; * in the global scope so that it can be set before base.js is loaded, which&quot;,&quot; * allows deps.js to be imported properly.&quot;,&quot; *&quot;,&quot; * The function is passed the script source, which is a relative URI. It should&quot;,&quot; * return true if the script was imported, false otherwise.&quot;,&quot; * @type {(function(string): boolean)|undefined}&quot;,&quot; */&quot;,&quot;goog.global.CLOSURE_IMPORT_SCRIPT;&quot;,null,null,&quot;/**&quot;,&quot; * Null function used for default values of callbacks, etc.&quot;,&quot; * @return {void} Nothing.&quot;,&quot; */&quot;,&quot;goog.nullFunction = function() {};&quot;,null,null,&quot;/**&quot;,&quot; * When defining a class Foo with an abstract method bar(), you can do:&quot;,&quot; * Foo.prototype.bar = goog.abstractMethod&quot;,&quot; *&quot;,&quot; * Now if a subclass of Foo fails to override bar(), an error will be thrown&quot;,&quot; * when bar() is invoked.&quot;,&quot; *&quot;,&quot; * @type {!Function}&quot;,&quot; * @throws {Error} when invoked to indicate the method should be overridden.&quot;,&quot; */&quot;,&quot;goog.abstractMethod = function() {&quot;,&quot;  throw new Error(&#39;unimplemented abstract method&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds a {@code getInstance} static method that always returns the same&quot;,&quot; * instance object.&quot;,&quot; * @param {!Function} ctor The constructor for the class to add the static&quot;,&quot; *     method to.&quot;,&quot; */&quot;,&quot;goog.addSingletonGetter = function(ctor) {&quot;,&quot;  // instance_ is immediately set to prevent issues with sealed constructors&quot;,&quot;  // such as are encountered when a constructor is returned as the export object&quot;,&quot;  // of a goog.module in unoptimized code.&quot;,&quot;  ctor.instance_ = undefined;&quot;,&quot;  ctor.getInstance = function() {&quot;,&quot;    if (ctor.instance_) {&quot;,&quot;      return ctor.instance_;&quot;,&quot;    }&quot;,&quot;    if (goog.DEBUG) {&quot;,&quot;      // NOTE: JSCompiler can&#39;t optimize away Array#push.&quot;,&quot;      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;&quot;,&quot;    }&quot;,&quot;    return ctor.instance_ = new ctor;&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * All singleton classes that have been instantiated, for testing. Don&#39;t read&quot;,&quot; * it directly, use the {@code goog.testing.singleton} module. The compiler&quot;,&quot; * removes this variable if unused.&quot;,&quot; * @type {!Array&lt;!Function&gt;}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.instantiatedSingletons_ = [];&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether to load goog.modules using {@code eval} when using&quot;,&quot; * the debug loader.  This provides a better debugging experience as the&quot;,&quot; * source is unmodified and can be edited using Chrome Workspaces or similar.&quot;,&quot; * However in some environments the use of {@code eval} is banned&quot;,&quot; * so we provide an alternative.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.LOAD_MODULE_USING_EVAL&#39;, true);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether the exports of goog.modules should be sealed when&quot;,&quot; * possible.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.SEAL_MODULE_EXPORTS&#39;, goog.DEBUG);&quot;,null,null,&quot;/**&quot;,&quot; * The registry of initialized modules:&quot;,&quot; * the module identifier to module exports map.&quot;,&quot; * @private @const {!Object&lt;string, ?&gt;}&quot;,&quot; */&quot;,&quot;goog.loadedModules_ = {};&quot;,null,null,&quot;/**&quot;,&quot; * True if goog.dependencies_ is available.&quot;,&quot; * @const {boolean}&quot;,&quot; */&quot;,&quot;goog.DEPENDENCIES_ENABLED = !COMPILED &amp;&amp; goog.ENABLE_DEBUG_LOADER;&quot;,null,null,&quot;/**&quot;,&quot; * @define {string} How to decide whether to transpile.  Valid values&quot;,&quot; * are &#39;always&#39;, &#39;never&#39;, and &#39;detect&#39;.  The default (&#39;detect&#39;) is to&quot;,&quot; * use feature detection to determine which language levels need&quot;,&quot; * transpilation.&quot;,&quot; */&quot;,&quot;// NOTE(user): we could expand this to accept a language level to bypass&quot;,&quot;// detection: e.g. goog.TRANSPILE == &#39;es5&#39; would transpile ES6 files but&quot;,&quot;// would leave ES3 and ES5 files alone.&quot;,&quot;goog.define(&#39;goog.TRANSPILE&#39;, &#39;detect&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * @define {string} Path to the transpiler.  Executing the script at this&quot;,&quot; * path (relative to base.js) should define a function $jscomp.transpile.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.TRANSPILER&#39;, &#39;transpile.js&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * @define {string} Debug loader file to load. This file should define an&quot;,&quot; * implementation of a `goog.DebugLoader` and register it via&quot;,&quot; * `goog.registerDebugLoader`.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.DEBUG_LOADER&#39;, &#39;&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * @package {?boolean}&quot;,&quot; * Visible for testing.&quot;,&quot; */&quot;,&quot;goog.hasBadLetScoping = null;&quot;,null,null,&quot;/**&quot;,&quot; * @return {boolean}&quot;,&quot; * @package Visible for testing.&quot;,&quot; */&quot;,&quot;goog.useSafari10Workaround = function() {&quot;,&quot;  if (goog.hasBadLetScoping == null) {&quot;,&quot;    var hasBadLetScoping;&quot;,&quot;    try {&quot;,&quot;      hasBadLetScoping = !eval(&quot;,&quot;          &#39;\&quot;use strict\&quot;;&#39; +&quot;,&quot;          &#39;let x = 1; function f() { return typeof x; };&#39; +&quot;,&quot;          &#39;f() == \&quot;number\&quot;;&#39;);&quot;,&quot;    } catch (e) {&quot;,&quot;      // Assume that ES6 syntax isn&#39;t supported.&quot;,&quot;      hasBadLetScoping = false;&quot;,&quot;    }&quot;,&quot;    goog.hasBadLetScoping = hasBadLetScoping;&quot;,&quot;  }&quot;,&quot;  return goog.hasBadLetScoping;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} moduleDef&quot;,&quot; * @return {string}&quot;,&quot; * @package Visible for testing.&quot;,&quot; */&quot;,&quot;goog.workaroundSafari10EvalBug = function(moduleDef) {&quot;,&quot;  return &#39;(function(){&#39; + moduleDef +&quot;,&quot;      &#39;\\n&#39; +  // Terminate any trailing single line comment.&quot;,&quot;      &#39;;&#39; +   // Terminate any trailing expression.&quot;,&quot;      &#39;})();\\n&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {function(?):?|string} moduleDef The module definition.&quot;,&quot; */&quot;,&quot;goog.loadModule = function(moduleDef) {&quot;,&quot;  // NOTE: we allow function definitions to be either in the from&quot;,&quot;  // of a string to eval (which keeps the original source intact) or&quot;,&quot;  // in a eval forbidden environment (CSP) we allow a function definition&quot;,&quot;  // which in its body must call {@code goog.module}, and return the exports&quot;,&quot;  // of the module.&quot;,&quot;  var previousState = goog.moduleLoaderState_;&quot;,&quot;  try {&quot;,&quot;    goog.moduleLoaderState_ = {&quot;,&quot;      moduleName: undefined,&quot;,&quot;      declareLegacyNamespace: false&quot;,&quot;    };&quot;,&quot;    var exports;&quot;,&quot;    if (goog.isFunction(moduleDef)) {&quot;,&quot;      exports = moduleDef.call(undefined, {});&quot;,&quot;    } else if (goog.isString(moduleDef)) {&quot;,&quot;      if (goog.useSafari10Workaround()) {&quot;,&quot;        moduleDef = goog.workaroundSafari10EvalBug(moduleDef);&quot;,&quot;      }&quot;,null,&quot;      exports = goog.loadModuleFromSource_.call(undefined, moduleDef);&quot;,&quot;    } else {&quot;,&quot;      throw new Error(&#39;Invalid module definition&#39;);&quot;,&quot;    }&quot;,null,&quot;    var moduleName = goog.moduleLoaderState_.moduleName;&quot;,&quot;    if (!goog.isString(moduleName) || !moduleName) {&quot;,&quot;      throw new Error(&#39;Invalid module name \\\&quot;&#39; + moduleName + &#39;\\\&quot;&#39;);&quot;,&quot;    }&quot;,null,&quot;    // Don&#39;t seal legacy namespaces as they may be uses as a parent of&quot;,&quot;    // another namespace&quot;,&quot;    if (goog.moduleLoaderState_.declareLegacyNamespace) {&quot;,&quot;      goog.constructNamespace_(moduleName, exports);&quot;,&quot;    } else if (&quot;,&quot;        goog.SEAL_MODULE_EXPORTS &amp;&amp; Object.seal &amp;&amp; typeof exports == &#39;object&#39; &amp;&amp;&quot;,&quot;        exports != null) {&quot;,&quot;      Object.seal(exports);&quot;,&quot;    }&quot;,null,&quot;    goog.loadedModules_[moduleName] = exports;&quot;,&quot;  } finally {&quot;,&quot;    goog.moduleLoaderState_ = previousState;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @private @const&quot;,&quot; */&quot;,&quot;goog.loadModuleFromSource_ = /** @type {function(string):?} */ (function() {&quot;,&quot;  // NOTE: we avoid declaring parameters or local variables here to avoid&quot;,&quot;  // masking globals or leaking values into the module definition.&quot;,&quot;  &#39;use strict&#39;;&quot;,&quot;  var exports = {};&quot;,&quot;  eval(arguments[0]);&quot;,&quot;  return exports;&quot;,&quot;});&quot;,null,null,&quot;/**&quot;,&quot; * Normalize a file path by removing redundant \&quot;..\&quot; and extraneous \&quot;.\&quot; file&quot;,&quot; * path components.&quot;,&quot; * @param {string} path&quot;,&quot; * @return {string}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.normalizePath_ = function(path) {&quot;,&quot;  var components = path.split(&#39;/&#39;);&quot;,&quot;  var i = 0;&quot;,&quot;  while (i &lt; components.length) {&quot;,&quot;    if (components[i] == &#39;.&#39;) {&quot;,&quot;      components.splice(i, 1);&quot;,&quot;    } else if (&quot;,&quot;        i &amp;&amp; components[i] == &#39;..&#39; &amp;&amp; components[i - 1] &amp;&amp;&quot;,&quot;        components[i - 1] != &#39;..&#39;) {&quot;,&quot;      components.splice(--i, 2);&quot;,&quot;    } else {&quot;,&quot;      i++;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return components.join(&#39;/&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Provides a hook for loading a file when using Closure&#39;s goog.require() API&quot;,&quot; * with goog.modules.  In particular this hook is provided to support Node.js.&quot;,&quot; *&quot;,&quot; * @type {(function(string):string)|undefined}&quot;,&quot; */&quot;,&quot;goog.global.CLOSURE_LOAD_FILE_SYNC;&quot;,null,null,&quot;/**&quot;,&quot; * Loads file by synchronous XHR. Should not be used in production environments.&quot;,&quot; * @param {string} src Source URL.&quot;,&quot; * @return {?string} File contents, or null if load failed.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.loadFileSync_ = function(src) {&quot;,&quot;  if (goog.global.CLOSURE_LOAD_FILE_SYNC) {&quot;,&quot;    return goog.global.CLOSURE_LOAD_FILE_SYNC(src);&quot;,&quot;  } else {&quot;,&quot;    try {&quot;,&quot;      /** @type {XMLHttpRequest} */&quot;,&quot;      var xhr = new goog.global[&#39;XMLHttpRequest&#39;]();&quot;,&quot;      xhr.open(&#39;get&#39;, src, false);&quot;,&quot;      xhr.send();&quot;,&quot;      // NOTE: Successful http: requests have a status of 200, but successful&quot;,&quot;      // file: requests may have a status of zero.  Any other status, or a&quot;,&quot;      // thrown exception (particularly in case of file: requests) indicates&quot;,&quot;      // some sort of error, which we treat as a missing or unavailable file.&quot;,&quot;      return xhr.status == 0 || xhr.status == 200 ? xhr.responseText : null;&quot;,&quot;    } catch (err) {&quot;,&quot;      // No need to rethrow or log, since errors should show up on their own.&quot;,&quot;      return null;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Lazily retrieves the transpiler and applies it to the source.&quot;,&quot; * @param {string} code JS code.&quot;,&quot; * @param {string} path Path to the code.&quot;,&quot; * @return {string} The transpiled code.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.transpile_ = function(code, path) {&quot;,&quot;  var jscomp = goog.global[&#39;$jscomp&#39;];&quot;,&quot;  if (!jscomp) {&quot;,&quot;    goog.global[&#39;$jscomp&#39;] = jscomp = {};&quot;,&quot;  }&quot;,&quot;  var transpile = jscomp.transpile;&quot;,&quot;  if (!transpile) {&quot;,&quot;    var transpilerPath = goog.basePath + goog.TRANSPILER;&quot;,&quot;    var transpilerCode = goog.loadFileSync_(transpilerPath);&quot;,&quot;    if (transpilerCode) {&quot;,&quot;      // This must be executed synchronously, since by the time we know we&quot;,&quot;      // need it, we&#39;re about to load and write the ES6 code synchronously,&quot;,&quot;      // so a normal script-tag load will be too slow. Wrapped in a function&quot;,&quot;      // so that code is eval&#39;d in the global scope.&quot;,&quot;      (function() {&quot;,&quot;        eval(transpilerCode + &#39;\\n//# sourceURL=&#39; + transpilerPath);&quot;,&quot;      }).call(goog.global);&quot;,&quot;      // Even though the transpiler is optional, if $gwtExport is found, it&#39;s&quot;,&quot;      // a sign the transpiler was loaded and the $jscomp.transpile *should*&quot;,&quot;      // be there.&quot;,&quot;      if (goog.global[&#39;$gwtExport&#39;] &amp;&amp; goog.global[&#39;$gwtExport&#39;][&#39;$jscomp&#39;] &amp;&amp;&quot;,&quot;          !goog.global[&#39;$gwtExport&#39;][&#39;$jscomp&#39;][&#39;transpile&#39;]) {&quot;,&quot;        throw new Error(&quot;,&quot;            &#39;The transpiler did not properly export the \&quot;transpile\&quot; &#39; +&quot;,&quot;            &#39;method. $gwtExport: &#39; + JSON.stringify(goog.global[&#39;$gwtExport&#39;]));&quot;,&quot;      }&quot;,&quot;      // transpile.js only exports a single $jscomp function, transpile. We&quot;,&quot;      // grab just that and add it to the existing definition of $jscomp which&quot;,&quot;      // contains the polyfills.&quot;,&quot;      goog.global[&#39;$jscomp&#39;].transpile =&quot;,&quot;          goog.global[&#39;$gwtExport&#39;][&#39;$jscomp&#39;][&#39;transpile&#39;];&quot;,&quot;      jscomp = goog.global[&#39;$jscomp&#39;];&quot;,&quot;      transpile = jscomp.transpile;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  if (!transpile) {&quot;,&quot;    // The transpiler is an optional component.  If it&#39;s not available then&quot;,&quot;    // replace it with a pass-through function that simply logs.&quot;,&quot;    var suffix = &#39; requires transpilation but no transpiler was found.&#39;;&quot;,&quot;    transpile = jscomp.transpile = function(code, path) {&quot;,&quot;      // TODO(user): figure out some way to get this error to show up&quot;,&quot;      // in test results, noting that the failure may occur in many&quot;,&quot;      // different ways, including in loadModule() before the test&quot;,&quot;      // runner even comes up.&quot;,&quot;      goog.logToConsole_(path + suffix);&quot;,&quot;      return code;&quot;,&quot;    };&quot;,&quot;  }&quot;,&quot;  // Note: any transpilation errors/warnings will be logged to the console.&quot;,&quot;  return transpile(code, path);&quot;,&quot;};&quot;,null,&quot;//==============================================================================&quot;,&quot;// Language Enhancements&quot;,&quot;//==============================================================================&quot;,null,null,&quot;/**&quot;,&quot; * This is a \&quot;fixed\&quot; version of the typeof operator.  It differs from the typeof&quot;,&quot; * operator in such a way that null returns &#39;null&#39; and arrays return &#39;array&#39;.&quot;,&quot; * @param {?} value The value to get the type of.&quot;,&quot; * @return {string} The name of the type.&quot;,&quot; */&quot;,&quot;goog.typeOf = function(value) {&quot;,&quot;  var s = typeof value;&quot;,&quot;  if (s == &#39;object&#39;) {&quot;,&quot;    if (value) {&quot;,&quot;      // Check these first, so we can avoid calling Object.prototype.toString if&quot;,&quot;      // possible.&quot;,&quot;      //&quot;,&quot;      // IE improperly marshals typeof across execution contexts, but a&quot;,&quot;      // cross-context object will still return false for \&quot;instanceof Object\&quot;.&quot;,&quot;      if (value instanceof Array) {&quot;,&quot;        return &#39;array&#39;;&quot;,&quot;      } else if (value instanceof Object) {&quot;,&quot;        return s;&quot;,&quot;      }&quot;,null,&quot;      // HACK: In order to use an Object prototype method on the arbitrary&quot;,&quot;      //   value, the compiler requires the value be cast to type Object,&quot;,&quot;      //   even though the ECMA spec explicitly allows it.&quot;,&quot;      var className = Object.prototype.toString.call(&quot;,&quot;          /** @type {!Object} */ (value));&quot;,&quot;      // In Firefox 3.6, attempting to access iframe window objects&#39; length&quot;,&quot;      // property throws an NS_ERROR_FAILURE, so we need to special-case it&quot;,&quot;      // here.&quot;,&quot;      if (className == &#39;[object Window]&#39;) {&quot;,&quot;        return &#39;object&#39;;&quot;,&quot;      }&quot;,null,&quot;      // We cannot always use constructor == Array or instanceof Array because&quot;,&quot;      // different frames have different Array objects. In IE6, if the iframe&quot;,&quot;      // where the array was created is destroyed, the array loses its&quot;,&quot;      // prototype. Then dereferencing val.splice here throws an exception, so&quot;,&quot;      // we can&#39;t use goog.isFunction. Calling typeof directly returns &#39;unknown&#39;&quot;,&quot;      // so that will work. In this case, this function will return false and&quot;,&quot;      // most array functions will still work because the array is still&quot;,&quot;      // array-like (supports length and []) even though it has lost its&quot;,&quot;      // prototype.&quot;,&quot;      // Mark Miller noticed that Object.prototype.toString&quot;,&quot;      // allows access to the unforgeable [[Class]] property.&quot;,&quot;      //  15.2.4.2 Object.prototype.toString ( )&quot;,&quot;      //  When the toString method is called, the following steps are taken:&quot;,&quot;      //      1. Get the [[Class]] property of this object.&quot;,&quot;      //      2. Compute a string value by concatenating the three strings&quot;,&quot;      //         \&quot;[object \&quot;, Result(1), and \&quot;]\&quot;.&quot;,&quot;      //      3. Return Result(2).&quot;,&quot;      // and this behavior survives the destruction of the execution context.&quot;,&quot;      if ((className == &#39;[object Array]&#39; ||&quot;,&quot;           // In IE all non value types are wrapped as objects across window&quot;,&quot;           // boundaries (not iframe though) so we have to do object detection&quot;,&quot;           // for this edge case.&quot;,&quot;           typeof value.length == &#39;number&#39; &amp;&amp;&quot;,&quot;               typeof value.splice != &#39;undefined&#39; &amp;&amp;&quot;,&quot;               typeof value.propertyIsEnumerable != &#39;undefined&#39; &amp;&amp;&quot;,&quot;               !value.propertyIsEnumerable(&#39;splice&#39;)&quot;,null,&quot;               )) {&quot;,&quot;        return &#39;array&#39;;&quot;,&quot;      }&quot;,&quot;      // HACK: There is still an array case that fails.&quot;,&quot;      //     function ArrayImpostor() {}&quot;,&quot;      //     ArrayImpostor.prototype = [];&quot;,&quot;      //     var impostor = new ArrayImpostor;&quot;,&quot;      // this can be fixed by getting rid of the fast path&quot;,&quot;      // (value instanceof Array) and solely relying on&quot;,&quot;      // (value &amp;&amp; Object.prototype.toString.vall(value) === &#39;[object Array]&#39;)&quot;,&quot;      // but that would require many more function calls and is not warranted&quot;,&quot;      // unless closure code is receiving objects from untrusted sources.&quot;,null,&quot;      // IE in cross-window calls does not correctly marshal the function type&quot;,&quot;      // (it appears just as an object) so we cannot use just typeof val ==&quot;,&quot;      // &#39;function&#39;. However, if the object has a call property, it is a&quot;,&quot;      // function.&quot;,&quot;      if ((className == &#39;[object Function]&#39; ||&quot;,&quot;           typeof value.call != &#39;undefined&#39; &amp;&amp;&quot;,&quot;               typeof value.propertyIsEnumerable != &#39;undefined&#39; &amp;&amp;&quot;,&quot;               !value.propertyIsEnumerable(&#39;call&#39;))) {&quot;,&quot;        return &#39;function&#39;;&quot;,&quot;      }&quot;,null,&quot;    } else {&quot;,&quot;      return &#39;null&#39;;&quot;,&quot;    }&quot;,null,&quot;  } else if (s == &#39;function&#39; &amp;&amp; typeof value.call == &#39;undefined&#39;) {&quot;,&quot;    // In Safari typeof nodeList returns &#39;function&#39;, and on Firefox typeof&quot;,&quot;    // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We&quot;,&quot;    // would like to return object for those and we can detect an invalid&quot;,&quot;    // function by making sure that the function object has a call method.&quot;,&quot;    return &#39;object&#39;;&quot;,&quot;  }&quot;,&quot;  return s;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if the specified value is null.&quot;,&quot; * @param {?} val Variable to test.&quot;,&quot; * @return {boolean} Whether variable is null.&quot;,&quot; */&quot;,&quot;goog.isNull = function(val) {&quot;,&quot;  return val === null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if the specified value is defined and not null.&quot;,&quot; * @param {?} val Variable to test.&quot;,&quot; * @return {boolean} Whether variable is defined and not null.&quot;,&quot; */&quot;,&quot;goog.isDefAndNotNull = function(val) {&quot;,&quot;  // Note that undefined == null.&quot;,&quot;  return val != null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if the specified value is an array.&quot;,&quot; * @param {?} val Variable to test.&quot;,&quot; * @return {boolean} Whether variable is an array.&quot;,&quot; */&quot;,&quot;goog.isArray = function(val) {&quot;,&quot;  return goog.typeOf(val) == &#39;array&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if the object looks like an array. To qualify as array like&quot;,&quot; * the value needs to be either a NodeList or an object with a Number length&quot;,&quot; * property. As a special case, a function value is not array like, because its&quot;,&quot; * length property is fixed to correspond to the number of expected arguments.&quot;,&quot; * @param {?} val Variable to test.&quot;,&quot; * @return {boolean} Whether variable is an array.&quot;,&quot; */&quot;,&quot;goog.isArrayLike = function(val) {&quot;,&quot;  var type = goog.typeOf(val);&quot;,&quot;  // We do not use goog.isObject here in order to exclude function values.&quot;,&quot;  return type == &#39;array&#39; || type == &#39;object&#39; &amp;&amp; typeof val.length == &#39;number&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if the object looks like a Date. To qualify as Date-like the&quot;,&quot; * value needs to be an object and have a getFullYear() function.&quot;,&quot; * @param {?} val Variable to test.&quot;,&quot; * @return {boolean} Whether variable is a like a Date.&quot;,&quot; */&quot;,&quot;goog.isDateLike = function(val) {&quot;,&quot;  return goog.isObject(val) &amp;&amp; typeof val.getFullYear == &#39;function&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if the specified value is a function.&quot;,&quot; * @param {?} val Variable to test.&quot;,&quot; * @return {boolean} Whether variable is a function.&quot;,&quot; */&quot;,&quot;goog.isFunction = function(val) {&quot;,&quot;  return goog.typeOf(val) == &#39;function&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if the specified value is an object.  This includes arrays and&quot;,&quot; * functions.&quot;,&quot; * @param {?} val Variable to test.&quot;,&quot; * @return {boolean} Whether variable is an object.&quot;,&quot; */&quot;,&quot;goog.isObject = function(val) {&quot;,&quot;  var type = typeof val;&quot;,&quot;  return type == &#39;object&#39; &amp;&amp; val != null || type == &#39;function&#39;;&quot;,&quot;  // return Object(val) === val also works, but is slower, especially if val is&quot;,&quot;  // not an object.&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets a unique ID for an object. This mutates the object so that further calls&quot;,&quot; * with the same object as a parameter returns the same value. The unique ID is&quot;,&quot; * guaranteed to be unique across the current session amongst objects that are&quot;,&quot; * passed into {@code getUid}. There is no guarantee that the ID is unique or&quot;,&quot; * consistent across sessions. It is unsafe to generate unique ID for function&quot;,&quot; * prototypes.&quot;,&quot; *&quot;,&quot; * @param {Object} obj The object to get the unique ID for.&quot;,&quot; * @return {number} The unique ID for the object.&quot;,&quot; */&quot;,&quot;goog.getUid = function(obj) {&quot;,&quot;  // TODO(arv): Make the type stricter, do not accept null.&quot;,null,&quot;  // In Opera window.hasOwnProperty exists but always returns false so we avoid&quot;,&quot;  // using it. As a consequence the unique ID generated for BaseClass.prototype&quot;,&quot;  // and SubClass.prototype will be the same.&quot;,&quot;  return obj[goog.UID_PROPERTY_] ||&quot;,&quot;      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Whether the given object is already assigned a unique ID.&quot;,&quot; *&quot;,&quot; * This does not modify the object.&quot;,&quot; *&quot;,&quot; * @param {!Object} obj The object to check.&quot;,&quot; * @return {boolean} Whether there is an assigned unique id for the object.&quot;,&quot; */&quot;,&quot;goog.hasUid = function(obj) {&quot;,&quot;  return !!obj[goog.UID_PROPERTY_];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes the unique ID from an object. This is useful if the object was&quot;,&quot; * previously mutated using {@code goog.getUid} in which case the mutation is&quot;,&quot; * undone.&quot;,&quot; * @param {Object} obj The object to remove the unique ID field from.&quot;,&quot; */&quot;,&quot;goog.removeUid = function(obj) {&quot;,&quot;  // TODO(arv): Make the type stricter, do not accept null.&quot;,null,&quot;  // In IE, DOM nodes are not instances of Object and throw an exception if we&quot;,&quot;  // try to delete.  Instead we try to use removeAttribute.&quot;,&quot;  if (obj !== null &amp;&amp; &#39;removeAttribute&#39; in obj) {&quot;,&quot;    obj.removeAttribute(goog.UID_PROPERTY_);&quot;,&quot;  }&quot;,null,&quot;  try {&quot;,&quot;    delete obj[goog.UID_PROPERTY_];&quot;,&quot;  } catch (ex) {&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Name for unique ID property. Initialized in a way to help avoid collisions&quot;,&quot; * with other closure JavaScript on the same page.&quot;,&quot; * @type {string}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.UID_PROPERTY_ = &#39;closure_uid_&#39; + ((Math.random() * 1e9) &gt;&gt;&gt; 0);&quot;,null,null,&quot;/**&quot;,&quot; * Counter for UID.&quot;,&quot; * @type {number}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uidCounter_ = 0;&quot;,null,null,&quot;/**&quot;,&quot; * Adds a hash code field to an object. The hash code is unique for the&quot;,&quot; * given object.&quot;,&quot; * @param {Object} obj The object to get the hash code for.&quot;,&quot; * @return {number} The hash code for the object.&quot;,&quot; * @deprecated Use goog.getUid instead.&quot;,&quot; */&quot;,&quot;goog.getHashCode = goog.getUid;&quot;,null,null,&quot;/**&quot;,&quot; * Removes the hash code field from an object.&quot;,&quot; * @param {Object} obj The object to remove the field from.&quot;,&quot; * @deprecated Use goog.removeUid instead.&quot;,&quot; */&quot;,&quot;goog.removeHashCode = goog.removeUid;&quot;,null,null,&quot;/**&quot;,&quot; * Clones a value. The input may be an Object, Array, or basic type. Objects and&quot;,&quot; * arrays will be cloned recursively.&quot;,&quot; *&quot;,&quot; * WARNINGS:&quot;,&quot; * &lt;code&gt;goog.cloneObject&lt;/code&gt; does not detect reference loops. Objects that&quot;,&quot; * refer to themselves will cause infinite recursion.&quot;,&quot; *&quot;,&quot; * &lt;code&gt;goog.cloneObject&lt;/code&gt; is unaware of unique identifiers, and copies&quot;,&quot; * UIDs created by &lt;code&gt;getUid&lt;/code&gt; into cloned results.&quot;,&quot; *&quot;,&quot; * @param {*} obj The value to clone.&quot;,&quot; * @return {*} A clone of the input value.&quot;,&quot; * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.&quot;,&quot; */&quot;,&quot;goog.cloneObject = function(obj) {&quot;,&quot;  var type = goog.typeOf(obj);&quot;,&quot;  if (type == &#39;object&#39; || type == &#39;array&#39;) {&quot;,&quot;    if (obj.clone) {&quot;,&quot;      return obj.clone();&quot;,&quot;    }&quot;,&quot;    var clone = type == &#39;array&#39; ? [] : {};&quot;,&quot;    for (var key in obj) {&quot;,&quot;      clone[key] = goog.cloneObject(obj[key]);&quot;,&quot;    }&quot;,&quot;    return clone;&quot;,&quot;  }&quot;,null,&quot;  return obj;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * A native implementation of goog.bind.&quot;,&quot; * @param {?function(this:T, ...)} fn A function to partially apply.&quot;,&quot; * @param {T} selfObj Specifies the object which this should point to when the&quot;,&quot; *     function is run.&quot;,&quot; * @param {...*} var_args Additional arguments that are partially applied to the&quot;,&quot; *     function.&quot;,&quot; * @return {!Function} A partially-applied form of the function goog.bind() was&quot;,&quot; *     invoked as a method of.&quot;,&quot; * @template T&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.bindNative_ = function(fn, selfObj, var_args) {&quot;,&quot;  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * A pure-JS implementation of goog.bind.&quot;,&quot; * @param {?function(this:T, ...)} fn A function to partially apply.&quot;,&quot; * @param {T} selfObj Specifies the object which this should point to when the&quot;,&quot; *     function is run.&quot;,&quot; * @param {...*} var_args Additional arguments that are partially applied to the&quot;,&quot; *     function.&quot;,&quot; * @return {!Function} A partially-applied form of the function goog.bind() was&quot;,&quot; *     invoked as a method of.&quot;,&quot; * @template T&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.bindJs_ = function(fn, selfObj, var_args) {&quot;,&quot;  if (!fn) {&quot;,&quot;    throw new Error();&quot;,&quot;  }&quot;,null,&quot;  if (arguments.length &gt; 2) {&quot;,&quot;    var boundArgs = Array.prototype.slice.call(arguments, 2);&quot;,&quot;    return function() {&quot;,&quot;      // Prepend the bound arguments to the current arguments.&quot;,&quot;      var newArgs = Array.prototype.slice.call(arguments);&quot;,&quot;      Array.prototype.unshift.apply(newArgs, boundArgs);&quot;,&quot;      return fn.apply(selfObj, newArgs);&quot;,&quot;    };&quot;,null,&quot;  } else {&quot;,&quot;    return function() {&quot;,&quot;      return fn.apply(selfObj, arguments);&quot;,&quot;    };&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Partially applies this function to a particular &#39;this object&#39; and zero or&quot;,&quot; * more arguments. The result is a new function with some arguments of the first&quot;,&quot; * function pre-filled and the value of this &#39;pre-specified&#39;.&quot;,&quot; *&quot;,&quot; * Remaining arguments specified at call-time are appended to the pre-specified&quot;,&quot; * ones.&quot;,&quot; *&quot;,&quot; * Also see: {@link #partial}.&quot;,&quot; *&quot;,&quot; * Usage:&quot;,&quot; * &lt;pre&gt;var barMethBound = goog.bind(myFunction, myObj, &#39;arg1&#39;, &#39;arg2&#39;);&quot;,&quot; * barMethBound(&#39;arg3&#39;, &#39;arg4&#39;);&lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * @param {?function(this:T, ...)} fn A function to partially apply.&quot;,&quot; * @param {T} selfObj Specifies the object which this should point to when the&quot;,&quot; *     function is run.&quot;,&quot; * @param {...*} var_args Additional arguments that are partially applied to the&quot;,&quot; *     function.&quot;,&quot; * @return {!Function} A partially-applied form of the function goog.bind() was&quot;,&quot; *     invoked as a method of.&quot;,&quot; * @template T&quot;,&quot; * @suppress {deprecated} See above.&quot;,&quot; */&quot;,&quot;goog.bind = function(fn, selfObj, var_args) {&quot;,&quot;  // TODO(nicksantos): narrow the type signature.&quot;,&quot;  if (Function.prototype.bind &amp;&amp;&quot;,&quot;      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome&quot;,&quot;      // extension environment. This means that for Chrome extensions, they get&quot;,&quot;      // the implementation of Function.prototype.bind that calls goog.bind&quot;,&quot;      // instead of the native one. Even worse, we don&#39;t want to introduce a&quot;,&quot;      // circular dependency between goog.bind and Function.prototype.bind, so&quot;,&quot;      // we have to hack this to make sure it works correctly.&quot;,&quot;      Function.prototype.bind.toString().indexOf(&#39;native code&#39;) != -1) {&quot;,&quot;    goog.bind = goog.bindNative_;&quot;,&quot;  } else {&quot;,&quot;    goog.bind = goog.bindJs_;&quot;,&quot;  }&quot;,&quot;  return goog.bind.apply(null, arguments);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Like goog.bind(), except that a &#39;this object&#39; is not required. Useful when&quot;,&quot; * the target function is already bound.&quot;,&quot; *&quot;,&quot; * Usage:&quot;,&quot; * var g = goog.partial(f, arg1, arg2);&quot;,&quot; * g(arg3, arg4);&quot;,&quot; *&quot;,&quot; * @param {Function} fn A function to partially apply.&quot;,&quot; * @param {...*} var_args Additional arguments that are partially applied to fn.&quot;,&quot; * @return {!Function} A partially-applied form of the function goog.partial()&quot;,&quot; *     was invoked as a method of.&quot;,&quot; */&quot;,&quot;goog.partial = function(fn, var_args) {&quot;,&quot;  var args = Array.prototype.slice.call(arguments, 1);&quot;,&quot;  return function() {&quot;,&quot;    // Clone the array (with slice()) and append additional arguments&quot;,&quot;    // to the existing arguments.&quot;,&quot;    var newArgs = args.slice();&quot;,&quot;    newArgs.push.apply(newArgs, arguments);&quot;,&quot;    return fn.apply(this, newArgs);&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Copies all the members of a source object to a target object. This method&quot;,&quot; * does not work on all browsers for all objects that contain keys such as&quot;,&quot; * toString or hasOwnProperty. Use goog.object.extend for this purpose.&quot;,&quot; * @param {Object} target Target.&quot;,&quot; * @param {Object} source Source.&quot;,&quot; */&quot;,&quot;goog.mixin = function(target, source) {&quot;,&quot;  for (var x in source) {&quot;,&quot;    target[x] = source[x];&quot;,&quot;  }&quot;,null,&quot;  // For IE7 or lower, the for-in-loop does not contain any properties that are&quot;,&quot;  // not enumerable on the prototype object (for example, isPrototypeOf from&quot;,&quot;  // Object.prototype) but also it will not include &#39;replace&#39; on objects that&quot;,&quot;  // extend String and change &#39;replace&#39; (not that it is common for anyone to&quot;,&quot;  // extend anything except Object).&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {number} An integer value representing the number of milliseconds&quot;,&quot; *     between midnight, January 1, 1970 and the current time.&quot;,&quot; */&quot;,&quot;goog.now = (goog.TRUSTED_SITE &amp;&amp; Date.now) || (function() {&quot;,&quot;             // Unary plus operator converts its operand to a number which in&quot;,&quot;             // the case of&quot;,&quot;             // a date is done by calling getTime().&quot;,&quot;             return +new Date();&quot;,&quot;           });&quot;,null,null,&quot;/**&quot;,&quot; * Evals JavaScript in the global scope.  In IE this uses execScript, other&quot;,&quot; * browsers use goog.global.eval. If goog.global.eval does not evaluate in the&quot;,&quot; * global scope (for example, in Safari), appends a script tag instead.&quot;,&quot; * Throws an exception if neither execScript or eval is defined.&quot;,&quot; * @param {string} script JavaScript string.&quot;,&quot; */&quot;,&quot;goog.globalEval = function(script) {&quot;,&quot;  if (goog.global.execScript) {&quot;,&quot;    goog.global.execScript(script, &#39;JavaScript&#39;);&quot;,&quot;  } else if (goog.global.eval) {&quot;,&quot;    // Test to see if eval works&quot;,&quot;    if (goog.evalWorksForGlobals_ == null) {&quot;,&quot;      try {&quot;,&quot;        goog.global.eval(&#39;var _evalTest_ = 1;&#39;);&quot;,&quot;      } catch (ignore) {&quot;,&quot;      }&quot;,&quot;      if (typeof goog.global[&#39;_evalTest_&#39;] != &#39;undefined&#39;) {&quot;,&quot;        try {&quot;,&quot;          delete goog.global[&#39;_evalTest_&#39;];&quot;,&quot;        } catch (ignore) {&quot;,&quot;          // Microsoft edge fails the deletion above in strict mode.&quot;,&quot;        }&quot;,&quot;        goog.evalWorksForGlobals_ = true;&quot;,&quot;      } else {&quot;,&quot;        goog.evalWorksForGlobals_ = false;&quot;,&quot;      }&quot;,&quot;    }&quot;,null,&quot;    if (goog.evalWorksForGlobals_) {&quot;,&quot;      goog.global.eval(script);&quot;,&quot;    } else {&quot;,&quot;      /** @type {!Document} */&quot;,&quot;      var doc = goog.global.document;&quot;,&quot;      var scriptElt =&quot;,&quot;          /** @type {!HTMLScriptElement} */ (doc.createElement(&#39;SCRIPT&#39;));&quot;,&quot;      scriptElt.type = &#39;text/javascript&#39;;&quot;,&quot;      scriptElt.defer = false;&quot;,&quot;      // Note(user): can&#39;t use .innerHTML since \&quot;t(&#39;&lt;test&gt;&#39;)\&quot; will fail and&quot;,&quot;      // .text doesn&#39;t work in Safari 2.  Therefore we append a text node.&quot;,&quot;      scriptElt.appendChild(doc.createTextNode(script));&quot;,&quot;      doc.head.appendChild(scriptElt);&quot;,&quot;      doc.head.removeChild(scriptElt);&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    throw new Error(&#39;goog.globalEval not available&#39;);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Indicates whether or not we can call &#39;eval&#39; directly to eval code in the&quot;,&quot; * global scope. Set to a Boolean by the first call to goog.globalEval (which&quot;,&quot; * empirically tests whether eval works for globals). @see goog.globalEval&quot;,&quot; * @type {?boolean}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.evalWorksForGlobals_ = null;&quot;,null,null,&quot;/**&quot;,&quot; * Optional map of CSS class names to obfuscated names used with&quot;,&quot; * goog.getCssName().&quot;,&quot; * @private {!Object&lt;string, string&gt;|undefined}&quot;,&quot; * @see goog.setCssNameMapping&quot;,&quot; */&quot;,&quot;goog.cssNameMapping_;&quot;,null,null,&quot;/**&quot;,&quot; * Optional obfuscation style for CSS class names. Should be set to either&quot;,&quot; * &#39;BY_WHOLE&#39; or &#39;BY_PART&#39; if defined.&quot;,&quot; * @type {string|undefined}&quot;,&quot; * @private&quot;,&quot; * @see goog.setCssNameMapping&quot;,&quot; */&quot;,&quot;goog.cssNameMappingStyle_;&quot;,null,null,null,&quot;/**&quot;,&quot; * A hook for modifying the default behavior goog.getCssName. The function&quot;,&quot; * if present, will receive the standard output of the goog.getCssName as&quot;,&quot; * its input.&quot;,&quot; *&quot;,&quot; * @type {(function(string):string)|undefined}&quot;,&quot; */&quot;,&quot;goog.global.CLOSURE_CSS_NAME_MAP_FN;&quot;,null,null,&quot;/**&quot;,&quot; * Handles strings that are intended to be used as CSS class names.&quot;,&quot; *&quot;,&quot; * This function works in tandem with @see goog.setCssNameMapping.&quot;,&quot; *&quot;,&quot; * Without any mapping set, the arguments are simple joined with a hyphen and&quot;,&quot; * passed through unaltered.&quot;,&quot; *&quot;,&quot; * When there is a mapping, there are two possible styles in which these&quot;,&quot; * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)&quot;,&quot; * of the passed in css name is rewritten according to the map. In the BY_WHOLE&quot;,&quot; * style, the full css name is looked up in the map directly. If a rewrite is&quot;,&quot; * not specified by the map, the compiler will output a warning.&quot;,&quot; *&quot;,&quot; * When the mapping is passed to the compiler, it will replace calls to&quot;,&quot; * goog.getCssName with the strings from the mapping, e.g.&quot;,&quot; *     var x = goog.getCssName(&#39;foo&#39;);&quot;,&quot; *     var y = goog.getCssName(this.baseClass, &#39;active&#39;);&quot;,&quot; *  becomes:&quot;,&quot; *     var x = &#39;foo&#39;;&quot;,&quot; *     var y = this.baseClass + &#39;-active&#39;;&quot;,&quot; *&quot;,&quot; * If one argument is passed it will be processed, if two are passed only the&quot;,&quot; * modifier will be processed, as it is assumed the first argument was generated&quot;,&quot; * as a result of calling goog.getCssName.&quot;,&quot; *&quot;,&quot; * @param {string} className The class name.&quot;,&quot; * @param {string=} opt_modifier A modifier to be appended to the class name.&quot;,&quot; * @return {string} The class name or the concatenation of the class name and&quot;,&quot; *     the modifier.&quot;,&quot; */&quot;,&quot;goog.getCssName = function(className, opt_modifier) {&quot;,&quot;  // String() is used for compatibility with compiled soy where the passed&quot;,&quot;  // className can be non-string objects.&quot;,&quot;  if (String(className).charAt(0) == &#39;.&#39;) {&quot;,&quot;    throw new Error(&quot;,&quot;        &#39;className passed in goog.getCssName must not start with \&quot;.\&quot;.&#39; +&quot;,&quot;        &#39; You passed: &#39; + className);&quot;,&quot;  }&quot;,null,&quot;  var getMapping = function(cssName) {&quot;,&quot;    return goog.cssNameMapping_[cssName] || cssName;&quot;,&quot;  };&quot;,null,&quot;  var renameByParts = function(cssName) {&quot;,&quot;    // Remap all the parts individually.&quot;,&quot;    var parts = cssName.split(&#39;-&#39;);&quot;,&quot;    var mapped = [];&quot;,&quot;    for (var i = 0; i &lt; parts.length; i++) {&quot;,&quot;      mapped.push(getMapping(parts[i]));&quot;,&quot;    }&quot;,&quot;    return mapped.join(&#39;-&#39;);&quot;,&quot;  };&quot;,null,&quot;  var rename;&quot;,&quot;  if (goog.cssNameMapping_) {&quot;,&quot;    rename =&quot;,&quot;        goog.cssNameMappingStyle_ == &#39;BY_WHOLE&#39; ? getMapping : renameByParts;&quot;,&quot;  } else {&quot;,&quot;    rename = function(a) {&quot;,&quot;      return a;&quot;,&quot;    };&quot;,&quot;  }&quot;,null,&quot;  var result =&quot;,&quot;      opt_modifier ? className + &#39;-&#39; + rename(opt_modifier) : rename(className);&quot;,null,&quot;  // The special CLOSURE_CSS_NAME_MAP_FN allows users to specify further&quot;,&quot;  // processing of the class name.&quot;,&quot;  if (goog.global.CLOSURE_CSS_NAME_MAP_FN) {&quot;,&quot;    return goog.global.CLOSURE_CSS_NAME_MAP_FN(result);&quot;,&quot;  }&quot;,null,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the map to check when returning a value from goog.getCssName(). Example:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; * goog.setCssNameMapping({&quot;,&quot; *   \&quot;goog\&quot;: \&quot;a\&quot;,&quot;,&quot; *   \&quot;disabled\&quot;: \&quot;b\&quot;,&quot;,&quot; * });&quot;,&quot; *&quot;,&quot; * var x = goog.getCssName(&#39;goog&#39;);&quot;,&quot; * // The following evaluates to: \&quot;a a-b\&quot;.&quot;,&quot; * goog.getCssName(&#39;goog&#39;) + &#39; &#39; + goog.getCssName(x, &#39;disabled&#39;)&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; * When declared as a map of string literals to string literals, the JSCompiler&quot;,&quot; * will replace all calls to goog.getCssName() using the supplied map if the&quot;,&quot; * --process_closure_primitives flag is set.&quot;,&quot; *&quot;,&quot; * @param {!Object} mapping A map of strings to strings where keys are possible&quot;,&quot; *     arguments to goog.getCssName() and values are the corresponding values&quot;,&quot; *     that should be returned.&quot;,&quot; * @param {string=} opt_style The style of css name mapping. There are two valid&quot;,&quot; *     options: &#39;BY_PART&#39;, and &#39;BY_WHOLE&#39;.&quot;,&quot; * @see goog.getCssName for a description.&quot;,&quot; */&quot;,&quot;goog.setCssNameMapping = function(mapping, opt_style) {&quot;,&quot;  goog.cssNameMapping_ = mapping;&quot;,&quot;  goog.cssNameMappingStyle_ = opt_style;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * To use CSS renaming in compiled mode, one of the input files should have a&quot;,&quot; * call to goog.setCssNameMapping() with an object literal that the JSCompiler&quot;,&quot; * can extract and use to replace all calls to goog.getCssName(). In uncompiled&quot;,&quot; * mode, JavaScript code should be loaded before this base.js file that declares&quot;,&quot; * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is&quot;,&quot; * to ensure that the mapping is loaded before any calls to goog.getCssName()&quot;,&quot; * are made in uncompiled mode.&quot;,&quot; *&quot;,&quot; * A hook for overriding the CSS name mapping.&quot;,&quot; * @type {!Object&lt;string, string&gt;|undefined}&quot;,&quot; */&quot;,&quot;goog.global.CLOSURE_CSS_NAME_MAPPING;&quot;,null,null,&quot;if (!COMPILED &amp;&amp; goog.global.CLOSURE_CSS_NAME_MAPPING) {&quot;,&quot;  // This does not call goog.setCssNameMapping() because the JSCompiler&quot;,&quot;  // requires that goog.setCssNameMapping() be called with an object literal.&quot;,&quot;  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;&quot;,&quot;}&quot;,null,null,&quot;/**&quot;,&quot; * Gets a localized message.&quot;,&quot; *&quot;,&quot; * This function is a compiler primitive. If you give the compiler a localized&quot;,&quot; * message bundle, it will replace the string at compile-time with a localized&quot;,&quot; * version, and expand goog.getMsg call to a concatenated string.&quot;,&quot; *&quot;,&quot; * Messages must be initialized in the form:&quot;,&quot; * &lt;code&gt;&quot;,&quot; * var MSG_NAME = goog.getMsg(&#39;Hello {$placeholder}&#39;, {&#39;placeholder&#39;: &#39;world&#39;});&quot;,&quot; * &lt;/code&gt;&quot;,&quot; *&quot;,&quot; * This function produces a string which should be treated as plain text. Use&quot;,&quot; * {@link goog.html.SafeHtmlFormatter} in conjunction with goog.getMsg to&quot;,&quot; * produce SafeHtml.&quot;,&quot; *&quot;,&quot; * @param {string} str Translatable string, places holders in the form {$foo}.&quot;,&quot; * @param {Object&lt;string, string&gt;=} opt_values Maps place holder name to value.&quot;,&quot; * @return {string} message with placeholders filled.&quot;,&quot; */&quot;,&quot;goog.getMsg = function(str, opt_values) {&quot;,&quot;  if (opt_values) {&quot;,&quot;    str = str.replace(/\\{\\$([^}]+)}/g, function(match, key) {&quot;,&quot;      return (opt_values != null &amp;&amp; key in opt_values) ? opt_values[key] :&quot;,&quot;                                                         match;&quot;,&quot;    });&quot;,&quot;  }&quot;,&quot;  return str;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets a localized message. If the message does not have a translation, gives a&quot;,&quot; * fallback message.&quot;,&quot; *&quot;,&quot; * This is useful when introducing a new message that has not yet been&quot;,&quot; * translated into all languages.&quot;,&quot; *&quot;,&quot; * This function is a compiler primitive. Must be used in the form:&quot;,&quot; * &lt;code&gt;var x = goog.getMsgWithFallback(MSG_A, MSG_B);&lt;/code&gt;&quot;,&quot; * where MSG_A and MSG_B were initialized with goog.getMsg.&quot;,&quot; *&quot;,&quot; * @param {string} a The preferred message.&quot;,&quot; * @param {string} b The fallback message.&quot;,&quot; * @return {string} The best translated message.&quot;,&quot; */&quot;,&quot;goog.getMsgWithFallback = function(a, b) {&quot;,&quot;  return a;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Exposes an unobfuscated global namespace path for the given object.&quot;,&quot; * Note that fields of the exported object *will* be obfuscated, unless they are&quot;,&quot; * exported in turn via this function or goog.exportProperty.&quot;,&quot; *&quot;,&quot; * Also handy for making public items that are defined in anonymous closures.&quot;,&quot; *&quot;,&quot; * ex. goog.exportSymbol(&#39;public.path.Foo&#39;, Foo);&quot;,&quot; *&quot;,&quot; * ex. goog.exportSymbol(&#39;public.path.Foo.staticFunction&#39;, Foo.staticFunction);&quot;,&quot; *     public.path.Foo.staticFunction();&quot;,&quot; *&quot;,&quot; * ex. goog.exportSymbol(&#39;public.path.Foo.prototype.myMethod&#39;,&quot;,&quot; *                       Foo.prototype.myMethod);&quot;,&quot; *     new public.path.Foo().myMethod();&quot;,&quot; *&quot;,&quot; * @param {string} publicPath Unobfuscated name to export.&quot;,&quot; * @param {*} object Object the name should point to.&quot;,&quot; * @param {Object=} opt_objectToExportTo The object to add the path to; default&quot;,&quot; *     is goog.global.&quot;,&quot; */&quot;,&quot;goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {&quot;,&quot;  goog.exportPath_(publicPath, object, opt_objectToExportTo);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Exports a property unobfuscated into the object&#39;s namespace.&quot;,&quot; * ex. goog.exportProperty(Foo, &#39;staticFunction&#39;, Foo.staticFunction);&quot;,&quot; * ex. goog.exportProperty(Foo.prototype, &#39;myMethod&#39;, Foo.prototype.myMethod);&quot;,&quot; * @param {Object} object Object whose static property is being exported.&quot;,&quot; * @param {string} publicName Unobfuscated name to export.&quot;,&quot; * @param {*} symbol Object the name should point to.&quot;,&quot; */&quot;,&quot;goog.exportProperty = function(object, publicName, symbol) {&quot;,&quot;  object[publicName] = symbol;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Inherit the prototype methods from one constructor into another.&quot;,&quot; *&quot;,&quot; * Usage:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; * function ParentClass(a, b) { }&quot;,&quot; * ParentClass.prototype.foo = function(a) { };&quot;,&quot; *&quot;,&quot; * function ChildClass(a, b, c) {&quot;,&quot; *   ChildClass.base(this, &#39;constructor&#39;, a, b);&quot;,&quot; * }&quot;,&quot; * goog.inherits(ChildClass, ParentClass);&quot;,&quot; *&quot;,&quot; * var child = new ChildClass(&#39;a&#39;, &#39;b&#39;, &#39;see&#39;);&quot;,&quot; * child.foo(); // This works.&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * @param {!Function} childCtor Child class.&quot;,&quot; * @param {!Function} parentCtor Parent class.&quot;,&quot; */&quot;,&quot;goog.inherits = function(childCtor, parentCtor) {&quot;,&quot;  /** @constructor */&quot;,&quot;  function tempCtor() {}&quot;,&quot;  tempCtor.prototype = parentCtor.prototype;&quot;,&quot;  childCtor.superClass_ = parentCtor.prototype;&quot;,&quot;  childCtor.prototype = new tempCtor();&quot;,&quot;  /** @override */&quot;,&quot;  childCtor.prototype.constructor = childCtor;&quot;,null,&quot;  /**&quot;,&quot;   * Calls superclass constructor/method.&quot;,&quot;   *&quot;,&quot;   * This function is only available if you use goog.inherits to&quot;,&quot;   * express inheritance relationships between classes.&quot;,&quot;   *&quot;,&quot;   * NOTE: This is a replacement for goog.base and for superClass_&quot;,&quot;   * property defined in childCtor.&quot;,&quot;   *&quot;,&quot;   * @param {!Object} me Should always be \&quot;this\&quot;.&quot;,&quot;   * @param {string} methodName The method name to call. Calling&quot;,&quot;   *     superclass constructor can be done with the special string&quot;,&quot;   *     &#39;constructor&#39;.&quot;,&quot;   * @param {...*} var_args The arguments to pass to superclass&quot;,&quot;   *     method/constructor.&quot;,&quot;   * @return {*} The return value of the superclass method/constructor.&quot;,&quot;   */&quot;,&quot;  childCtor.base = function(me, methodName, var_args) {&quot;,&quot;    // Copying using loop to avoid deop due to passing arguments object to&quot;,&quot;    // function. This is faster in many JS engines as of late 2014.&quot;,&quot;    var args = new Array(arguments.length - 2);&quot;,&quot;    for (var i = 2; i &lt; arguments.length; i++) {&quot;,&quot;      args[i - 2] = arguments[i];&quot;,&quot;    }&quot;,&quot;    return parentCtor.prototype[methodName].apply(me, args);&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Call up to the superclass.&quot;,&quot; *&quot;,&quot; * If this is called from a constructor, then this calls the superclass&quot;,&quot; * constructor with arguments 1-N.&quot;,&quot; *&quot;,&quot; * If this is called from a prototype method, then you must pass the name of the&quot;,&quot; * method as the second argument to this function. If you do not, you will get a&quot;,&quot; * runtime error. This calls the superclass&#39; method with arguments 2-N.&quot;,&quot; *&quot;,&quot; * This function only works if you use goog.inherits to express inheritance&quot;,&quot; * relationships between your classes.&quot;,&quot; *&quot;,&quot; * This function is a compiler primitive. At compile-time, the compiler will do&quot;,&quot; * macro expansion to remove a lot of the extra overhead that this function&quot;,&quot; * introduces. The compiler will also enforce a lot of the assumptions that this&quot;,&quot; * function makes, and treat it as a compiler error if you break them.&quot;,&quot; *&quot;,&quot; * @param {!Object} me Should always be \&quot;this\&quot;.&quot;,&quot; * @param {*=} opt_methodName The method name if calling a super method.&quot;,&quot; * @param {...*} var_args The rest of the arguments.&quot;,&quot; * @return {*} The return value of the superclass method.&quot;,&quot; * @suppress {es5Strict} This method can not be used in strict mode, but&quot;,&quot; *     all Closure Library consumers must depend on this file.&quot;,&quot; * @deprecated goog.base is not strict mode compatible.  Prefer the static&quot;,&quot; *     \&quot;base\&quot; method added to the constructor by goog.inherits&quot;,&quot; *     or ES6 classes and the \&quot;super\&quot; keyword.&quot;,&quot; */&quot;,&quot;goog.base = function(me, opt_methodName, var_args) {&quot;,&quot;  var caller = arguments.callee.caller;&quot;,null,&quot;  if (goog.STRICT_MODE_COMPATIBLE || (goog.DEBUG &amp;&amp; !caller)) {&quot;,&quot;    throw new Error(&quot;,&quot;        &#39;arguments.caller not defined.  goog.base() cannot be used &#39; +&quot;,&quot;        &#39;with strict mode code. See &#39; +&quot;,&quot;        &#39;http://www.ecma-international.org/ecma-262/5.1/#sec-C&#39;);&quot;,&quot;  }&quot;,null,&quot;  if (caller.superClass_) {&quot;,&quot;    // Copying using loop to avoid deop due to passing arguments object to&quot;,&quot;    // function. This is faster in many JS engines as of late 2014.&quot;,&quot;    var ctorArgs = new Array(arguments.length - 1);&quot;,&quot;    for (var i = 1; i &lt; arguments.length; i++) {&quot;,&quot;      ctorArgs[i - 1] = arguments[i];&quot;,&quot;    }&quot;,&quot;    // This is a constructor. Call the superclass constructor.&quot;,&quot;    return caller.superClass_.constructor.apply(me, ctorArgs);&quot;,&quot;  }&quot;,null,&quot;  // Copying using loop to avoid deop due to passing arguments object to&quot;,&quot;  // function. This is faster in many JS engines as of late 2014.&quot;,&quot;  var args = new Array(arguments.length - 2);&quot;,&quot;  for (var i = 2; i &lt; arguments.length; i++) {&quot;,&quot;    args[i - 2] = arguments[i];&quot;,&quot;  }&quot;,&quot;  var foundCaller = false;&quot;,&quot;  for (var ctor = me.constructor; ctor;&quot;,&quot;       ctor = ctor.superClass_ &amp;&amp; ctor.superClass_.constructor) {&quot;,&quot;    if (ctor.prototype[opt_methodName] === caller) {&quot;,&quot;      foundCaller = true;&quot;,&quot;    } else if (foundCaller) {&quot;,&quot;      return ctor.prototype[opt_methodName].apply(me, args);&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // If we did not find the caller in the prototype chain, then one of two&quot;,&quot;  // things happened:&quot;,&quot;  // 1) The caller is an instance method.&quot;,&quot;  // 2) This method was not called by the right caller.&quot;,&quot;  if (me[opt_methodName] === caller) {&quot;,&quot;    return me.constructor.prototype[opt_methodName].apply(me, args);&quot;,&quot;  } else {&quot;,&quot;    throw new Error(&quot;,&quot;        &#39;goog.base called from a method of one name &#39; +&quot;,&quot;        &#39;to a method of a different name&#39;);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Allow for aliasing within scope functions.  This function exists for&quot;,&quot; * uncompiled code - in compiled code the calls will be inlined and the aliases&quot;,&quot; * applied.  In uncompiled code the function is simply run since the aliases as&quot;,&quot; * written are valid JavaScript.&quot;,&quot; *&quot;,&quot; *&quot;,&quot; * @param {function()} fn Function to call.  This function can contain aliases&quot;,&quot; *     to namespaces (e.g. \&quot;var dom = goog.dom\&quot;) or classes&quot;,&quot; *     (e.g. \&quot;var Timer = goog.Timer\&quot;).&quot;,&quot; */&quot;,&quot;goog.scope = function(fn) {&quot;,&quot;  if (goog.isInModuleLoader_()) {&quot;,&quot;    throw new Error(&#39;goog.scope is not supported within a goog.module.&#39;);&quot;,&quot;  }&quot;,&quot;  fn.call(goog.global);&quot;,&quot;};&quot;,null,null,&quot;/*&quot;,&quot; * To support uncompiled, strict mode bundles that use eval to divide source&quot;,&quot; * like so:&quot;,&quot; *    eval(&#39;someSource;//# sourceUrl sourcefile.js&#39;);&quot;,&quot; * We need to export the globally defined symbols \&quot;goog\&quot; and \&quot;COMPILED\&quot;.&quot;,&quot; * Exporting \&quot;goog\&quot; breaks the compiler optimizations, so we required that&quot;,&quot; * be defined externally.&quot;,&quot; * NOTE: We don&#39;t use goog.exportSymbol here because we don&#39;t want to trigger&quot;,&quot; * extern generation when that compiler option is enabled.&quot;,&quot; */&quot;,&quot;if (!COMPILED) {&quot;,&quot;  goog.global[&#39;COMPILED&#39;] = COMPILED;&quot;,&quot;}&quot;,null,null,&quot;//==============================================================================&quot;,&quot;// goog.defineClass implementation&quot;,&quot;//==============================================================================&quot;,null,null,&quot;/**&quot;,&quot; * Creates a restricted form of a Closure \&quot;class\&quot;:&quot;,&quot; *   - from the compiler&#39;s perspective, the instance returned from the&quot;,&quot; *     constructor is sealed (no new properties may be added).  This enables&quot;,&quot; *     better checks.&quot;,&quot; *   - the compiler will rewrite this definition to a form that is optimal&quot;,&quot; *     for type checking and optimization (initially this will be a more&quot;,&quot; *     traditional form).&quot;,&quot; *&quot;,&quot; * @param {Function} superClass The superclass, Object or null.&quot;,&quot; * @param {goog.defineClass.ClassDescriptor} def&quot;,&quot; *     An object literal describing&quot;,&quot; *     the class.  It may have the following properties:&quot;,&quot; *     \&quot;constructor\&quot;: the constructor function&quot;,&quot; *     \&quot;statics\&quot;: an object literal containing methods to add to the constructor&quot;,&quot; *        as \&quot;static\&quot; methods or a function that will receive the constructor&quot;,&quot; *        function as its only parameter to which static properties can&quot;,&quot; *        be added.&quot;,&quot; *     all other properties are added to the prototype.&quot;,&quot; * @return {!Function} The class constructor.&quot;,&quot; */&quot;,&quot;goog.defineClass = function(superClass, def) {&quot;,&quot;  // TODO(johnlenz): consider making the superClass an optional parameter.&quot;,&quot;  var constructor = def.constructor;&quot;,&quot;  var statics = def.statics;&quot;,&quot;  // Wrap the constructor prior to setting up the prototype and static methods.&quot;,&quot;  if (!constructor || constructor == Object.prototype.constructor) {&quot;,&quot;    constructor = function() {&quot;,&quot;      throw new Error(&quot;,&quot;          &#39;cannot instantiate an interface (no constructor defined).&#39;);&quot;,&quot;    };&quot;,&quot;  }&quot;,null,&quot;  var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);&quot;,&quot;  if (superClass) {&quot;,&quot;    goog.inherits(cls, superClass);&quot;,&quot;  }&quot;,null,&quot;  // Remove all the properties that should not be copied to the prototype.&quot;,&quot;  delete def.constructor;&quot;,&quot;  delete def.statics;&quot;,null,&quot;  goog.defineClass.applyProperties_(cls.prototype, def);&quot;,&quot;  if (statics != null) {&quot;,&quot;    if (statics instanceof Function) {&quot;,&quot;      statics(cls);&quot;,&quot;    } else {&quot;,&quot;      goog.defineClass.applyProperties_(cls, statics);&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  return cls;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @typedef {{&quot;,&quot; *   constructor: (!Function|undefined),&quot;,&quot; *   statics: (Object|undefined|function(Function):void)&quot;,&quot; * }}&quot;,&quot; */&quot;,&quot;goog.defineClass.ClassDescriptor;&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether the instances returned by goog.defineClass should&quot;,&quot; *     be sealed when possible.&quot;,&quot; *&quot;,&quot; * When sealing is disabled the constructor function will not be wrapped by&quot;,&quot; * goog.defineClass, making it incompatible with ES6 class methods.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.defineClass.SEAL_CLASS_INSTANCES&#39;, goog.DEBUG);&quot;,null,null,&quot;/**&quot;,&quot; * If goog.defineClass.SEAL_CLASS_INSTANCES is enabled and Object.seal is&quot;,&quot; * defined, this function will wrap the constructor in a function that seals the&quot;,&quot; * results of the provided constructor function.&quot;,&quot; *&quot;,&quot; * @param {!Function} ctr The constructor whose results maybe be sealed.&quot;,&quot; * @param {Function} superClass The superclass constructor.&quot;,&quot; * @return {!Function} The replacement constructor.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.defineClass.createSealingConstructor_ = function(ctr, superClass) {&quot;,&quot;  if (!goog.defineClass.SEAL_CLASS_INSTANCES) {&quot;,&quot;    // Do now wrap the constructor when sealing is disabled. Angular code&quot;,&quot;    // depends on this for injection to work properly.&quot;,&quot;    return ctr;&quot;,&quot;  }&quot;,null,&quot;  // Compute whether the constructor is sealable at definition time, rather&quot;,&quot;  // than when the instance is being constructed.&quot;,&quot;  var superclassSealable = !goog.defineClass.isUnsealable_(superClass);&quot;,null,&quot;  /**&quot;,&quot;   * @this {Object}&quot;,&quot;   * @return {?}&quot;,&quot;   */&quot;,&quot;  var wrappedCtr = function() {&quot;,&quot;    // Don&#39;t seal an instance of a subclass when it calls the constructor of&quot;,&quot;    // its super class as there is most likely still setup to do.&quot;,&quot;    var instance = ctr.apply(this, arguments) || this;&quot;,&quot;    instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];&quot;,null,&quot;    if (this.constructor === wrappedCtr &amp;&amp; superclassSealable &amp;&amp;&quot;,&quot;        Object.seal instanceof Function) {&quot;,&quot;      Object.seal(instance);&quot;,&quot;    }&quot;,&quot;    return instance;&quot;,&quot;  };&quot;,null,&quot;  return wrappedCtr;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {Function} ctr The constructor to test.&quot;,&quot; * @return {boolean} Whether the constructor has been tagged as unsealable&quot;,&quot; *     using goog.tagUnsealableClass.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.defineClass.isUnsealable_ = function(ctr) {&quot;,&quot;  return ctr &amp;&amp; ctr.prototype &amp;&amp;&quot;,&quot;      ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];&quot;,&quot;};&quot;,null,null,&quot;// TODO(johnlenz): share these values with the goog.object&quot;,&quot;/**&quot;,&quot; * The names of the fields that are defined on Object.prototype.&quot;,&quot; * @type {!Array&lt;string&gt;}&quot;,&quot; * @private&quot;,&quot; * @const&quot;,&quot; */&quot;,&quot;goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = [&quot;,&quot;  &#39;constructor&#39;, &#39;hasOwnProperty&#39;, &#39;isPrototypeOf&#39;, &#39;propertyIsEnumerable&#39;,&quot;,&quot;  &#39;toLocaleString&#39;, &#39;toString&#39;, &#39;valueOf&#39;&quot;,&quot;];&quot;,null,null,&quot;// TODO(johnlenz): share this function with the goog.object&quot;,&quot;/**&quot;,&quot; * @param {!Object} target The object to add properties to.&quot;,&quot; * @param {!Object} source The object to copy properties from.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.defineClass.applyProperties_ = function(target, source) {&quot;,&quot;  // TODO(johnlenz): update this to support ES5 getters/setters&quot;,null,&quot;  var key;&quot;,&quot;  for (key in source) {&quot;,&quot;    if (Object.prototype.hasOwnProperty.call(source, key)) {&quot;,&quot;      target[key] = source[key];&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // For IE the for-in-loop does not contain any properties that are not&quot;,&quot;  // enumerable on the prototype object (for example isPrototypeOf from&quot;,&quot;  // Object.prototype) and it will also not include &#39;replace&#39; on objects that&quot;,&quot;  // extend String and change &#39;replace&#39; (not that it is common for anyone to&quot;,&quot;  // extend anything except Object).&quot;,&quot;  for (var i = 0; i &lt; goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {&quot;,&quot;    key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];&quot;,&quot;    if (Object.prototype.hasOwnProperty.call(source, key)) {&quot;,&quot;      target[key] = source[key];&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sealing classes breaks the older idiom of assigning properties on the&quot;,&quot; * prototype rather than in the constructor. As such, goog.defineClass&quot;,&quot; * must not seal subclasses of these old-style classes until they are fixed.&quot;,&quot; * Until then, this marks a class as \&quot;broken\&quot;, instructing defineClass&quot;,&quot; * not to seal subclasses.&quot;,&quot; * @param {!Function} ctr The legacy constructor to tag as unsealable.&quot;,&quot; */&quot;,&quot;goog.tagUnsealableClass = function(ctr) {&quot;,&quot;  if (!COMPILED &amp;&amp; goog.defineClass.SEAL_CLASS_INSTANCES) {&quot;,&quot;    ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Name for unsealable tag property.&quot;,&quot; * @const @private {string}&quot;,&quot; */&quot;,&quot;goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = &#39;goog_defineClass_legacy_unsealable&#39;;&quot;,null,null,null,&quot;if (goog.DEPENDENCIES_ENABLED) {&quot;,&quot;  /**&quot;,&quot;   * Tries to detect whether is in the context of an HTML document.&quot;,&quot;   * @return {boolean} True if it looks like HTML document.&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.inHtmlDocument_ = function() {&quot;,&quot;    /** @type {!Document} */&quot;,&quot;    var doc = goog.global.document;&quot;,&quot;    return doc != null &amp;&amp; &#39;write&#39; in doc;  // XULDocument misses write.&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * Tries to detect the base path of base.js script that bootstraps Closure.&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.findBasePath_ = function() {&quot;,&quot;    if (goog.isDef(goog.global.CLOSURE_BASE_PATH) &amp;&amp;&quot;,&quot;        // Anti DOM-clobbering runtime check (b/37736576).&quot;,&quot;        goog.isString(goog.global.CLOSURE_BASE_PATH)) {&quot;,&quot;      goog.basePath = goog.global.CLOSURE_BASE_PATH;&quot;,&quot;      return;&quot;,&quot;    } else if (!goog.inHtmlDocument_()) {&quot;,&quot;      return;&quot;,&quot;    }&quot;,&quot;    /** @type {!Document} */&quot;,&quot;    var doc = goog.global.document;&quot;,&quot;    // If we have a currentScript available, use it exclusively.&quot;,&quot;    var currentScript = doc.currentScript;&quot;,&quot;    if (currentScript) {&quot;,&quot;      var scripts = [currentScript];&quot;,&quot;    } else {&quot;,&quot;      var scripts = doc.getElementsByTagName(&#39;SCRIPT&#39;);&quot;,&quot;    }&quot;,&quot;    // Search backwards since the current script is in almost all cases the one&quot;,&quot;    // that has base.js.&quot;,&quot;    for (var i = scripts.length - 1; i &gt;= 0; --i) {&quot;,&quot;      var script = /** @type {!HTMLScriptElement} */ (scripts[i]);&quot;,&quot;      var src = script.src;&quot;,&quot;      var qmark = src.lastIndexOf(&#39;?&#39;);&quot;,&quot;      var l = qmark == -1 ? src.length : qmark;&quot;,&quot;      if (src.substr(l - 7, 7) == &#39;base.js&#39;) {&quot;,&quot;        goog.basePath = src.substr(0, l - 7);&quot;,&quot;        return;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  };&quot;,null,&quot;  goog.findBasePath_();&quot;,null,&quot;  /** @struct @constructor @final */&quot;,&quot;  goog.Transpiler = function() {&quot;,&quot;    /** @private {?Object&lt;string, boolean&gt;} */&quot;,&quot;    this.requiresTranspilation_ = null;&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * Returns a newly created map from language mode string to a boolean&quot;,&quot;   * indicating whether transpilation should be done for that mode.&quot;,&quot;   *&quot;,&quot;   * Guaranteed invariant:&quot;,&quot;   * For any two modes, l1 and l2 where l2 is a newer mode than l1,&quot;,&quot;   * `map[l1] == true` implies that `map[l2] == true`.&quot;,&quot;   *&quot;,&quot;   * Note this method is extracted and used elsewhere, so it cannot rely on&quot;,&quot;   * anything external (it should easily be able to be transformed into a&quot;,&quot;   * standalone, top level function).&quot;,&quot;   *&quot;,&quot;   * @private&quot;,&quot;   * @return {!Object&lt;string, boolean&gt;}&quot;,&quot;   */&quot;,&quot;  goog.Transpiler.prototype.createRequiresTranspilation_ = function() {&quot;,&quot;    var /** !Object&lt;string, boolean&gt; */ requiresTranspilation = {&#39;es3&#39;: false};&quot;,&quot;    var transpilationRequiredForAllLaterModes = false;&quot;,null,&quot;    /**&quot;,&quot;     * Adds an entry to requiresTranspliation for the given language mode.&quot;,&quot;     *&quot;,&quot;     * IMPORTANT: Calls must be made in order from oldest to newest language&quot;,&quot;     * mode.&quot;,&quot;     * @param {string} modeName&quot;,&quot;     * @param {function(): boolean} isSupported Returns true if the JS engine&quot;,&quot;     *     supports the given mode.&quot;,&quot;     */&quot;,&quot;    function addNewerLanguageTranspilationCheck(modeName, isSupported) {&quot;,&quot;      if (transpilationRequiredForAllLaterModes) {&quot;,&quot;        requiresTranspilation[modeName] = true;&quot;,&quot;      } else if (isSupported()) {&quot;,&quot;        requiresTranspilation[modeName] = false;&quot;,&quot;      } else {&quot;,&quot;        requiresTranspilation[modeName] = true;&quot;,&quot;        transpilationRequiredForAllLaterModes = true;&quot;,&quot;      }&quot;,&quot;    }&quot;,null,&quot;    /**&quot;,&quot;     * Does the given code evaluate without syntax errors and return a truthy&quot;,&quot;     * result?&quot;,&quot;     */&quot;,&quot;    function /** boolean */ evalCheck(/** string */ code) {&quot;,&quot;      try {&quot;,&quot;        return !!eval(code);&quot;,&quot;      } catch (ignored) {&quot;,&quot;        return false;&quot;,&quot;      }&quot;,&quot;    }&quot;,null,&quot;    var userAgent = goog.global.navigator &amp;&amp; goog.global.navigator.userAgent ?&quot;,&quot;        goog.global.navigator.userAgent :&quot;,&quot;        &#39;&#39;;&quot;,null,&quot;    // Identify ES3-only browsers by their incorrect treatment of commas.&quot;,&quot;    addNewerLanguageTranspilationCheck(&#39;es5&#39;, function() {&quot;,&quot;      return evalCheck(&#39;[1,].length==1&#39;);&quot;,&quot;    });&quot;,&quot;    addNewerLanguageTranspilationCheck(&#39;es6&#39;, function() {&quot;,&quot;      // Edge has a non-deterministic (i.e., not reproducible) bug with ES6:&quot;,&quot;      // https://github.com/Microsoft/ChakraCore/issues/1496.&quot;,&quot;      var re = /Edge\\/(\\d+)(\\.\\d)*/i;&quot;,&quot;      var edgeUserAgent = userAgent.match(re);&quot;,&quot;      if (edgeUserAgent &amp;&amp; Number(edgeUserAgent[1]) &lt; 15) {&quot;,&quot;        return false;&quot;,&quot;      }&quot;,&quot;      // Test es6: [FF50 (?), Edge 14 (?), Chrome 50]&quot;,&quot;      //   (a) default params (specifically shadowing locals),&quot;,&quot;      //   (b) destructuring, (c) block-scoped functions,&quot;,&quot;      //   (d) for-of (const), (e) new.target/Reflect.construct&quot;,&quot;      var es6fullTest =&quot;,&quot;          &#39;class X{constructor(){if(new.target!=String)throw 1;this.x=42}}&#39; +&quot;,&quot;          &#39;let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof &#39; +&quot;,&quot;          &#39;String))throw 1;for(const a of[2,3]){if(a==2)continue;function &#39; +&quot;,&quot;          &#39;f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()&#39; +&quot;,&quot;          &#39;==3}&#39;;&quot;,null,&quot;      return evalCheck(&#39;(()=&gt;{\&quot;use strict\&quot;;&#39; + es6fullTest + &#39;})()&#39;);&quot;,&quot;    });&quot;,&quot;    // TODO(joeltine): Remove es6-impl references for b/31340605.&quot;,&quot;    // Consider es6-impl (widely-implemented es6 features) to be supported&quot;,&quot;    // whenever es6 is supported. Technically es6-impl is a lower level of&quot;,&quot;    // support than es6, but we don&#39;t have tests specifically for it.&quot;,&quot;    addNewerLanguageTranspilationCheck(&#39;es6-impl&#39;, function() {&quot;,&quot;      return true;&quot;,&quot;    });&quot;,&quot;    // ** and **= are the only new features in &#39;es7&#39;&quot;,&quot;    addNewerLanguageTranspilationCheck(&#39;es7&#39;, function() {&quot;,&quot;      return evalCheck(&#39;2 ** 2 == 4&#39;);&quot;,&quot;    });&quot;,&quot;    // async functions are the only new features in &#39;es8&#39;&quot;,&quot;    addNewerLanguageTranspilationCheck(&#39;es8&#39;, function() {&quot;,&quot;      return evalCheck(&#39;async () =&gt; 1, true&#39;);&quot;,&quot;    });&quot;,&quot;    return requiresTranspilation;&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * Determines whether the given language needs to be transpiled.&quot;,&quot;   * @param {string} lang&quot;,&quot;   * @return {boolean}&quot;,&quot;   */&quot;,&quot;  goog.Transpiler.prototype.needsTranspile = function(lang) {&quot;,&quot;    if (goog.TRANSPILE == &#39;always&#39;) {&quot;,&quot;      return true;&quot;,&quot;    } else if (goog.TRANSPILE == &#39;never&#39;) {&quot;,&quot;      return false;&quot;,&quot;    } else if (!this.requiresTranspilation_) {&quot;,&quot;      this.requiresTranspilation_ = this.createRequiresTranspilation_();&quot;,&quot;    }&quot;,&quot;    if (lang in this.requiresTranspilation_) {&quot;,&quot;      return this.requiresTranspilation_[lang];&quot;,&quot;    } else {&quot;,&quot;      throw new Error(&#39;Unknown language mode: &#39; + lang);&quot;,&quot;    }&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * Lazily retrieves the transpiler and applies it to the source.&quot;,&quot;   * @param {string} code JS code.&quot;,&quot;   * @param {string} path Path to the code.&quot;,&quot;   * @return {string} The transpiled code.&quot;,&quot;   */&quot;,&quot;  goog.Transpiler.prototype.transpile = function(code, path) {&quot;,&quot;    // TODO(user): We should delete goog.transpile_ and just have this&quot;,&quot;    // function. But there&#39;s some compile error atm where goog.global is being&quot;,&quot;    // stripped incorrectly without this.&quot;,&quot;    return goog.transpile_(code, path);&quot;,&quot;  };&quot;,null,null,&quot;  /** @private @final {!goog.Transpiler} */&quot;,&quot;  goog.transpiler_ = new goog.Transpiler();&quot;,null,null,&quot;  /**&quot;,&quot;   * A debug loader is responsible for downloading and executing javascript&quot;,&quot;   * files in an unbundled, uncompiled environment.&quot;,&quot;   *&quot;,&quot;   * @struct @constructor&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader = function() {&quot;,&quot;    /**&quot;,&quot;     * This object is used to keep track of dependencies and other data that is&quot;,&quot;     * used for loading scripts.&quot;,&quot;     * @private&quot;,&quot;     * @type {{&quot;,&quot;     *   loadFlags: !Object&lt;string, !Object&lt;string, string&gt;&gt;,&quot;,&quot;     *   nameToPath: !Object&lt;string, string&gt;,&quot;,&quot;     *   requires: !Object&lt;string, !Object&lt;string, boolean&gt;&gt;,&quot;,&quot;     *   visited: !Object&lt;string, boolean&gt;,&quot;,&quot;     *   written: !Object&lt;string, boolean&gt;,&quot;,&quot;     *   deferred: !Object&lt;string, string&gt;&quot;,&quot;     * }}&quot;,&quot;     */&quot;,&quot;    this.dependencies_ = {&quot;,&quot;      loadFlags: {},  // 1 to 1&quot;,null,&quot;      nameToPath: {},  // 1 to 1&quot;,null,&quot;      requires: {},  // 1 to many&quot;,null,&quot;      // Used when resolving dependencies to prevent us from visiting file&quot;,&quot;      // twice.&quot;,&quot;      visited: {},&quot;,null,&quot;      written: {},  // Used to keep track of script files we have written.&quot;,null,&quot;      deferred: {}  // Used to track deferred module evaluations in old IEs&quot;,&quot;    };&quot;,null,&quot;    /**&quot;,&quot;     * Whether IE9 or earlier is waiting on a dependency.  This ensures that&quot;,&quot;     * deferred modules that have no non-deferred dependencies actually get&quot;,&quot;     * loaded, since if we defer them and then never pull in a non-deferred&quot;,&quot;     * script, then `this.loadQueuedModules_` will never be called.  Instead,&quot;,&quot;     * if not waiting on anything we simply don&#39;t defer in the first place.&quot;,&quot;     * @private {boolean}&quot;,&quot;     */&quot;,&quot;    this.oldIeWaiting_ = false;&quot;,null,&quot;    /** @private {!Array&lt;string&gt;} */&quot;,&quot;    this.queuedModules_ = [];&quot;,null,&quot;    /** @private {number} */&quot;,&quot;    this.lastNonModuleScriptIndex_ = 0;&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * Whether the browser is IE9 or earlier, which needs special handling&quot;,&quot;   * for deferred modules.&quot;,&quot;   * @const @private {boolean}&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.IS_OLD_IE_ =&quot;,&quot;      !!(!goog.global.atob &amp;&amp; goog.global.document &amp;&amp; goog.global.document.all);&quot;,null,null,&quot;  /**&quot;,&quot;   * Performs any needed preprocessing of a goog.require call.&quot;,&quot;   *&quot;,&quot;   * @param {string} name&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.earlyProcessLoad = function(name) {&quot;,&quot;    if (goog.DebugLoader.IS_OLD_IE_) {&quot;,&quot;      this.maybeProcessDeferredDep_(name);&quot;,&quot;    }&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * Loads the given symbol along with any dependencies.&quot;,&quot;   *&quot;,&quot;   * @param {string} name&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.load = function(name) {&quot;,&quot;    var pathToLoad = this.getPathFromDeps_(name);&quot;,&quot;    if (!pathToLoad) {&quot;,&quot;      var errorMessage = &#39;goog.require could not find: &#39; + name;&quot;,&quot;      this.logToConsole(errorMessage);&quot;,null,&quot;      throw Error(errorMessage);&quot;,&quot;    } else {&quot;,&quot;      /** @type {!Array&lt;string&gt;} The scripts we need to write this time. */&quot;,&quot;      var scripts = [];&quot;,&quot;      var seenScript = {};&quot;,&quot;      var deps = this.dependencies_;&quot;,&quot;      var loader = this;&quot;,null,&quot;      /** @param {string} path */&quot;,&quot;      function visitNode(path) {&quot;,&quot;        if (path in deps.written) {&quot;,&quot;          return;&quot;,&quot;        }&quot;,null,&quot;        // We have already visited this one. We can get here if we have cyclic&quot;,&quot;        // dependencies.&quot;,&quot;        if (path in deps.visited) {&quot;,&quot;          return;&quot;,&quot;        }&quot;,null,&quot;        deps.visited[path] = true;&quot;,null,&quot;        if (path in deps.requires) {&quot;,&quot;          for (var requireName in deps.requires[path]) {&quot;,&quot;            // If the required name is defined, we assume that it was already&quot;,&quot;            // bootstrapped by other means.&quot;,&quot;            if (!loader.isProvided(requireName)) {&quot;,&quot;              if (requireName in deps.nameToPath) {&quot;,&quot;                visitNode(deps.nameToPath[requireName]);&quot;,&quot;              } else {&quot;,&quot;                throw Error(&#39;Undefined nameToPath for &#39; + requireName);&quot;,&quot;              }&quot;,&quot;            }&quot;,&quot;          }&quot;,&quot;        }&quot;,null,&quot;        if (!(path in seenScript)) {&quot;,&quot;          seenScript[path] = true;&quot;,&quot;          scripts.push(path);&quot;,&quot;        }&quot;,&quot;      }&quot;,null,&quot;      visitNode(pathToLoad);&quot;,null,&quot;      // record that we are going to load all these scripts.&quot;,&quot;      for (var i = 0; i &lt; scripts.length; i++) {&quot;,&quot;        var path = scripts[i];&quot;,&quot;        this.dependencies_.written[path] = true;&quot;,&quot;      }&quot;,null,&quot;      for (var i = 0; i &lt; scripts.length; i++) {&quot;,&quot;        var path = scripts[i];&quot;,&quot;        if (path) {&quot;,&quot;          var loadFlags = deps.loadFlags[path] || {};&quot;,&quot;          var languageLevel = loadFlags[&#39;lang&#39;] || &#39;es3&#39;;&quot;,&quot;          var needsTranspile =&quot;,&quot;              this.getTranspiler().needsTranspile(languageLevel);&quot;,&quot;          if (loadFlags[&#39;module&#39;] == &#39;goog&#39; || needsTranspile) {&quot;,&quot;            this.importProcessedScript_(&quot;,&quot;                goog.basePath + path, loadFlags[&#39;module&#39;] == &#39;goog&#39;,&quot;,&quot;                needsTranspile);&quot;,&quot;          } else {&quot;,&quot;            this.importScript_(goog.basePath + path);&quot;,&quot;          }&quot;,&quot;        } else {&quot;,&quot;          throw Error(&#39;Undefined script input&#39;);&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * @param {string} relPath&quot;,&quot;   * @param {!Array&lt;string&gt;} provides&quot;,&quot;   * @param {!Array&lt;string&gt;} requires&quot;,&quot;   * @param {boolean|!Object&lt;string&gt;=} opt_loadFlags&quot;,&quot;   * @see goog.addDependency&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.addDependency = function(&quot;,&quot;      relPath, provides, requires, opt_loadFlags) {&quot;,&quot;    var provide, require;&quot;,&quot;    var path = relPath.replace(/\\\\/g, &#39;/&#39;);&quot;,&quot;    var deps = this.dependencies_;&quot;,&quot;    if (!opt_loadFlags || typeof opt_loadFlags === &#39;boolean&#39;) {&quot;,&quot;      opt_loadFlags = opt_loadFlags ? {&#39;module&#39;: &#39;goog&#39;} : {};&quot;,&quot;    }&quot;,&quot;    for (var i = 0; provide = provides[i]; i++) {&quot;,&quot;      deps.nameToPath[provide] = path;&quot;,&quot;      deps.loadFlags[path] = opt_loadFlags;&quot;,&quot;    }&quot;,&quot;    for (var j = 0; require = requires[j]; j++) {&quot;,&quot;      if (!(path in deps.requires)) {&quot;,&quot;        deps.requires[path] = {};&quot;,&quot;      }&quot;,&quot;      deps.requires[path][require] = true;&quot;,&quot;    }&quot;,&quot;  };&quot;,null,&quot;  /**&quot;,&quot;   * Imports a script if, and only if, that script hasn&#39;t already been imported.&quot;,&quot;   * (Must be called at execution time)&quot;,&quot;   * @param {string} src Script source.&quot;,&quot;   * @param {string=} opt_sourceText The optionally source text to evaluate&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.importScript_ = function(src, opt_sourceText) {&quot;,&quot;    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||&quot;,&quot;        goog.bind(this.writeScriptTag_, this);&quot;,&quot;    if (importScript(src, opt_sourceText)) {&quot;,&quot;      this.dependencies_.written[src] = true;&quot;,&quot;    }&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * Given a URL initiate retrieval and execution of a script that needs&quot;,&quot;   * pre-processing.&quot;,&quot;   * @param {string} src Script source URL.&quot;,&quot;   * @param {boolean} isModule Whether this is a goog.module.&quot;,&quot;   * @param {boolean} needsTranspile Whether this source needs transpilation.&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.importProcessedScript_ = function(&quot;,&quot;      src, isModule, needsTranspile) {&quot;,&quot;    // In an attempt to keep browsers from timing out loading scripts using&quot;,&quot;    // synchronous XHRs, put each load in its own script block.&quot;,&quot;    var bootstrap = &#39;goog.debugLoader_.retrieveAndExec_(\&quot;&#39; + src + &#39;\&quot;, &#39; +&quot;,&quot;        isModule + &#39;, &#39; + needsTranspile + &#39;);&#39;;&quot;,null,&quot;    this.importScript_(&#39;&#39;, bootstrap);&quot;,&quot;  };&quot;,null,&quot;  /**&quot;,&quot;   * Retrieve and execute a script that needs some sort of wrapping.&quot;,&quot;   * @param {string} src Script source URL.&quot;,&quot;   * @param {boolean} isModule Whether to load as a module.&quot;,&quot;   * @param {boolean} needsTranspile Whether to transpile down to ES3.&quot;,&quot;   * @private&quot;,&quot;   * @suppress {unusedPrivateMembers}&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.retrieveAndExec_ = function(&quot;,&quot;      src, isModule, needsTranspile) {&quot;,&quot;    if (!COMPILED) {&quot;,&quot;      // The full but non-canonicalized URL for later use.&quot;,&quot;      var originalPath = src;&quot;,&quot;      // Canonicalize the path, removing any /./ or /../ since Chrome&#39;s&quot;,&quot;      // debugging console doesn&#39;t auto-canonicalize XHR loads as it does&quot;,&quot;      // &lt;script&gt; srcs.&quot;,&quot;      src = this.normalizePath(src);&quot;,null,&quot;      var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||&quot;,&quot;          goog.bind(this.writeScriptTag_, this);&quot;,null,&quot;      var scriptText = this.loadFileSync(src);&quot;,&quot;      if (scriptText == null) {&quot;,&quot;        throw new Error(&#39;Load of \&quot;&#39; + src + &#39;\&quot; failed&#39;);&quot;,&quot;      }&quot;,null,&quot;      if (needsTranspile) {&quot;,&quot;        scriptText = this.getTranspiler().transpile(scriptText, src);&quot;,&quot;      }&quot;,null,&quot;      if (isModule) {&quot;,&quot;        scriptText = this.wrapModule_(src, scriptText);&quot;,&quot;      } else {&quot;,&quot;        scriptText += &#39;\\n//# sourceURL=&#39; + src;&quot;,&quot;      }&quot;,&quot;      var isOldIE = goog.DebugLoader.IS_OLD_IE_;&quot;,&quot;      if (isOldIE &amp;&amp; this.oldIeWaiting_) {&quot;,&quot;        this.dependencies_.deferred[originalPath] = scriptText;&quot;,&quot;        this.queuedModules_.push(originalPath);&quot;,&quot;      } else {&quot;,&quot;        importScript(src, scriptText);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * Return an appropriate module text. Suitable to insert into&quot;,&quot;   * a script tag (that is unescaped).&quot;,&quot;   * @param {string} srcUrl&quot;,&quot;   * @param {string} scriptText&quot;,&quot;   * @return {string}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.wrapModule_ = function(srcUrl, scriptText) {&quot;,&quot;    if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) {&quot;,&quot;      return &#39;&#39; +&quot;,&quot;          &#39;goog.loadModule(function(exports) {&#39; +&quot;,&quot;          &#39;\&quot;use strict\&quot;;&#39; + scriptText +&quot;,&quot;          &#39;\\n&#39; +  // terminate any trailing single line comment.&quot;,&quot;          &#39;;return exports&#39; +&quot;,&quot;          &#39;});&#39; +&quot;,&quot;          &#39;\\n//# sourceURL=&#39; + srcUrl + &#39;\\n&#39;;&quot;,&quot;    } else {&quot;,&quot;      return &#39;&#39; +&quot;,&quot;          &#39;goog.loadModule(&#39; +&quot;,&quot;          goog.global.JSON.stringify(&quot;,&quot;              scriptText + &#39;\\n//# sourceURL=&#39; + srcUrl + &#39;\\n&#39;) +&quot;,&quot;          &#39;);&#39;;&quot;,&quot;    }&quot;,&quot;  };&quot;,null,&quot;  // On IE9 and earlier, it is necessary to handle&quot;,&quot;  // deferred module loads. In later browsers, the&quot;,&quot;  // code to be evaluated is simply inserted as a script&quot;,&quot;  // block in the correct order. To eval deferred&quot;,&quot;  // code at the right time, we piggy back on goog.require to call&quot;,&quot;  // this.maybeProcessDeferredDep_.&quot;,&quot;  //&quot;,&quot;  // The goog.requires are used both to bootstrap&quot;,&quot;  // the loading process (when no deps are available) and&quot;,&quot;  // declare that they should be available.&quot;,&quot;  //&quot;,&quot;  // Here we eval the sources, if all the deps are available&quot;,&quot;  // either already eval&#39;d or goog.require&#39;d.  This will&quot;,&quot;  // be the case when all the dependencies have already&quot;,&quot;  // been loaded, and the dependent module is loaded.&quot;,&quot;  //&quot;,&quot;  // But this alone isn&#39;t sufficient because it is also&quot;,&quot;  // necessary to handle the case where there is no root&quot;,&quot;  // that is not deferred.  For that there we register for an event&quot;,&quot;  // and trigger this.loadQueuedModules_ handle any remaining deferred&quot;,&quot;  // evaluations.&quot;,null,&quot;  /**&quot;,&quot;   * Handle any remaining deferred goog.module evals.&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.loadQueuedModules_ = function() {&quot;,&quot;    var count = this.queuedModules_.length;&quot;,&quot;    if (count &gt; 0) {&quot;,&quot;      var queue = this.queuedModules_;&quot;,&quot;      this.queuedModules_ = [];&quot;,&quot;      for (var i = 0; i &lt; count; i++) {&quot;,&quot;        var path = queue[i];&quot;,&quot;        this.maybeProcessDeferredPath_(path);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    this.oldIeWaiting_ = false;&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * Eval the named module if its dependencies are&quot;,&quot;   * available.&quot;,&quot;   * @param {string} name The module to load.&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.maybeProcessDeferredDep_ = function(name) {&quot;,&quot;    if (this.isDeferredModule_(name) &amp;&amp; this.allDepsAreAvailable_(name)) {&quot;,&quot;      var path = this.getPathFromDeps_(name);&quot;,&quot;      this.maybeProcessDeferredPath_(goog.basePath + path);&quot;,&quot;    }&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * @param {string} name The module to check.&quot;,&quot;   * @return {boolean} Whether the name represents a&quot;,&quot;   *     module whose evaluation has been deferred.&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.isDeferredModule_ = function(name) {&quot;,&quot;    var path = this.getPathFromDeps_(name);&quot;,&quot;    var loadFlags = path &amp;&amp; this.dependencies_.loadFlags[path] || {};&quot;,&quot;    var languageLevel = loadFlags[&#39;lang&#39;] || &#39;es3&#39;;&quot;,&quot;    if (path &amp;&amp;&quot;,&quot;        (loadFlags[&#39;module&#39;] == &#39;goog&#39; ||&quot;,&quot;         this.getTranspiler().needsTranspile(languageLevel))) {&quot;,&quot;      var abspath = goog.basePath + path;&quot;,&quot;      return (abspath) in this.dependencies_.deferred;&quot;,&quot;    }&quot;,&quot;    return false;&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * @param {string} name The module to check.&quot;,&quot;   * @return {boolean} Whether the name represents a&quot;,&quot;   *     module whose declared dependencies have all been loaded&quot;,&quot;   *     (eval&#39;d or a deferred module load)&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.allDepsAreAvailable_ = function(name) {&quot;,&quot;    var path = this.getPathFromDeps_(name);&quot;,&quot;    if (path &amp;&amp; (path in this.dependencies_.requires)) {&quot;,&quot;      for (var requireName in this.dependencies_.requires[path]) {&quot;,&quot;        if (!this.isProvided(requireName) &amp;&amp;&quot;,&quot;            !this.isDeferredModule_(requireName)) {&quot;,&quot;          return false;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    return true;&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * @param {string} abspath&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.maybeProcessDeferredPath_ = function(abspath) {&quot;,&quot;    if (abspath in this.dependencies_.deferred) {&quot;,&quot;      var src = this.dependencies_.deferred[abspath];&quot;,&quot;      delete this.dependencies_.deferred[abspath];&quot;,&quot;      goog.globalEval(src);&quot;,&quot;    }&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * Writes a new script pointing to {@code src} directly into the DOM.&quot;,&quot;   *&quot;,&quot;   * NOTE: This method is not CSP-compliant. @see this.appendScriptSrcNode_ for&quot;,&quot;   * the fallback mechanism.&quot;,&quot;   *&quot;,&quot;   * @param {string} src The script URL.&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.writeScriptSrcNode_ = function(src) {&quot;,&quot;    goog.global.document.write(&quot;,&quot;        &#39;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;&#39; + src + &#39;\&quot;&gt;&lt;/&#39; +&quot;,&quot;        &#39;script&gt;&#39;);&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * Appends a new script node to the DOM using a CSP-compliant mechanism. This&quot;,&quot;   * method exists as a fallback for document.write (which is not allowed in a&quot;,&quot;   * strict CSP context, e.g., Chrome apps).&quot;,&quot;   *&quot;,&quot;   * NOTE: This method is not analogous to using document.write to insert a&quot;,&quot;   * &lt;script&gt; tag; specifically, the user agent will execute a script added by&quot;,&quot;   * document.write immediately after the current script block finishes&quot;,&quot;   * executing, whereas the DOM-appended script node will not be executed until&quot;,&quot;   * the entire document is parsed and executed. That is to say, this script is&quot;,&quot;   * added to the end of the script execution queue.&quot;,&quot;   *&quot;,&quot;   * The page must not attempt to call goog.required entities until after the&quot;,&quot;   * document has loaded, e.g., in or after the window.onload callback.&quot;,&quot;   *&quot;,&quot;   * @param {string} src The script URL.&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.appendScriptSrcNode_ = function(src) {&quot;,&quot;    /** @type {!Document} */&quot;,&quot;    var doc = goog.global.document;&quot;,&quot;    var scriptEl =&quot;,&quot;        /** @type {!HTMLScriptElement} */ (doc.createElement(&#39;script&#39;));&quot;,&quot;    scriptEl.type = &#39;text/javascript&#39;;&quot;,&quot;    scriptEl.src = src;&quot;,&quot;    scriptEl.defer = false;&quot;,&quot;    scriptEl.async = false;&quot;,&quot;    doc.head.appendChild(scriptEl);&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * The default implementation of the import function. Writes a script tag to&quot;,&quot;   * import the script.&quot;,&quot;   *&quot;,&quot;   * @param {string} src The script url.&quot;,&quot;   * @param {string=} opt_sourceText The optionally source text to evaluate&quot;,&quot;   * @return {boolean} True if the script was imported, false otherwise.&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.writeScriptTag_ = function(src, opt_sourceText) {&quot;,&quot;    if (this.inHtmlDocument()) {&quot;,&quot;      /** @type {!HTMLDocument} */&quot;,&quot;      var doc = goog.global.document;&quot;,null,&quot;      // If the user tries to require a new symbol after document load,&quot;,&quot;      // something has gone terribly wrong. Doing a document.write would&quot;,&quot;      // wipe out the page. This does not apply to the CSP-compliant method&quot;,&quot;      // of writing script tags.&quot;,&quot;      if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &amp;&amp;&quot;,&quot;          doc.readyState == &#39;complete&#39;) {&quot;,&quot;        // Certain test frameworks load base.js multiple times, which tries&quot;,&quot;        // to write deps.js each time. If that happens, just fail silently.&quot;,&quot;        // These frameworks wipe the page between each load of base.js, so this&quot;,&quot;        // is OK.&quot;,&quot;        var isDeps = /\\bdeps.js$/.test(src);&quot;,&quot;        if (isDeps) {&quot;,&quot;          return false;&quot;,&quot;        } else {&quot;,&quot;          throw Error(&#39;Cannot write \&quot;&#39; + src + &#39;\&quot; after document load&#39;);&quot;,&quot;        }&quot;,&quot;      }&quot;,null,&quot;      if (opt_sourceText === undefined) {&quot;,&quot;        if (!goog.DebugLoader.IS_OLD_IE_) {&quot;,&quot;          if (goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {&quot;,&quot;            this.appendScriptSrcNode_(src);&quot;,&quot;          } else {&quot;,&quot;            this.writeScriptSrcNode_(src);&quot;,&quot;          }&quot;,&quot;        } else {&quot;,&quot;          this.oldIeWaiting_ = true;&quot;,&quot;          var state = &#39; onreadystatechange=\\&#39;goog.debugLoader_&#39; +&quot;,&quot;              &#39;.onScriptLoad_(this, &#39; + ++this.lastNonModuleScriptIndex_ +&quot;,&quot;              &#39;)\\&#39; &#39;;&quot;,&quot;          doc.write(&quot;,&quot;              &#39;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;&#39; + src + &#39;\&quot;&#39; + state +&quot;,&quot;              &#39;&gt;&lt;/&#39; +&quot;,&quot;              &#39;script&gt;&#39;);&quot;,&quot;        }&quot;,&quot;      } else {&quot;,&quot;        doc.write(&quot;,&quot;            &#39;&lt;script type=\&quot;text/javascript\&quot;&gt;&#39; +&quot;,&quot;            this.protectScriptTag_(opt_sourceText) + &#39;&lt;/&#39; +&quot;,&quot;            &#39;script&gt;&#39;);&quot;,&quot;      }&quot;,&quot;      return true;&quot;,&quot;    } else {&quot;,&quot;      return false;&quot;,&quot;    }&quot;,&quot;  };&quot;,null,&quot;  /**&quot;,&quot;   * Rewrites closing script tags in input to avoid ending an enclosing script&quot;,&quot;   * tag.&quot;,&quot;   *&quot;,&quot;   * @param {string} str&quot;,&quot;   * @return {string}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.protectScriptTag_ = function(str) {&quot;,&quot;    return str.replace(/&lt;\\/(SCRIPT)/ig, &#39;\\\\x3c/$1&#39;);&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * A readystatechange handler for legacy IE&quot;,&quot;   * @param {?} script&quot;,&quot;   * @param {number} scriptIndex&quot;,&quot;   * @return {boolean}&quot;,&quot;   * @private&quot;,&quot;   * @suppress {unusedPrivateMembers}&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.onScriptLoad_ = function(script, scriptIndex) {&quot;,&quot;    // for now load the modules when we reach the last script,&quot;,&quot;    // later allow more inter-mingling.&quot;,&quot;    if (script.readyState == &#39;complete&#39; &amp;&amp;&quot;,&quot;        this.lastNonModuleScriptIndex_ == scriptIndex) {&quot;,&quot;      this.loadQueuedModules_();&quot;,&quot;    }&quot;,&quot;    return true;&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * Looks at the dependency rules and tries to determine the script file that&quot;,&quot;   * fulfills a particular rule.&quot;,&quot;   * @param {string} rule In the form goog.namespace.Class or project.script.&quot;,&quot;   * @return {?string} Url corresponding to the rule, or null.&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.getPathFromDeps_ = function(rule) {&quot;,&quot;    if (rule in this.dependencies_.nameToPath) {&quot;,&quot;      return this.dependencies_.nameToPath[rule];&quot;,&quot;    } else {&quot;,&quot;      return null;&quot;,&quot;    }&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * @return {!goog.Transpiler}&quot;,&quot;   * @protected @final&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.getTranspiler = function() {&quot;,&quot;    return goog.transpiler_;&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * @param {string} namespaceOrPath&quot;,&quot;   * @return {boolean}&quot;,&quot;   * @protected @final&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.isProvided = function(namespaceOrPath) {&quot;,&quot;    return goog.isProvided_(namespaceOrPath);&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * @return {boolean}&quot;,&quot;   * @protected @final&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.inHtmlDocument = function() {&quot;,&quot;    return goog.inHtmlDocument_();&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * @param {string} message&quot;,&quot;   * @protected @final&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.logToConsole = function(message) {&quot;,&quot;    goog.logToConsole_(message);&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * @param {string} srcUrl&quot;,&quot;   * @return {?string}&quot;,&quot;   * @protected @final&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.loadFileSync = function(srcUrl) {&quot;,&quot;    return goog.loadFileSync_(srcUrl);&quot;,&quot;  };&quot;,null,null,&quot;  /**&quot;,&quot;   * @param {string} path&quot;,&quot;   * @return {string}&quot;,&quot;   * @protected @final&quot;,&quot;   */&quot;,&quot;  goog.DebugLoader.prototype.normalizePath = function(path) {&quot;,&quot;    return goog.normalizePath_(path);&quot;,&quot;  };&quot;,null,null,&quot;  /** @private {?goog.DebugLoader} */&quot;,&quot;  goog.debugLoader_ = null;&quot;,null,null,&quot;  /** @param {!goog.DebugLoader} loader */&quot;,&quot;  goog.registerDebugLoader = function(loader) {&quot;,&quot;    if (goog.debugLoader_) {&quot;,&quot;      throw new Error(&#39;Debug loader already registered!&#39;);&quot;,&quot;    }&quot;,&quot;    if (!(loader instanceof goog.DebugLoader)) {&quot;,&quot;      throw new Error(&#39;Not a goog.DebugLoader.&#39;);&quot;,&quot;    }&quot;,&quot;    goog.debugLoader_ = loader;&quot;,&quot;  };&quot;,null,&quot;  /** @private @return {!goog.DebugLoader} */&quot;,&quot;  goog.getLoader_ = function() {&quot;,&quot;    if (!goog.debugLoader_ &amp;&amp; goog.DEBUG_LOADER) {&quot;,&quot;      // Tried to load earlier but failed.&quot;,&quot;      throw new Error(&#39;Loaded debug loader file but no loader was registered!&#39;);&quot;,&quot;    } else if (!goog.debugLoader_) {&quot;,&quot;      // No custom loader and no closure deps. Was not made earlier; make it&quot;,&quot;      // now.&quot;,&quot;      goog.debugLoader_ = new goog.DebugLoader();&quot;,&quot;    }&quot;,&quot;    return goog.debugLoader_;&quot;,&quot;  };&quot;,null,&quot;  (function() {&quot;,&quot;    var tempLoader;&quot;,&quot;    if (goog.DEBUG_LOADER) {&quot;,&quot;      tempLoader = new goog.DebugLoader();&quot;,&quot;      tempLoader.importScript_(goog.basePath + goog.DEBUG_LOADER);&quot;,&quot;    }&quot;,null,&quot;    // Allow projects to manage the deps files themselves.&quot;,&quot;    if (!goog.global.CLOSURE_NO_DEPS) {&quot;,&quot;      tempLoader = tempLoader || new goog.DebugLoader();&quot;,&quot;      if (!goog.DEBUG_LOADER) {&quot;,&quot;        // Can reuse the same debug loader in the rest of the application.&quot;,&quot;        goog.registerDebugLoader(tempLoader);&quot;,&quot;      }&quot;,&quot;      tempLoader.importScript_(goog.basePath + &#39;deps.js&#39;);&quot;,&quot;    }&quot;,&quot;  })();&quot;,&quot;}&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../dossier.js" defer></script>