<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>functions.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;functions.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/functions/functions.js&quot;,[&quot;// Copyright 2008 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Utilities for creating functions. Loosely inspired by the&quot;,&quot; * java classes: http://goo.gl/GM0Hmu and http://goo.gl/6k7nI8.&quot;,&quot; *&quot;,&quot; * @author nicksantos@google.com (Nick Santos)&quot;,&quot; */&quot;,null,null,&quot;goog.provide(&#39;goog.functions&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * Creates a function that always returns the same value.&quot;,&quot; * @param {T} retValue The value to return.&quot;,&quot; * @return {function():T} The new function.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.functions.constant = function(retValue) {&quot;,&quot;  return function() { return retValue; };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Always returns false.&quot;,&quot; * @type {function(...): boolean}&quot;,&quot; */&quot;,&quot;goog.functions.FALSE = goog.functions.constant(false);&quot;,null,null,&quot;/**&quot;,&quot; * Always returns true.&quot;,&quot; * @type {function(...): boolean}&quot;,&quot; */&quot;,&quot;goog.functions.TRUE = goog.functions.constant(true);&quot;,null,null,&quot;/**&quot;,&quot; * Always returns NULL.&quot;,&quot; * @type {function(...): null}&quot;,&quot; */&quot;,&quot;goog.functions.NULL = goog.functions.constant(null);&quot;,null,null,&quot;/**&quot;,&quot; * A simple function that returns the first argument of whatever is passed&quot;,&quot; * into it.&quot;,&quot; * @param {T=} opt_returnValue The single value that will be returned.&quot;,&quot; * @param {...*} var_args Optional trailing arguments. These are ignored.&quot;,&quot; * @return {T} The first argument passed in, or undefined if nothing was passed.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.functions.identity = function(opt_returnValue, var_args) {&quot;,&quot;  return opt_returnValue;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a function that always throws an error with the given message.&quot;,&quot; * @param {string} message The error message.&quot;,&quot; * @return {!Function} The error-throwing function.&quot;,&quot; */&quot;,&quot;goog.functions.error = function(message) {&quot;,&quot;  return function() {&quot;,&quot;    throw new Error(message);&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a function that throws the given object.&quot;,&quot; * @param {*} err An object to be thrown.&quot;,&quot; * @return {!Function} The error-throwing function.&quot;,&quot; */&quot;,&quot;goog.functions.fail = function(err) {&quot;,&quot;  return function() { throw err; };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Given a function, create a function that keeps opt_numArgs arguments and&quot;,&quot; * silently discards all additional arguments.&quot;,&quot; * @param {Function} f The original function.&quot;,&quot; * @param {number=} opt_numArgs The number of arguments to keep. Defaults to 0.&quot;,&quot; * @return {!Function} A version of f that only keeps the first opt_numArgs&quot;,&quot; *     arguments.&quot;,&quot; */&quot;,&quot;goog.functions.lock = function(f, opt_numArgs) {&quot;,&quot;  opt_numArgs = opt_numArgs || 0;&quot;,&quot;  return function() {&quot;,&quot;    var self = /** @type {*} */ (this);&quot;,&quot;    return f.apply(self, Array.prototype.slice.call(arguments, 0, opt_numArgs));&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a function that returns its nth argument.&quot;,&quot; * @param {number} n The position of the return argument.&quot;,&quot; * @return {!Function} A new function.&quot;,&quot; */&quot;,&quot;goog.functions.nth = function(n) {&quot;,&quot;  return function() { return arguments[n]; };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Like goog.partial(), except that arguments are added after arguments to the&quot;,&quot; * returned function.&quot;,&quot; *&quot;,&quot; * Usage:&quot;,&quot; * function f(arg1, arg2, arg3, arg4) { ... }&quot;,&quot; * var g = goog.functions.partialRight(f, arg3, arg4);&quot;,&quot; * g(arg1, arg2);&quot;,&quot; *&quot;,&quot; * @param {!Function} fn A function to partially apply.&quot;,&quot; * @param {...*} var_args Additional arguments that are partially applied to fn&quot;,&quot; *     at the end.&quot;,&quot; * @return {!Function} A partially-applied form of the function goog.partial()&quot;,&quot; *     was invoked as a method of.&quot;,&quot; */&quot;,&quot;goog.functions.partialRight = function(fn, var_args) {&quot;,&quot;  var rightArgs = Array.prototype.slice.call(arguments, 1);&quot;,&quot;  return function() {&quot;,&quot;    var self = /** @type {*} */ (this);&quot;,&quot;    var newArgs = Array.prototype.slice.call(arguments);&quot;,&quot;    newArgs.push.apply(newArgs, rightArgs);&quot;,&quot;    return fn.apply(self, newArgs);&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Given a function, create a new function that swallows its return value&quot;,&quot; * and replaces it with a new one.&quot;,&quot; * @param {Function} f A function.&quot;,&quot; * @param {T} retValue A new return value.&quot;,&quot; * @return {function(...?):T} A new function.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.functions.withReturnValue = function(f, retValue) {&quot;,&quot;  return goog.functions.sequence(f, goog.functions.constant(retValue));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a function that returns whether its argument equals the given value.&quot;,&quot; *&quot;,&quot; * Example:&quot;,&quot; * var key = goog.object.findKey(obj, goog.functions.equalTo(&#39;needle&#39;));&quot;,&quot; *&quot;,&quot; * @param {*} value The value to compare to.&quot;,&quot; * @param {boolean=} opt_useLooseComparison Whether to use a loose (==)&quot;,&quot; *     comparison rather than a strict (===) one. Defaults to false.&quot;,&quot; * @return {function(*):boolean} The new function.&quot;,&quot; */&quot;,&quot;goog.functions.equalTo = function(value, opt_useLooseComparison) {&quot;,&quot;  return function(other) {&quot;,&quot;    return opt_useLooseComparison ? (value == other) : (value === other);&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates the composition of the functions passed in.&quot;,&quot; * For example, (goog.functions.compose(f, g))(a) is equivalent to f(g(a)).&quot;,&quot; * @param {function(...?):T} fn The final function.&quot;,&quot; * @param {...Function} var_args A list of functions.&quot;,&quot; * @return {function(...?):T} The composition of all inputs.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.functions.compose = function(fn, var_args) {&quot;,&quot;  var functions = arguments;&quot;,&quot;  var length = functions.length;&quot;,&quot;  return function() {&quot;,&quot;    var self = /** @type {*} */ (this);&quot;,&quot;    var result;&quot;,&quot;    if (length) {&quot;,&quot;      result = functions[length - 1].apply(self, arguments);&quot;,&quot;    }&quot;,null,&quot;    for (var i = length - 2; i &gt;= 0; i--) {&quot;,&quot;      result = functions[i].call(self, result);&quot;,&quot;    }&quot;,&quot;    return result;&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a function that calls the functions passed in in sequence, and&quot;,&quot; * returns the value of the last function. For example,&quot;,&quot; * (goog.functions.sequence(f, g))(x) is equivalent to f(x),g(x).&quot;,&quot; * @param {...Function} var_args A list of functions.&quot;,&quot; * @return {!Function} A function that calls all inputs in sequence.&quot;,&quot; */&quot;,&quot;goog.functions.sequence = function(var_args) {&quot;,&quot;  var functions = arguments;&quot;,&quot;  var length = functions.length;&quot;,&quot;  return function() {&quot;,&quot;    var self = /** @type {*} */ (this);&quot;,&quot;    var result;&quot;,&quot;    for (var i = 0; i &lt; length; i++) {&quot;,&quot;      result = functions[i].apply(self, arguments);&quot;,&quot;    }&quot;,&quot;    return result;&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a function that returns true if each of its components evaluates&quot;,&quot; * to true. The components are evaluated in order, and the evaluation will be&quot;,&quot; * short-circuited as soon as a function returns false.&quot;,&quot; * For example, (goog.functions.and(f, g))(x) is equivalent to f(x) &amp;&amp; g(x).&quot;,&quot; * @param {...Function} var_args A list of functions.&quot;,&quot; * @return {function(...?):boolean} A function that ANDs its component&quot;,&quot; *      functions.&quot;,&quot; */&quot;,&quot;goog.functions.and = function(var_args) {&quot;,&quot;  var functions = arguments;&quot;,&quot;  var length = functions.length;&quot;,&quot;  return function() {&quot;,&quot;    var self = /** @type {*} */ (this);&quot;,&quot;    for (var i = 0; i &lt; length; i++) {&quot;,&quot;      if (!functions[i].apply(self, arguments)) {&quot;,&quot;        return false;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    return true;&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a function that returns true if any of its components evaluates&quot;,&quot; * to true. The components are evaluated in order, and the evaluation will be&quot;,&quot; * short-circuited as soon as a function returns true.&quot;,&quot; * For example, (goog.functions.or(f, g))(x) is equivalent to f(x) || g(x).&quot;,&quot; * @param {...Function} var_args A list of functions.&quot;,&quot; * @return {function(...?):boolean} A function that ORs its component&quot;,&quot; *    functions.&quot;,&quot; */&quot;,&quot;goog.functions.or = function(var_args) {&quot;,&quot;  var functions = arguments;&quot;,&quot;  var length = functions.length;&quot;,&quot;  return function() {&quot;,&quot;    var self = /** @type {*} */ (this);&quot;,&quot;    for (var i = 0; i &lt; length; i++) {&quot;,&quot;      if (functions[i].apply(self, arguments)) {&quot;,&quot;        return true;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    return false;&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a function that returns the Boolean opposite of a provided function.&quot;,&quot; * For example, (goog.functions.not(f))(x) is equivalent to !f(x).&quot;,&quot; * @param {!Function} f The original function.&quot;,&quot; * @return {function(...?):boolean} A function that delegates to f and returns&quot;,&quot; * opposite.&quot;,&quot; */&quot;,&quot;goog.functions.not = function(f) {&quot;,&quot;  return function() {&quot;,&quot;    var self = /** @type {*} */ (this);&quot;,&quot;    return !f.apply(self, arguments);&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Generic factory function to construct an object given the constructor&quot;,&quot; * and the arguments. Intended to be bound to create object factories.&quot;,&quot; *&quot;,&quot; * Example:&quot;,&quot; *&quot;,&quot; * var factory = goog.partial(goog.functions.create, Class);&quot;,&quot; *&quot;,&quot; * @param {function(new:T, ...)} constructor The constructor for the Object.&quot;,&quot; * @param {...*} var_args The arguments to be passed to the constructor.&quot;,&quot; * @return {T} A new instance of the class given in {@code constructor}.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.functions.create = function(constructor, var_args) {&quot;,&quot;  /**&quot;,&quot;   * @constructor&quot;,&quot;   * @final&quot;,&quot;   */&quot;,&quot;  var temp = function() {};&quot;,&quot;  temp.prototype = constructor.prototype;&quot;,null,&quot;  // obj will have constructor&#39;s prototype in its chain and&quot;,&quot;  // &#39;obj instanceof constructor&#39; will be true.&quot;,&quot;  var obj = new temp();&quot;,null,&quot;  // obj is initialized by constructor.&quot;,&quot;  // arguments is only array-like so lacks shift(), but can be used with&quot;,&quot;  // the Array prototype function.&quot;,&quot;  constructor.apply(obj, Array.prototype.slice.call(arguments, 1));&quot;,&quot;  return obj;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether the return value cache should be used.&quot;,&quot; *    This should only be used to disable caches when testing.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.functions.CACHE_RETURN_VALUE&#39;, true);&quot;,null,null,&quot;/**&quot;,&quot; * Gives a wrapper function that caches the return value of a parameterless&quot;,&quot; * function when first called.&quot;,&quot; *&quot;,&quot; * When called for the first time, the given function is called and its&quot;,&quot; * return value is cached (thus this is only appropriate for idempotent&quot;,&quot; * functions).  Subsequent calls will return the cached return value. This&quot;,&quot; * allows the evaluation of expensive functions to be delayed until first used.&quot;,&quot; *&quot;,&quot; * To cache the return values of functions with parameters, see goog.memoize.&quot;,&quot; *&quot;,&quot; * @param {function():T} fn A function to lazily evaluate.&quot;,&quot; * @return {function():T} A wrapped version the function.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.functions.cacheReturnValue = function(fn) {&quot;,&quot;  var called = false;&quot;,&quot;  var value;&quot;,null,&quot;  return function() {&quot;,&quot;    if (!goog.functions.CACHE_RETURN_VALUE) {&quot;,&quot;      return fn();&quot;,&quot;    }&quot;,null,&quot;    if (!called) {&quot;,&quot;      value = fn();&quot;,&quot;      called = true;&quot;,&quot;    }&quot;,null,&quot;    return value;&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Wraps a function to allow it to be called, at most, once. All&quot;,&quot; * additional calls are no-ops.&quot;,&quot; *&quot;,&quot; * This is particularly useful for initialization functions&quot;,&quot; * that should be called, at most, once.&quot;,&quot; *&quot;,&quot; * @param {function():*} f Function to call.&quot;,&quot; * @return {function():undefined} Wrapped function.&quot;,&quot; */&quot;,&quot;goog.functions.once = function(f) {&quot;,&quot;  // Keep a reference to the function that we null out when we&#39;re done with&quot;,&quot;  // it -- that way, the function can be GC&#39;d when we&#39;re done with it.&quot;,&quot;  var inner = f;&quot;,&quot;  return function() {&quot;,&quot;    if (inner) {&quot;,&quot;      var tmp = inner;&quot;,&quot;      inner = null;&quot;,&quot;      tmp();&quot;,&quot;    }&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Wraps a function to allow it to be called, at most, once per interval&quot;,&quot; * (specified in milliseconds). If the wrapper function is called N times within&quot;,&quot; * that interval, only the Nth call will go through.&quot;,&quot; *&quot;,&quot; * This is particularly useful for batching up repeated actions where the&quot;,&quot; * last action should win. This can be used, for example, for refreshing an&quot;,&quot; * autocomplete pop-up every so often rather than updating with every keystroke,&quot;,&quot; * since the final text typed by the user is the one that should produce the&quot;,&quot; * final autocomplete results. For more stateful debouncing with support for&quot;,&quot; * pausing, resuming, and canceling debounced actions, use {@code&quot;,&quot; * goog.async.Debouncer}.&quot;,&quot; *&quot;,&quot; * @param {function(this:SCOPE, ...?)} f Function to call.&quot;,&quot; * @param {number} interval Interval over which to debounce. The function will&quot;,&quot; *     only be called after the full interval has elapsed since the last call.&quot;,&quot; * @param {SCOPE=} opt_scope Object in whose scope to call the function.&quot;,&quot; * @return {function(...?): undefined} Wrapped function.&quot;,&quot; * @template SCOPE&quot;,&quot; */&quot;,&quot;goog.functions.debounce = function(f, interval, opt_scope) {&quot;,&quot;  var timeout = 0;&quot;,&quot;  return /** @type {function(...?)} */ (function(var_args) {&quot;,&quot;    goog.global.clearTimeout(timeout);&quot;,&quot;    var args = arguments;&quot;,&quot;    timeout = goog.global.setTimeout(function() {&quot;,&quot;      f.apply(opt_scope, args);&quot;,&quot;    }, interval);&quot;,&quot;  });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Wraps a function to allow it to be called, at most, once per interval&quot;,&quot; * (specified in milliseconds). If the wrapper function is called N times in&quot;,&quot; * that interval, both the 1st and the Nth calls will go through.&quot;,&quot; *&quot;,&quot; * This is particularly useful for limiting repeated user requests where the&quot;,&quot; * the last action should win, but you also don&#39;t want to wait until the end of&quot;,&quot; * the interval before sending a request out, as it leads to a perception of&quot;,&quot; * slowness for the user.&quot;,&quot; *&quot;,&quot; * @param {function(this:SCOPE, ...?)} f Function to call.&quot;,&quot; * @param {number} interval Interval over which to throttle. The function can&quot;,&quot; *     only be called once per interval.&quot;,&quot; * @param {SCOPE=} opt_scope Object in whose scope to call the function.&quot;,&quot; * @return {function(...?): undefined} Wrapped function.&quot;,&quot; * @template SCOPE&quot;,&quot; */&quot;,&quot;goog.functions.throttle = function(f, interval, opt_scope) {&quot;,&quot;  var timeout = 0;&quot;,&quot;  var shouldFire = false;&quot;,&quot;  var args = [];&quot;,null,&quot;  var handleTimeout = function() {&quot;,&quot;    timeout = 0;&quot;,&quot;    if (shouldFire) {&quot;,&quot;      shouldFire = false;&quot;,&quot;      fire();&quot;,&quot;    }&quot;,&quot;  };&quot;,null,&quot;  var fire = function() {&quot;,&quot;    timeout = goog.global.setTimeout(handleTimeout, interval);&quot;,&quot;    f.apply(opt_scope, args);&quot;,&quot;  };&quot;,null,&quot;  return /** @type {function(...?)} */ (function(var_args) {&quot;,&quot;    args = arguments;&quot;,&quot;    if (!timeout) {&quot;,&quot;      fire();&quot;,&quot;    } else {&quot;,&quot;      shouldFire = true;&quot;,&quot;    }&quot;,&quot;  });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Wraps a function to allow it to be called, at most, once per interval&quot;,&quot; * (specified in milliseconds). If the wrapper function is called N times within&quot;,&quot; * that interval, only the 1st call will go through.&quot;,&quot; *&quot;,&quot; * This is particularly useful for limiting repeated user requests where the&quot;,&quot; * first request is guaranteed to have all the data required to perform the&quot;,&quot; * final action, so there&#39;s no need to wait until the end of the interval before&quot;,&quot; * sending the request out.&quot;,&quot; *&quot;,&quot; * @param {function(this:SCOPE, ...?)} f Function to call.&quot;,&quot; * @param {number} interval Interval over which to rate-limit. The function will&quot;,&quot; *     only be called once per interval, and ignored for the remainer of the&quot;,&quot; *     interval.&quot;,&quot; * @param {SCOPE=} opt_scope Object in whose scope to call the function.&quot;,&quot; * @return {function(...?): undefined} Wrapped function.&quot;,&quot; * @template SCOPE&quot;,&quot; */&quot;,&quot;goog.functions.rateLimit = function(f, interval, opt_scope) {&quot;,&quot;  var timeout = 0;&quot;,null,&quot;  var handleTimeout = function() {&quot;,&quot;    timeout = 0;&quot;,&quot;  };&quot;,null,&quot;  return /** @type {function(...?)} */ (function(var_args) {&quot;,&quot;    if (!timeout) {&quot;,&quot;      timeout = goog.global.setTimeout(handleTimeout, interval);&quot;,&quot;      f.apply(opt_scope, arguments);&quot;,&quot;    }&quot;,&quot;  });&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>