<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>promise.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;promise.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/promise/promise.js&quot;,[&quot;// Copyright 2013 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;goog.provide(&#39;goog.Promise&#39;);&quot;,null,&quot;goog.require(&#39;goog.Thenable&#39;);&quot;,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;goog.async.FreeList&#39;);&quot;,&quot;goog.require(&#39;goog.async.run&#39;);&quot;,&quot;goog.require(&#39;goog.async.throwException&#39;);&quot;,&quot;goog.require(&#39;goog.debug.Error&#39;);&quot;,&quot;goog.require(&#39;goog.promise.Resolver&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * NOTE: This class was created in anticipation of the built-in Promise type&quot;,&quot; * being standardized and implemented across browsers. Now that Promise is&quot;,&quot; * available in modern browsers, and is automatically polyfilled by the Closure&quot;,&quot; * Compiler, by default, most new code should use native {@code Promise}&quot;,&quot; * instead of {@code goog.Promise}. However, {@code goog.Promise} has the&quot;,&quot; * concept of cancellation which native Promises do not yet have. So code&quot;,&quot; * needing cancellation may still want to use {@code goog.Promise}.&quot;,&quot; *&quot;,&quot; * Promises provide a result that may be resolved asynchronously. A Promise may&quot;,&quot; * be resolved by being fulfilled with a fulfillment value, rejected with a&quot;,&quot; * rejection reason, or blocked by another Promise. A Promise is said to be&quot;,&quot; * settled if it is either fulfilled or rejected. Once settled, the Promise&quot;,&quot; * result is immutable.&quot;,&quot; *&quot;,&quot; * Promises may represent results of any type, including undefined. Rejection&quot;,&quot; * reasons are typically Errors, but may also be of any type. Closure Promises&quot;,&quot; * allow for optional type annotations that enforce that fulfillment values are&quot;,&quot; * of the appropriate types at compile time.&quot;,&quot; *&quot;,&quot; * The result of a Promise is accessible by calling {@code then} and registering&quot;,&quot; * {@code onFulfilled} and {@code onRejected} callbacks. Once the Promise&quot;,&quot; * is settled, the relevant callbacks are invoked with the fulfillment value or&quot;,&quot; * rejection reason as argument. Callbacks are always invoked in the order they&quot;,&quot; * were registered, even when additional {@code then} calls are made from inside&quot;,&quot; * another callback. A callback is always run asynchronously sometime after the&quot;,&quot; * scope containing the registering {@code then} invocation has returned.&quot;,&quot; *&quot;,&quot; * If a Promise is resolved with another Promise, the first Promise will block&quot;,&quot; * until the second is settled, and then assumes the same result as the second&quot;,&quot; * Promise. This allows Promises to depend on the results of other Promises,&quot;,&quot; * linking together multiple asynchronous operations.&quot;,&quot; *&quot;,&quot; * This implementation is compatible with the Promises/A+ specification and&quot;,&quot; * passes that specification&#39;s conformance test suite. A Closure Promise may be&quot;,&quot; * resolved with a Promise instance (or sufficiently compatible Promise-like&quot;,&quot; * object) created by other Promise implementations. From the specification,&quot;,&quot; * Promise-like objects are known as \&quot;Thenables\&quot;.&quot;,&quot; *&quot;,&quot; * @see http://promisesaplus.com/&quot;,&quot; *&quot;,&quot; * @param {function(&quot;,&quot; *             this:RESOLVER_CONTEXT,&quot;,&quot; *             function((TYPE|IThenable&lt;TYPE&gt;|Thenable)=),&quot;,&quot; *             function(*=)): void} resolver&quot;,&quot; *     Initialization function that is invoked immediately with {@code resolve}&quot;,&quot; *     and {@code reject} functions as arguments. The Promise is resolved or&quot;,&quot; *     rejected with the first argument passed to either function.&quot;,&quot; * @param {RESOLVER_CONTEXT=} opt_context An optional context for executing the&quot;,&quot; *     resolver function. If unspecified, the resolver function will be executed&quot;,&quot; *     in the default scope.&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; * @final&quot;,&quot; * @implements {goog.Thenable&lt;TYPE&gt;}&quot;,&quot; * @template TYPE,RESOLVER_CONTEXT&quot;,&quot; */&quot;,&quot;goog.Promise = function(resolver, opt_context) {&quot;,&quot;  /**&quot;,&quot;   * The internal state of this Promise. Either PENDING, FULFILLED, REJECTED, or&quot;,&quot;   * BLOCKED.&quot;,&quot;   * @private {goog.Promise.State_}&quot;,&quot;   */&quot;,&quot;  this.state_ = goog.Promise.State_.PENDING;&quot;,null,&quot;  /**&quot;,&quot;   * The settled result of the Promise. Immutable once set with either a&quot;,&quot;   * fulfillment value or rejection reason.&quot;,&quot;   * @private {*}&quot;,&quot;   */&quot;,&quot;  this.result_ = undefined;&quot;,null,&quot;  /**&quot;,&quot;   * For Promises created by calling {@code then()}, the originating parent.&quot;,&quot;   * @private {goog.Promise}&quot;,&quot;   */&quot;,&quot;  this.parent_ = null;&quot;,null,&quot;  /**&quot;,&quot;   * The linked list of {@code onFulfilled} and {@code onRejected} callbacks&quot;,&quot;   * added to this Promise by calls to {@code then()}.&quot;,&quot;   * @private {?goog.Promise.CallbackEntry_}&quot;,&quot;   */&quot;,&quot;  this.callbackEntries_ = null;&quot;,null,&quot;  /**&quot;,&quot;   * The tail of the linked list of {@code onFulfilled} and {@code onRejected}&quot;,&quot;   * callbacks added to this Promise by calls to {@code then()}.&quot;,&quot;   * @private {?goog.Promise.CallbackEntry_}&quot;,&quot;   */&quot;,&quot;  this.callbackEntriesTail_ = null;&quot;,null,&quot;  /**&quot;,&quot;   * Whether the Promise is in the queue of Promises to execute.&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.executing_ = false;&quot;,null,&quot;  if (goog.Promise.UNHANDLED_REJECTION_DELAY &gt; 0) {&quot;,&quot;    /**&quot;,&quot;     * A timeout ID used when the {@code UNHANDLED_REJECTION_DELAY} is greater&quot;,&quot;     * than 0 milliseconds. The ID is set when the Promise is rejected, and&quot;,&quot;     * cleared only if an {@code onRejected} callback is invoked for the&quot;,&quot;     * Promise (or one of its descendants) before the delay is exceeded.&quot;,&quot;     *&quot;,&quot;     * If the rejection is not handled before the timeout completes, the&quot;,&quot;     * rejection reason is passed to the unhandled rejection handler.&quot;,&quot;     * @private {number}&quot;,&quot;     */&quot;,&quot;    this.unhandledRejectionId_ = 0;&quot;,&quot;  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {&quot;,&quot;    /**&quot;,&quot;     * When the {@code UNHANDLED_REJECTION_DELAY} is set to 0 milliseconds, a&quot;,&quot;     * boolean that is set if the Promise is rejected, and reset to false if an&quot;,&quot;     * {@code onRejected} callback is invoked for the Promise (or one of its&quot;,&quot;     * descendants). If the rejection is not handled before the next timestep,&quot;,&quot;     * the rejection reason is passed to the unhandled rejection handler.&quot;,&quot;     * @private {boolean}&quot;,&quot;     */&quot;,&quot;    this.hadUnhandledRejection_ = false;&quot;,&quot;  }&quot;,null,&quot;  if (goog.Promise.LONG_STACK_TRACES) {&quot;,&quot;    /**&quot;,&quot;     * A list of stack trace frames pointing to the locations where this Promise&quot;,&quot;     * was created or had callbacks added to it. Saved to add additional context&quot;,&quot;     * to stack traces when an exception is thrown.&quot;,&quot;     * @private {!Array&lt;string&gt;}&quot;,&quot;     */&quot;,&quot;    this.stack_ = [];&quot;,&quot;    this.addStackTrace_(new Error(&#39;created&#39;));&quot;,null,&quot;    /**&quot;,&quot;     * Index of the most recently executed stack frame entry.&quot;,&quot;     * @private {number}&quot;,&quot;     */&quot;,&quot;    this.currentStep_ = 0;&quot;,&quot;  }&quot;,null,&quot;  // As an optimization, we can skip this if resolver is goog.nullFunction.&quot;,&quot;  // This value is passed internally when creating a promise which will be&quot;,&quot;  // resolved through a more optimized path.&quot;,&quot;  if (resolver != goog.nullFunction) {&quot;,&quot;    try {&quot;,&quot;      var self = this;&quot;,&quot;      resolver.call(&quot;,&quot;          opt_context,&quot;,&quot;          function(value) {&quot;,&quot;            self.resolve_(goog.Promise.State_.FULFILLED, value);&quot;,&quot;          },&quot;,&quot;          function(reason) {&quot;,&quot;            if (goog.DEBUG &amp;&amp;&quot;,&quot;                !(reason instanceof goog.Promise.CancellationError)) {&quot;,&quot;              try {&quot;,&quot;                // Promise was rejected. Step up one call frame to see why.&quot;,&quot;                if (reason instanceof Error) {&quot;,&quot;                  throw reason;&quot;,&quot;                } else {&quot;,&quot;                  throw new Error(&#39;Promise rejected.&#39;);&quot;,&quot;                }&quot;,&quot;              } catch (e) {&quot;,&quot;                // Only thrown so browser dev tools can catch rejections of&quot;,&quot;                // promises when the option to break on caught exceptions is&quot;,&quot;                // activated.&quot;,&quot;              }&quot;,&quot;            }&quot;,&quot;            self.resolve_(goog.Promise.State_.REJECTED, reason);&quot;,&quot;          });&quot;,&quot;    } catch (e) {&quot;,&quot;      this.resolve_(goog.Promise.State_.REJECTED, e);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether traces of {@code then} calls should be included in&quot;,&quot; * exceptions thrown&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.Promise.LONG_STACK_TRACES&#39;, false);&quot;,null,null,&quot;/**&quot;,&quot; * @define {number} The delay in milliseconds before a rejected Promise&#39;s reason&quot;,&quot; * is passed to the rejection handler. By default, the rejection handler&quot;,&quot; * rethrows the rejection reason so that it appears in the developer console or&quot;,&quot; * {@code window.onerror} handler.&quot;,&quot; *&quot;,&quot; * Rejections are rethrown as quickly as possible by default. A negative value&quot;,&quot; * disables rejection handling entirely.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.Promise.UNHANDLED_REJECTION_DELAY&#39;, 0);&quot;,null,null,&quot;/**&quot;,&quot; * The possible internal states for a Promise. These states are not directly&quot;,&quot; * observable to external callers.&quot;,&quot; * @enum {number}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.State_ = {&quot;,&quot;  /** The Promise is waiting for resolution. */&quot;,&quot;  PENDING: 0,&quot;,null,&quot;  /** The Promise is blocked waiting for the result of another Thenable. */&quot;,&quot;  BLOCKED: 1,&quot;,null,&quot;  /** The Promise has been resolved with a fulfillment value. */&quot;,&quot;  FULFILLED: 2,&quot;,null,&quot;  /** The Promise has been resolved with a rejection reason. */&quot;,&quot;  REJECTED: 3&quot;,&quot;};&quot;,null,null,null,&quot;/**&quot;,&quot; * Entries in the callback chain. Each call to {@code then},&quot;,&quot; * {@code thenCatch}, or {@code thenAlways} creates an entry containing the&quot;,&quot; * functions that may be invoked once the Promise is settled.&quot;,&quot; *&quot;,&quot; * @private @final @struct @constructor&quot;,&quot; */&quot;,&quot;goog.Promise.CallbackEntry_ = function() {&quot;,&quot;  /** @type {?goog.Promise} */&quot;,&quot;  this.child = null;&quot;,&quot;  /** @type {Function} */&quot;,&quot;  this.onFulfilled = null;&quot;,&quot;  /** @type {Function} */&quot;,&quot;  this.onRejected = null;&quot;,&quot;  /** @type {?} */&quot;,&quot;  this.context = null;&quot;,&quot;  /** @type {?goog.Promise.CallbackEntry_} */&quot;,&quot;  this.next = null;&quot;,null,&quot;  /**&quot;,&quot;   * A boolean value to indicate this is a \&quot;thenAlways\&quot; callback entry.&quot;,&quot;   * Unlike a normal \&quot;then/thenVoid\&quot; a \&quot;thenAlways doesn&#39;t participate&quot;,&quot;   * in \&quot;cancel\&quot; considerations but is simply an observer and requires&quot;,&quot;   * special handling.&quot;,&quot;   * @type {boolean}&quot;,&quot;   */&quot;,&quot;  this.always = false;&quot;,&quot;};&quot;,null,null,&quot;/** clear the object prior to reuse */&quot;,&quot;goog.Promise.CallbackEntry_.prototype.reset = function() {&quot;,&quot;  this.child = null;&quot;,&quot;  this.onFulfilled = null;&quot;,&quot;  this.onRejected = null;&quot;,&quot;  this.context = null;&quot;,&quot;  this.always = false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @define {number} The number of currently unused objects to keep around for&quot;,&quot; *    reuse.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.Promise.DEFAULT_MAX_UNUSED&#39;, 100);&quot;,null,null,&quot;/** @const @private {goog.async.FreeList&lt;!goog.Promise.CallbackEntry_&gt;} */&quot;,&quot;goog.Promise.freelist_ = new goog.async.FreeList(&quot;,&quot;    function() { return new goog.Promise.CallbackEntry_(); },&quot;,&quot;    function(item) { item.reset(); }, goog.Promise.DEFAULT_MAX_UNUSED);&quot;,null,null,&quot;/**&quot;,&quot; * @param {Function} onFulfilled&quot;,&quot; * @param {Function} onRejected&quot;,&quot; * @param {?} context&quot;,&quot; * @return {!goog.Promise.CallbackEntry_}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.getCallbackEntry_ = function(onFulfilled, onRejected, context) {&quot;,&quot;  var entry = goog.Promise.freelist_.get();&quot;,&quot;  entry.onFulfilled = onFulfilled;&quot;,&quot;  entry.onRejected = onRejected;&quot;,&quot;  entry.context = context;&quot;,&quot;  return entry;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {!goog.Promise.CallbackEntry_} entry&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.returnEntry_ = function(entry) {&quot;,&quot;  goog.Promise.freelist_.put(entry);&quot;,&quot;};&quot;,null,null,&quot;// NOTE: this is the same template expression as is used for&quot;,&quot;// goog.IThenable.prototype.then&quot;,null,null,&quot;/**&quot;,&quot; * @param {VALUE=} opt_value&quot;,&quot; * @return {RESULT} A new Promise that is immediately resolved&quot;,&quot; *     with the given value. If the input value is already a goog.Promise, it&quot;,&quot; *     will be returned immediately without creating a new instance.&quot;,&quot; * @template VALUE&quot;,&quot; * @template RESULT := type(&#39;goog.Promise&#39;,&quot;,&quot; *     cond(isUnknown(VALUE), unknown(),&quot;,&quot; *       mapunion(VALUE, (V) =&gt;&quot;,&quot; *         cond(isTemplatized(V) &amp;&amp; sub(rawTypeOf(V), &#39;IThenable&#39;),&quot;,&quot; *           templateTypeOf(V, 0),&quot;,&quot; *           cond(sub(V, &#39;Thenable&#39;),&quot;,&quot; *              unknown(),&quot;,&quot; *              V)))))&quot;,&quot; * =:&quot;,&quot; */&quot;,&quot;goog.Promise.resolve = function(opt_value) {&quot;,&quot;  if (opt_value instanceof goog.Promise) {&quot;,&quot;    // Avoid creating a new object if we already have a promise object&quot;,&quot;    // of the correct type.&quot;,&quot;    return opt_value;&quot;,&quot;  }&quot;,null,&quot;  // Passing goog.nullFunction will cause the constructor to take an optimized&quot;,&quot;  // path that skips calling the resolver function.&quot;,&quot;  var promise = new goog.Promise(goog.nullFunction);&quot;,&quot;  promise.resolve_(goog.Promise.State_.FULFILLED, opt_value);&quot;,&quot;  return promise;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {*=} opt_reason&quot;,&quot; * @return {!goog.Promise} A new Promise that is immediately rejected with the&quot;,&quot; *     given reason.&quot;,&quot; */&quot;,&quot;goog.Promise.reject = function(opt_reason) {&quot;,&quot;  return new goog.Promise(function(resolve, reject) { reject(opt_reason); });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * This is identical to&quot;,&quot; * {@code goog.Promise.resolve(value).then(onFulfilled, onRejected)}, but it&quot;,&quot; * avoids creating an unnecessary wrapper Promise when {@code value} is already&quot;,&quot; * thenable.&quot;,&quot; *&quot;,&quot; * @param {?(goog.Thenable&lt;TYPE&gt;|Thenable|TYPE)} value&quot;,&quot; * @param {function(TYPE): ?} onFulfilled&quot;,&quot; * @param {function(*): *} onRejected&quot;,&quot; * @template TYPE&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.resolveThen_ = function(value, onFulfilled, onRejected) {&quot;,&quot;  var isThenable =&quot;,&quot;      goog.Promise.maybeThen_(value, onFulfilled, onRejected, null);&quot;,&quot;  if (!isThenable) {&quot;,&quot;    goog.async.run(goog.partial(onFulfilled, value));&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {!Array&lt;?(goog.Promise&lt;TYPE&gt;|goog.Thenable&lt;TYPE&gt;|Thenable|*)&gt;}&quot;,&quot; *     promises&quot;,&quot; * @return {!goog.Promise&lt;TYPE&gt;} A Promise that receives the result of the&quot;,&quot; *     first Promise (or Promise-like) input to settle immediately after it&quot;,&quot; *     settles.&quot;,&quot; * @template TYPE&quot;,&quot; */&quot;,&quot;goog.Promise.race = function(promises) {&quot;,&quot;  return new goog.Promise(function(resolve, reject) {&quot;,&quot;    if (!promises.length) {&quot;,&quot;      resolve(undefined);&quot;,&quot;    }&quot;,&quot;    for (var i = 0, promise; i &lt; promises.length; i++) {&quot;,&quot;      promise = promises[i];&quot;,&quot;      goog.Promise.resolveThen_(promise, resolve, reject);&quot;,&quot;    }&quot;,&quot;  });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {!Array&lt;?(goog.Promise&lt;TYPE&gt;|goog.Thenable&lt;TYPE&gt;|Thenable|*)&gt;}&quot;,&quot; *     promises&quot;,&quot; * @return {!goog.Promise&lt;!Array&lt;TYPE&gt;&gt;} A Promise that receives a list of&quot;,&quot; *     every fulfilled value once every input Promise (or Promise-like) is&quot;,&quot; *     successfully fulfilled, or is rejected with the first rejection reason&quot;,&quot; *     immediately after it is rejected.&quot;,&quot; * @template TYPE&quot;,&quot; */&quot;,&quot;goog.Promise.all = function(promises) {&quot;,&quot;  return new goog.Promise(function(resolve, reject) {&quot;,&quot;    var toFulfill = promises.length;&quot;,&quot;    var values = [];&quot;,null,&quot;    if (!toFulfill) {&quot;,&quot;      resolve(values);&quot;,&quot;      return;&quot;,&quot;    }&quot;,null,&quot;    var onFulfill = function(index, value) {&quot;,&quot;      toFulfill--;&quot;,&quot;      values[index] = value;&quot;,&quot;      if (toFulfill == 0) {&quot;,&quot;        resolve(values);&quot;,&quot;      }&quot;,&quot;    };&quot;,null,&quot;    var onReject = function(reason) { reject(reason); };&quot;,null,&quot;    for (var i = 0, promise; i &lt; promises.length; i++) {&quot;,&quot;      promise = promises[i];&quot;,&quot;      goog.Promise.resolveThen_(promise, goog.partial(onFulfill, i), onReject);&quot;,&quot;    }&quot;,&quot;  });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {!Array&lt;?(goog.Promise&lt;TYPE&gt;|goog.Thenable&lt;TYPE&gt;|Thenable|*)&gt;}&quot;,&quot; *     promises&quot;,&quot; * @return {!goog.Promise&lt;!Array&lt;{&quot;,&quot; *     fulfilled: boolean,&quot;,&quot; *     value: (TYPE|undefined),&quot;,&quot; *     reason: (*|undefined)}&gt;&gt;} A Promise that resolves with a list of&quot;,&quot; *         result objects once all input Promises (or Promise-like) have&quot;,&quot; *         settled. Each result object contains a &#39;fulfilled&#39; boolean indicating&quot;,&quot; *         whether an input Promise was fulfilled or rejected. For fulfilled&quot;,&quot; *         Promises, the resulting value is stored in the &#39;value&#39; field. For&quot;,&quot; *         rejected Promises, the rejection reason is stored in the &#39;reason&#39;&quot;,&quot; *         field.&quot;,&quot; * @template TYPE&quot;,&quot; */&quot;,&quot;goog.Promise.allSettled = function(promises) {&quot;,&quot;  return new goog.Promise(function(resolve, reject) {&quot;,&quot;    var toSettle = promises.length;&quot;,&quot;    var results = [];&quot;,null,&quot;    if (!toSettle) {&quot;,&quot;      resolve(results);&quot;,&quot;      return;&quot;,&quot;    }&quot;,null,&quot;    var onSettled = function(index, fulfilled, result) {&quot;,&quot;      toSettle--;&quot;,&quot;      results[index] = fulfilled ? {fulfilled: true, value: result} :&quot;,&quot;                                   {fulfilled: false, reason: result};&quot;,&quot;      if (toSettle == 0) {&quot;,&quot;        resolve(results);&quot;,&quot;      }&quot;,&quot;    };&quot;,null,&quot;    for (var i = 0, promise; i &lt; promises.length; i++) {&quot;,&quot;      promise = promises[i];&quot;,&quot;      goog.Promise.resolveThen_(&quot;,&quot;          promise, goog.partial(onSettled, i, true /* fulfilled */),&quot;,&quot;          goog.partial(onSettled, i, false /* fulfilled */));&quot;,&quot;    }&quot;,&quot;  });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {!Array&lt;?(goog.Promise&lt;TYPE&gt;|goog.Thenable&lt;TYPE&gt;|Thenable|*)&gt;}&quot;,&quot; *     promises&quot;,&quot; * @return {!goog.Promise&lt;TYPE&gt;} A Promise that receives the value of the first&quot;,&quot; *     input to be fulfilled, or is rejected with a list of every rejection&quot;,&quot; *     reason if all inputs are rejected.&quot;,&quot; * @template TYPE&quot;,&quot; */&quot;,&quot;goog.Promise.firstFulfilled = function(promises) {&quot;,&quot;  return new goog.Promise(function(resolve, reject) {&quot;,&quot;    var toReject = promises.length;&quot;,&quot;    var reasons = [];&quot;,null,&quot;    if (!toReject) {&quot;,&quot;      resolve(undefined);&quot;,&quot;      return;&quot;,&quot;    }&quot;,null,&quot;    var onFulfill = function(value) { resolve(value); };&quot;,null,&quot;    var onReject = function(index, reason) {&quot;,&quot;      toReject--;&quot;,&quot;      reasons[index] = reason;&quot;,&quot;      if (toReject == 0) {&quot;,&quot;        reject(reasons);&quot;,&quot;      }&quot;,&quot;    };&quot;,null,&quot;    for (var i = 0, promise; i &lt; promises.length; i++) {&quot;,&quot;      promise = promises[i];&quot;,&quot;      goog.Promise.resolveThen_(promise, onFulfill, goog.partial(onReject, i));&quot;,&quot;    }&quot;,&quot;  });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {!goog.promise.Resolver&lt;TYPE&gt;} Resolver wrapping the promise and its&quot;,&quot; *     resolve / reject functions. Resolving or rejecting the resolver&quot;,&quot; *     resolves or rejects the promise.&quot;,&quot; * @template TYPE&quot;,&quot; */&quot;,&quot;goog.Promise.withResolver = function() {&quot;,&quot;  var resolve, reject;&quot;,&quot;  var promise = new goog.Promise(function(rs, rj) {&quot;,&quot;    resolve = rs;&quot;,&quot;    reject = rj;&quot;,&quot;  });&quot;,&quot;  return new goog.Promise.Resolver_(promise, resolve, reject);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds callbacks that will operate on the result of the Promise, returning a&quot;,&quot; * new child Promise.&quot;,&quot; *&quot;,&quot; * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked&quot;,&quot; * with the fulfillment value as argument, and the child Promise will be&quot;,&quot; * fulfilled with the return value of the callback. If the callback throws an&quot;,&quot; * exception, the child Promise will be rejected with the thrown value instead.&quot;,&quot; *&quot;,&quot; * If the Promise is rejected, the {@code onRejected} callback will be invoked&quot;,&quot; * with the rejection reason as argument, and the child Promise will be resolved&quot;,&quot; * with the return value or rejected with the thrown value of the callback.&quot;,&quot; *&quot;,&quot; * @override&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.then = function(&quot;,&quot;    opt_onFulfilled, opt_onRejected, opt_context) {&quot;,null,&quot;  if (opt_onFulfilled != null) {&quot;,&quot;    goog.asserts.assertFunction(&quot;,&quot;        opt_onFulfilled, &#39;opt_onFulfilled should be a function.&#39;);&quot;,&quot;  }&quot;,&quot;  if (opt_onRejected != null) {&quot;,&quot;    goog.asserts.assertFunction(&quot;,&quot;        opt_onRejected,&quot;,&quot;        &#39;opt_onRejected should be a function. Did you pass opt_context &#39; +&quot;,&quot;            &#39;as the second argument instead of the third?&#39;);&quot;,&quot;  }&quot;,null,&quot;  if (goog.Promise.LONG_STACK_TRACES) {&quot;,&quot;    this.addStackTrace_(new Error(&#39;then&#39;));&quot;,&quot;  }&quot;,null,&quot;  return this.addChildPromise_(&quot;,&quot;      goog.isFunction(opt_onFulfilled) ? opt_onFulfilled : null,&quot;,&quot;      goog.isFunction(opt_onRejected) ? opt_onRejected : null, opt_context);&quot;,&quot;};&quot;,&quot;goog.Thenable.addImplementation(goog.Promise);&quot;,null,null,&quot;/**&quot;,&quot; * Adds callbacks that will operate on the result of the Promise without&quot;,&quot; * returning a child Promise (unlike \&quot;then\&quot;).&quot;,&quot; *&quot;,&quot; * If the Promise is fulfilled, the {@code onFulfilled} callback will be invoked&quot;,&quot; * with the fulfillment value as argument.&quot;,&quot; *&quot;,&quot; * If the Promise is rejected, the {@code onRejected} callback will be invoked&quot;,&quot; * with the rejection reason as argument.&quot;,&quot; *&quot;,&quot; * @param {?(function(this:THIS, TYPE):?)=} opt_onFulfilled A&quot;,&quot; *     function that will be invoked with the fulfillment value if the Promise&quot;,&quot; *     is fulfilled.&quot;,&quot; * @param {?(function(this:THIS, *): *)=} opt_onRejected A function that will&quot;,&quot; *     be invoked with the rejection reason if the Promise is rejected.&quot;,&quot; * @param {THIS=} opt_context An optional context object that will be the&quot;,&quot; *     execution context for the callbacks. By default, functions are executed&quot;,&quot; *     with the default this.&quot;,&quot; * @package&quot;,&quot; * @template THIS&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.thenVoid = function(&quot;,&quot;    opt_onFulfilled, opt_onRejected, opt_context) {&quot;,null,&quot;  if (opt_onFulfilled != null) {&quot;,&quot;    goog.asserts.assertFunction(&quot;,&quot;        opt_onFulfilled, &#39;opt_onFulfilled should be a function.&#39;);&quot;,&quot;  }&quot;,&quot;  if (opt_onRejected != null) {&quot;,&quot;    goog.asserts.assertFunction(&quot;,&quot;        opt_onRejected,&quot;,&quot;        &#39;opt_onRejected should be a function. Did you pass opt_context &#39; +&quot;,&quot;            &#39;as the second argument instead of the third?&#39;);&quot;,&quot;  }&quot;,null,&quot;  if (goog.Promise.LONG_STACK_TRACES) {&quot;,&quot;    this.addStackTrace_(new Error(&#39;then&#39;));&quot;,&quot;  }&quot;,null,&quot;  // Note: no default rejection handler is provided here as we need to&quot;,&quot;  // distinguish unhandled rejections.&quot;,&quot;  this.addCallbackEntry_(&quot;,&quot;      goog.Promise.getCallbackEntry_(&quot;,&quot;          opt_onFulfilled || goog.nullFunction, opt_onRejected || null,&quot;,&quot;          opt_context));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds a callback that will be invoked when the Promise is settled (fulfilled&quot;,&quot; * or rejected). The callback receives no argument, and no new child Promise is&quot;,&quot; * created. This is useful for ensuring that cleanup takes place after certain&quot;,&quot; * asynchronous operations. Callbacks added with {@code thenAlways} will be&quot;,&quot; * executed in the same order with other calls to {@code then},&quot;,&quot; * {@code thenAlways}, or {@code thenCatch}.&quot;,&quot; *&quot;,&quot; * Since it does not produce a new child Promise, cancellation propagation is&quot;,&quot; * not prevented by adding callbacks with {@code thenAlways}. A Promise that has&quot;,&quot; * a cleanup handler added with {@code thenAlways} will be canceled if all of&quot;,&quot; * its children created by {@code then} (or {@code thenCatch}) are canceled.&quot;,&quot; * Additionally, since any rejections are not passed to the callback, it does&quot;,&quot; * not stop the unhandled rejection handler from running.&quot;,&quot; *&quot;,&quot; * @param {function(this:THIS): void} onSettled A function that will be invoked&quot;,&quot; *     when the Promise is settled (fulfilled or rejected).&quot;,&quot; * @param {THIS=} opt_context An optional context object that will be the&quot;,&quot; *     execution context for the callbacks. By default, functions are executed&quot;,&quot; *     in the global scope.&quot;,&quot; * @return {!goog.Promise&lt;TYPE&gt;} This Promise, for chaining additional calls.&quot;,&quot; * @template THIS&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.thenAlways = function(onSettled, opt_context) {&quot;,&quot;  if (goog.Promise.LONG_STACK_TRACES) {&quot;,&quot;    this.addStackTrace_(new Error(&#39;thenAlways&#39;));&quot;,&quot;  }&quot;,null,&quot;  var entry = goog.Promise.getCallbackEntry_(onSettled, onSettled, opt_context);&quot;,&quot;  entry.always = true;&quot;,&quot;  this.addCallbackEntry_(entry);&quot;,&quot;  return this;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds a callback that will be invoked only if the Promise is rejected. This&quot;,&quot; * is equivalent to {@code then(null, onRejected)}.&quot;,&quot; *&quot;,&quot; * @param {function(this:THIS, *): *} onRejected A function that will be&quot;,&quot; *     invoked with the rejection reason if the Promise is rejected.&quot;,&quot; * @param {THIS=} opt_context An optional context object that will be the&quot;,&quot; *     execution context for the callbacks. By default, functions are executed&quot;,&quot; *     in the global scope.&quot;,&quot; * @return {!goog.Promise} A new Promise that will receive the result of the&quot;,&quot; *     callback.&quot;,&quot; * @template THIS&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.thenCatch = function(onRejected, opt_context) {&quot;,&quot;  if (goog.Promise.LONG_STACK_TRACES) {&quot;,&quot;    this.addStackTrace_(new Error(&#39;thenCatch&#39;));&quot;,&quot;  }&quot;,&quot;  return this.addChildPromise_(null, onRejected, opt_context);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Cancels the Promise if it is still pending by rejecting it with a cancel&quot;,&quot; * Error. No action is performed if the Promise is already resolved.&quot;,&quot; *&quot;,&quot; * All child Promises of the canceled Promise will be rejected with the same&quot;,&quot; * cancel error, as with normal Promise rejection. If the Promise to be canceled&quot;,&quot; * is the only child of a pending Promise, the parent Promise will also be&quot;,&quot; * canceled. Cancellation may propagate upward through multiple generations.&quot;,&quot; *&quot;,&quot; * @param {string=} opt_message An optional debugging message for describing the&quot;,&quot; *     cancellation reason.&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.cancel = function(opt_message) {&quot;,&quot;  if (this.state_ == goog.Promise.State_.PENDING) {&quot;,&quot;    goog.async.run(function() {&quot;,&quot;      var err = new goog.Promise.CancellationError(opt_message);&quot;,&quot;      this.cancelInternal_(err);&quot;,&quot;    }, this);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Cancels this Promise with the given error.&quot;,&quot; *&quot;,&quot; * @param {!Error} err The cancellation error.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.cancelInternal_ = function(err) {&quot;,&quot;  if (this.state_ == goog.Promise.State_.PENDING) {&quot;,&quot;    if (this.parent_) {&quot;,&quot;      // Cancel the Promise and remove it from the parent&#39;s child list.&quot;,&quot;      this.parent_.cancelChild_(this, err);&quot;,&quot;      this.parent_ = null;&quot;,&quot;    } else {&quot;,&quot;      this.resolve_(goog.Promise.State_.REJECTED, err);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Cancels a child Promise from the list of callback entries. If the Promise has&quot;,&quot; * not already been resolved, reject it with a cancel error. If there are no&quot;,&quot; * other children in the list of callback entries, propagate the cancellation&quot;,&quot; * by canceling this Promise as well.&quot;,&quot; *&quot;,&quot; * @param {!goog.Promise} childPromise The Promise to cancel.&quot;,&quot; * @param {!Error} err The cancel error to use for rejecting the Promise.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.cancelChild_ = function(childPromise, err) {&quot;,&quot;  if (!this.callbackEntries_) {&quot;,&quot;    return;&quot;,&quot;  }&quot;,&quot;  var childCount = 0;&quot;,&quot;  var childEntry = null;&quot;,&quot;  var beforeChildEntry = null;&quot;,null,&quot;  // Find the callback entry for the childPromise, and count whether there are&quot;,&quot;  // additional child Promises.&quot;,&quot;  for (var entry = this.callbackEntries_; entry; entry = entry.next) {&quot;,&quot;    if (!entry.always) {&quot;,&quot;      childCount++;&quot;,&quot;      if (entry.child == childPromise) {&quot;,&quot;        childEntry = entry;&quot;,&quot;      }&quot;,&quot;      if (childEntry &amp;&amp; childCount &gt; 1) {&quot;,&quot;        break;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    if (!childEntry) {&quot;,&quot;      beforeChildEntry = entry;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // Can a child entry be missing?&quot;,null,&quot;  // If the child Promise was the only child, cancel this Promise as well.&quot;,&quot;  // Otherwise, reject only the child Promise with the cancel error.&quot;,&quot;  if (childEntry) {&quot;,&quot;    if (this.state_ == goog.Promise.State_.PENDING &amp;&amp; childCount == 1) {&quot;,&quot;      this.cancelInternal_(err);&quot;,&quot;    } else {&quot;,&quot;      if (beforeChildEntry) {&quot;,&quot;        this.removeEntryAfter_(beforeChildEntry);&quot;,&quot;      } else {&quot;,&quot;        this.popEntry_();&quot;,&quot;      }&quot;,null,&quot;      this.executeCallback_(childEntry, goog.Promise.State_.REJECTED, err);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds a callback entry to the current Promise, and schedules callback&quot;,&quot; * execution if the Promise has already been settled.&quot;,&quot; *&quot;,&quot; * @param {goog.Promise.CallbackEntry_} callbackEntry Record containing&quot;,&quot; *     {@code onFulfilled} and {@code onRejected} callbacks to execute after&quot;,&quot; *     the Promise is settled.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.addCallbackEntry_ = function(callbackEntry) {&quot;,&quot;  if (!this.hasEntry_() &amp;&amp; (this.state_ == goog.Promise.State_.FULFILLED ||&quot;,&quot;                            this.state_ == goog.Promise.State_.REJECTED)) {&quot;,&quot;    this.scheduleCallbacks_();&quot;,&quot;  }&quot;,&quot;  this.queueEntry_(callbackEntry);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a child Promise and adds it to the callback entry list. The result of&quot;,&quot; * the child Promise is determined by the state of the parent Promise and the&quot;,&quot; * result of the {@code onFulfilled} or {@code onRejected} callbacks as&quot;,&quot; * specified in the Promise resolution procedure.&quot;,&quot; *&quot;,&quot; * @see http://promisesaplus.com/#the__method&quot;,&quot; *&quot;,&quot; * @param {?function(this:THIS, TYPE):&quot;,&quot; *          (RESULT|goog.Promise&lt;RESULT&gt;|Thenable)} onFulfilled A callback that&quot;,&quot; *     will be invoked if the Promise is fulfilled, or null.&quot;,&quot; * @param {?function(this:THIS, *): *} onRejected A callback that will be&quot;,&quot; *     invoked if the Promise is rejected, or null.&quot;,&quot; * @param {THIS=} opt_context An optional execution context for the callbacks.&quot;,&quot; *     in the default calling context.&quot;,&quot; * @return {!goog.Promise} The child Promise.&quot;,&quot; * @template RESULT,THIS&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.addChildPromise_ = function(&quot;,&quot;    onFulfilled, onRejected, opt_context) {&quot;,null,&quot;  /** @type {goog.Promise.CallbackEntry_} */&quot;,&quot;  var callbackEntry = goog.Promise.getCallbackEntry_(null, null, null);&quot;,null,&quot;  callbackEntry.child = new goog.Promise(function(resolve, reject) {&quot;,&quot;    // Invoke onFulfilled, or resolve with the parent&#39;s value if absent.&quot;,&quot;    callbackEntry.onFulfilled = onFulfilled ? function(value) {&quot;,&quot;      try {&quot;,&quot;        var result = onFulfilled.call(opt_context, value);&quot;,&quot;        resolve(result);&quot;,&quot;      } catch (err) {&quot;,&quot;        reject(err);&quot;,&quot;      }&quot;,&quot;    } : resolve;&quot;,null,&quot;    // Invoke onRejected, or reject with the parent&#39;s reason if absent.&quot;,&quot;    callbackEntry.onRejected = onRejected ? function(reason) {&quot;,&quot;      try {&quot;,&quot;        var result = onRejected.call(opt_context, reason);&quot;,&quot;        if (!goog.isDef(result) &amp;&amp;&quot;,&quot;            reason instanceof goog.Promise.CancellationError) {&quot;,&quot;          // Propagate cancellation to children if no other result is returned.&quot;,&quot;          reject(reason);&quot;,&quot;        } else {&quot;,&quot;          resolve(result);&quot;,&quot;        }&quot;,&quot;      } catch (err) {&quot;,&quot;        reject(err);&quot;,&quot;      }&quot;,&quot;    } : reject;&quot;,&quot;  });&quot;,null,&quot;  callbackEntry.child.parent_ = this;&quot;,&quot;  this.addCallbackEntry_(callbackEntry);&quot;,&quot;  return callbackEntry.child;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Unblocks the Promise and fulfills it with the given value.&quot;,&quot; *&quot;,&quot; * @param {TYPE} value&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.unblockAndFulfill_ = function(value) {&quot;,&quot;  goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);&quot;,&quot;  this.state_ = goog.Promise.State_.PENDING;&quot;,&quot;  this.resolve_(goog.Promise.State_.FULFILLED, value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Unblocks the Promise and rejects it with the given rejection reason.&quot;,&quot; *&quot;,&quot; * @param {*} reason&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.unblockAndReject_ = function(reason) {&quot;,&quot;  goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);&quot;,&quot;  this.state_ = goog.Promise.State_.PENDING;&quot;,&quot;  this.resolve_(goog.Promise.State_.REJECTED, reason);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Attempts to resolve a Promise with a given resolution state and value. This&quot;,&quot; * is a no-op if the given Promise has already been resolved.&quot;,&quot; *&quot;,&quot; * If the given result is a Thenable (such as another Promise), the Promise will&quot;,&quot; * be settled with the same state and result as the Thenable once it is itself&quot;,&quot; * settled.&quot;,&quot; *&quot;,&quot; * If the given result is not a Thenable, the Promise will be settled (fulfilled&quot;,&quot; * or rejected) with that result based on the given state.&quot;,&quot; *&quot;,&quot; * @see http://promisesaplus.com/#the_promise_resolution_procedure&quot;,&quot; *&quot;,&quot; * @param {goog.Promise.State_} state&quot;,&quot; * @param {*} x The result to apply to the Promise.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.resolve_ = function(state, x) {&quot;,&quot;  if (this.state_ != goog.Promise.State_.PENDING) {&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  if (this === x) {&quot;,&quot;    state = goog.Promise.State_.REJECTED;&quot;,&quot;    x = new TypeError(&#39;Promise cannot resolve to itself&#39;);&quot;,&quot;  }&quot;,null,&quot;  this.state_ = goog.Promise.State_.BLOCKED;&quot;,&quot;  var isThenable = goog.Promise.maybeThen_(&quot;,&quot;      x, this.unblockAndFulfill_, this.unblockAndReject_, this);&quot;,&quot;  if (isThenable) {&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  this.result_ = x;&quot;,&quot;  this.state_ = state;&quot;,&quot;  // Since we can no longer be canceled, remove link to parent, so that the&quot;,&quot;  // child promise does not keep the parent promise alive.&quot;,&quot;  this.parent_ = null;&quot;,&quot;  this.scheduleCallbacks_();&quot;,null,&quot;  if (state == goog.Promise.State_.REJECTED &amp;&amp;&quot;,&quot;      !(x instanceof goog.Promise.CancellationError)) {&quot;,&quot;    goog.Promise.addUnhandledRejection_(this, x);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Invokes the \&quot;then\&quot; method of an input value if that value is a Thenable. This&quot;,&quot; * is a no-op if the value is not thenable.&quot;,&quot; *&quot;,&quot; * @param {?} value A potentially thenable value.&quot;,&quot; * @param {!Function} onFulfilled&quot;,&quot; * @param {!Function} onRejected&quot;,&quot; * @param {?} context&quot;,&quot; * @return {boolean} Whether the input value was thenable.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.maybeThen_ = function(value, onFulfilled, onRejected, context) {&quot;,&quot;  if (value instanceof goog.Promise) {&quot;,&quot;    value.thenVoid(onFulfilled, onRejected, context);&quot;,&quot;    return true;&quot;,&quot;  } else if (goog.Thenable.isImplementedBy(value)) {&quot;,&quot;    value = /** @type {!goog.Thenable} */ (value);&quot;,&quot;    value.then(onFulfilled, onRejected, context);&quot;,&quot;    return true;&quot;,&quot;  } else if (goog.isObject(value)) {&quot;,&quot;    try {&quot;,&quot;      var then = value[&#39;then&#39;];&quot;,&quot;      if (goog.isFunction(then)) {&quot;,&quot;        goog.Promise.tryThen_(value, then, onFulfilled, onRejected, context);&quot;,&quot;        return true;&quot;,&quot;      }&quot;,&quot;    } catch (e) {&quot;,&quot;      onRejected.call(context, e);&quot;,&quot;      return true;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  return false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Attempts to call the {@code then} method on an object in the hopes that it is&quot;,&quot; * a Promise-compatible instance. This allows interoperation between different&quot;,&quot; * Promise implementations, however a non-compliant object may cause a Promise&quot;,&quot; * to hang indefinitely. If the {@code then} method throws an exception, the&quot;,&quot; * dependent Promise will be rejected with the thrown value.&quot;,&quot; *&quot;,&quot; * @see http://promisesaplus.com/#point-70&quot;,&quot; *&quot;,&quot; * @param {Thenable} thenable An object with a {@code then} method that may be&quot;,&quot; *     compatible with the Promise/A+ specification.&quot;,&quot; * @param {!Function} then The {@code then} method of the Thenable object.&quot;,&quot; * @param {!Function} onFulfilled&quot;,&quot; * @param {!Function} onRejected&quot;,&quot; * @param {*} context&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.tryThen_ = function(&quot;,&quot;    thenable, then, onFulfilled, onRejected, context) {&quot;,null,&quot;  var called = false;&quot;,&quot;  var resolve = function(value) {&quot;,&quot;    if (!called) {&quot;,&quot;      called = true;&quot;,&quot;      onFulfilled.call(context, value);&quot;,&quot;    }&quot;,&quot;  };&quot;,null,&quot;  var reject = function(reason) {&quot;,&quot;    if (!called) {&quot;,&quot;      called = true;&quot;,&quot;      onRejected.call(context, reason);&quot;,&quot;    }&quot;,&quot;  };&quot;,null,&quot;  try {&quot;,&quot;    then.call(thenable, resolve, reject);&quot;,&quot;  } catch (e) {&quot;,&quot;    reject(e);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Executes the pending callbacks of a settled Promise after a timeout.&quot;,&quot; *&quot;,&quot; * Section 2.2.4 of the Promises/A+ specification requires that Promise&quot;,&quot; * callbacks must only be invoked from a call stack that only contains Promise&quot;,&quot; * implementation code, which we accomplish by invoking callback execution after&quot;,&quot; * a timeout. If {@code startExecution_} is called multiple times for the same&quot;,&quot; * Promise, the callback chain will be evaluated only once. Additional callbacks&quot;,&quot; * may be added during the evaluation phase, and will be executed in the same&quot;,&quot; * event loop.&quot;,&quot; *&quot;,&quot; * All Promises added to the waiting list during the same browser event loop&quot;,&quot; * will be executed in one batch to avoid using a separate timeout per Promise.&quot;,&quot; *&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.scheduleCallbacks_ = function() {&quot;,&quot;  if (!this.executing_) {&quot;,&quot;    this.executing_ = true;&quot;,&quot;    goog.async.run(this.executeCallbacks_, this);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {boolean} Whether there are any pending callbacks queued.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.hasEntry_ = function() {&quot;,&quot;  return !!this.callbackEntries_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {goog.Promise.CallbackEntry_} entry&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.queueEntry_ = function(entry) {&quot;,&quot;  goog.asserts.assert(entry.onFulfilled != null);&quot;,null,&quot;  if (this.callbackEntriesTail_) {&quot;,&quot;    this.callbackEntriesTail_.next = entry;&quot;,&quot;    this.callbackEntriesTail_ = entry;&quot;,&quot;  } else {&quot;,&quot;    // It the work queue was empty set the head too.&quot;,&quot;    this.callbackEntries_ = entry;&quot;,&quot;    this.callbackEntriesTail_ = entry;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {goog.Promise.CallbackEntry_} entry&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.popEntry_ = function() {&quot;,&quot;  var entry = null;&quot;,&quot;  if (this.callbackEntries_) {&quot;,&quot;    entry = this.callbackEntries_;&quot;,&quot;    this.callbackEntries_ = entry.next;&quot;,&quot;    entry.next = null;&quot;,&quot;  }&quot;,&quot;  // It the work queue is empty clear the tail too.&quot;,&quot;  if (!this.callbackEntries_) {&quot;,&quot;    this.callbackEntriesTail_ = null;&quot;,&quot;  }&quot;,null,&quot;  if (entry != null) {&quot;,&quot;    goog.asserts.assert(entry.onFulfilled != null);&quot;,&quot;  }&quot;,&quot;  return entry;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {goog.Promise.CallbackEntry_} previous&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.removeEntryAfter_ = function(previous) {&quot;,&quot;  goog.asserts.assert(this.callbackEntries_);&quot;,&quot;  goog.asserts.assert(previous != null);&quot;,&quot;  // If the last entry is being removed, update the tail&quot;,&quot;  if (previous.next == this.callbackEntriesTail_) {&quot;,&quot;    this.callbackEntriesTail_ = previous;&quot;,&quot;  }&quot;,null,&quot;  previous.next = previous.next.next;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Executes all pending callbacks for this Promise.&quot;,&quot; *&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.executeCallbacks_ = function() {&quot;,&quot;  var entry = null;&quot;,&quot;  while (entry = this.popEntry_()) {&quot;,&quot;    if (goog.Promise.LONG_STACK_TRACES) {&quot;,&quot;      this.currentStep_++;&quot;,&quot;    }&quot;,&quot;    this.executeCallback_(entry, this.state_, this.result_);&quot;,&quot;  }&quot;,&quot;  this.executing_ = false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Executes a pending callback for this Promise. Invokes an {@code onFulfilled}&quot;,&quot; * or {@code onRejected} callback based on the settled state of the Promise.&quot;,&quot; *&quot;,&quot; * @param {!goog.Promise.CallbackEntry_} callbackEntry An entry containing the&quot;,&quot; *     onFulfilled and/or onRejected callbacks for this step.&quot;,&quot; * @param {goog.Promise.State_} state The resolution status of the Promise,&quot;,&quot; *     either FULFILLED or REJECTED.&quot;,&quot; * @param {*} result The settled result of the Promise.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.executeCallback_ = function(&quot;,&quot;    callbackEntry, state, result) {&quot;,&quot;  // Cancel an unhandled rejection if the then/thenVoid call had an onRejected.&quot;,&quot;  if (state == goog.Promise.State_.REJECTED &amp;&amp; callbackEntry.onRejected &amp;&amp;&quot;,&quot;      !callbackEntry.always) {&quot;,&quot;    this.removeUnhandledRejection_();&quot;,&quot;  }&quot;,null,&quot;  if (callbackEntry.child) {&quot;,&quot;    // When the parent is settled, the child no longer needs to hold on to it,&quot;,&quot;    // as the parent can no longer be canceled.&quot;,&quot;    callbackEntry.child.parent_ = null;&quot;,&quot;    goog.Promise.invokeCallback_(callbackEntry, state, result);&quot;,&quot;  } else {&quot;,&quot;    // Callbacks created with thenAlways or thenVoid do not have the rejection&quot;,&quot;    // handling code normally set up in the child Promise.&quot;,&quot;    try {&quot;,&quot;      callbackEntry.always ?&quot;,&quot;          callbackEntry.onFulfilled.call(callbackEntry.context) :&quot;,&quot;          goog.Promise.invokeCallback_(callbackEntry, state, result);&quot;,&quot;    } catch (err) {&quot;,&quot;      goog.Promise.handleRejection_.call(null, err);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  goog.Promise.returnEntry_(callbackEntry);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Executes the onFulfilled or onRejected callback for a callbackEntry.&quot;,&quot; *&quot;,&quot; * @param {!goog.Promise.CallbackEntry_} callbackEntry&quot;,&quot; * @param {goog.Promise.State_} state&quot;,&quot; * @param {*} result&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.invokeCallback_ = function(callbackEntry, state, result) {&quot;,&quot;  if (state == goog.Promise.State_.FULFILLED) {&quot;,&quot;    callbackEntry.onFulfilled.call(callbackEntry.context, result);&quot;,&quot;  } else if (callbackEntry.onRejected) {&quot;,&quot;    callbackEntry.onRejected.call(callbackEntry.context, result);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Records a stack trace entry for functions that call {@code then} or the&quot;,&quot; * Promise constructor. May be disabled by unsetting {@code LONG_STACK_TRACES}.&quot;,&quot; *&quot;,&quot; * @param {!Error} err An Error object created by the calling function for&quot;,&quot; *     providing a stack trace.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.addStackTrace_ = function(err) {&quot;,&quot;  if (goog.Promise.LONG_STACK_TRACES &amp;&amp; goog.isString(err.stack)) {&quot;,&quot;    // Extract the third line of the stack trace, which is the entry for the&quot;,&quot;    // user function that called into Promise code.&quot;,&quot;    var trace = err.stack.split(&#39;\\n&#39;, 4)[3];&quot;,&quot;    var message = err.message;&quot;,null,&quot;    // Pad the message to align the traces.&quot;,&quot;    message += Array(11 - message.length).join(&#39; &#39;);&quot;,&quot;    this.stack_.push(message + trace);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds extra stack trace information to an exception for the list of&quot;,&quot; * asynchronous {@code then} calls that have been run for this Promise. Stack&quot;,&quot; * trace information is recorded in {@see #addStackTrace_}, and appended to&quot;,&quot; * rethrown errors when {@code LONG_STACK_TRACES} is enabled.&quot;,&quot; *&quot;,&quot; * @param {*} err An unhandled exception captured during callback execution.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.appendLongStack_ = function(err) {&quot;,&quot;  if (goog.Promise.LONG_STACK_TRACES &amp;&amp; err &amp;&amp; goog.isString(err.stack) &amp;&amp;&quot;,&quot;      this.stack_.length) {&quot;,&quot;    var longTrace = [&#39;Promise trace:&#39;];&quot;,null,&quot;    for (var promise = this; promise; promise = promise.parent_) {&quot;,&quot;      for (var i = this.currentStep_; i &gt;= 0; i--) {&quot;,&quot;        longTrace.push(promise.stack_[i]);&quot;,&quot;      }&quot;,&quot;      longTrace.push(&quot;,&quot;          &#39;Value: &#39; +&quot;,&quot;          &#39;[&#39; + (promise.state_ == goog.Promise.State_.REJECTED ? &#39;REJECTED&#39; :&quot;,&quot;                                                                  &#39;FULFILLED&#39;) +&quot;,&quot;          &#39;] &#39; +&quot;,&quot;          &#39;&lt;&#39; + String(promise.result_) + &#39;&gt;&#39;);&quot;,&quot;    }&quot;,&quot;    err.stack += &#39;\\n\\n&#39; + longTrace.join(&#39;\\n&#39;);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Marks this rejected Promise as having being handled. Also marks any parent&quot;,&quot; * Promises in the rejected state as handled. The rejection handler will no&quot;,&quot; * longer be invoked for this Promise (if it has not been called already).&quot;,&quot; *&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.prototype.removeUnhandledRejection_ = function() {&quot;,&quot;  if (goog.Promise.UNHANDLED_REJECTION_DELAY &gt; 0) {&quot;,&quot;    for (var p = this; p &amp;&amp; p.unhandledRejectionId_; p = p.parent_) {&quot;,&quot;      goog.global.clearTimeout(p.unhandledRejectionId_);&quot;,&quot;      p.unhandledRejectionId_ = 0;&quot;,&quot;    }&quot;,&quot;  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {&quot;,&quot;    for (var p = this; p &amp;&amp; p.hadUnhandledRejection_; p = p.parent_) {&quot;,&quot;      p.hadUnhandledRejection_ = false;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Marks this rejected Promise as unhandled. If no {@code onRejected} callback&quot;,&quot; * is called for this Promise before the {@code UNHANDLED_REJECTION_DELAY}&quot;,&quot; * expires, the reason will be passed to the unhandled rejection handler. The&quot;,&quot; * handler typically rethrows the rejection reason so that it becomes visible in&quot;,&quot; * the developer console.&quot;,&quot; *&quot;,&quot; * @param {!goog.Promise} promise The rejected Promise.&quot;,&quot; * @param {*} reason The Promise rejection reason.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.addUnhandledRejection_ = function(promise, reason) {&quot;,&quot;  if (goog.Promise.UNHANDLED_REJECTION_DELAY &gt; 0) {&quot;,&quot;    promise.unhandledRejectionId_ = goog.global.setTimeout(function() {&quot;,&quot;      promise.appendLongStack_(reason);&quot;,&quot;      goog.Promise.handleRejection_.call(null, reason);&quot;,&quot;    }, goog.Promise.UNHANDLED_REJECTION_DELAY);&quot;,null,&quot;  } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {&quot;,&quot;    promise.hadUnhandledRejection_ = true;&quot;,&quot;    goog.async.run(function() {&quot;,&quot;      if (promise.hadUnhandledRejection_) {&quot;,&quot;        promise.appendLongStack_(reason);&quot;,&quot;        goog.Promise.handleRejection_.call(null, reason);&quot;,&quot;      }&quot;,&quot;    });&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * A method that is invoked with the rejection reasons for Promises that are&quot;,&quot; * rejected but have no {@code onRejected} callbacks registered yet.&quot;,&quot; * @type {function(*)}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Promise.handleRejection_ = goog.async.throwException;&quot;,null,null,&quot;/**&quot;,&quot; * Sets a handler that will be called with reasons from unhandled rejected&quot;,&quot; * Promises. If the rejected Promise (or one of its descendants) has an&quot;,&quot; * {@code onRejected} callback registered, the rejection will be considered&quot;,&quot; * handled, and the rejection handler will not be called.&quot;,&quot; *&quot;,&quot; * By default, unhandled rejections are rethrown so that the error may be&quot;,&quot; * captured by the developer console or a {@code window.onerror} handler.&quot;,&quot; *&quot;,&quot; * @param {function(*)} handler A function that will be called with reasons from&quot;,&quot; *     rejected Promises. Defaults to {@code goog.async.throwException}.&quot;,&quot; */&quot;,&quot;goog.Promise.setUnhandledRejectionHandler = function(handler) {&quot;,&quot;  goog.Promise.handleRejection_ = handler;&quot;,&quot;};&quot;,null,null,null,&quot;/**&quot;,&quot; * Error used as a rejection reason for canceled Promises.&quot;,&quot; *&quot;,&quot; * @param {string=} opt_message&quot;,&quot; * @constructor&quot;,&quot; * @extends {goog.debug.Error}&quot;,&quot; * @final&quot;,&quot; */&quot;,&quot;goog.Promise.CancellationError = function(opt_message) {&quot;,&quot;  goog.Promise.CancellationError.base(this, &#39;constructor&#39;, opt_message);&quot;,&quot;};&quot;,&quot;goog.inherits(goog.Promise.CancellationError, goog.debug.Error);&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.Promise.CancellationError.prototype.name = &#39;cancel&#39;;&quot;,null,null,null,&quot;/**&quot;,&quot; * Internal implementation of the resolver interface.&quot;,&quot; *&quot;,&quot; * @param {!goog.Promise&lt;TYPE&gt;} promise&quot;,&quot; * @param {function((TYPE|goog.Promise&lt;TYPE&gt;|Thenable)=)} resolve&quot;,&quot; * @param {function(*=): void} reject&quot;,&quot; * @implements {goog.promise.Resolver&lt;TYPE&gt;}&quot;,&quot; * @final @struct&quot;,&quot; * @constructor&quot;,&quot; * @private&quot;,&quot; * @template TYPE&quot;,&quot; */&quot;,&quot;goog.Promise.Resolver_ = function(promise, resolve, reject) {&quot;,&quot;  /** @const */&quot;,&quot;  this.promise = promise;&quot;,null,&quot;  /** @const */&quot;,&quot;  this.resolve = resolve;&quot;,null,&quot;  /** @const */&quot;,&quot;  this.reject = reject;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>