<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>disposable.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;disposable.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/disposable/disposable.js&quot;,[&quot;// Copyright 2005 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Implements the disposable interface. The dispose method is used&quot;,&quot; * to clean up references and resources.&quot;,&quot; * @author arv@google.com (Erik Arvidsson)&quot;,&quot; */&quot;,null,null,&quot;goog.provide(&#39;goog.Disposable&#39;);&quot;,&quot;goog.provide(&#39;goog.dispose&#39;);&quot;,&quot;goog.provide(&#39;goog.disposeAll&#39;);&quot;,null,&quot;goog.require(&#39;goog.disposable.IDisposable&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * Class that provides the basic implementation for disposable objects. If your&quot;,&quot; * class holds one or more references to COM objects, DOM nodes, or other&quot;,&quot; * disposable objects, it should extend this class or implement the disposable&quot;,&quot; * interface (defined in goog.disposable.IDisposable).&quot;,&quot; * @constructor&quot;,&quot; * @implements {goog.disposable.IDisposable}&quot;,&quot; */&quot;,&quot;goog.Disposable = function() {&quot;,&quot;  /**&quot;,&quot;   * If monitoring the goog.Disposable instances is enabled, stores the creation&quot;,&quot;   * stack trace of the Disposable instance.&quot;,&quot;   * @type {string|undefined}&quot;,&quot;   */&quot;,&quot;  this.creationStack;&quot;,null,&quot;  if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {&quot;,&quot;    if (goog.Disposable.INCLUDE_STACK_ON_CREATION) {&quot;,&quot;      this.creationStack = new Error().stack;&quot;,&quot;    }&quot;,&quot;    goog.Disposable.instances_[goog.getUid(this)] = this;&quot;,&quot;  }&quot;,&quot;  // Support sealing&quot;,&quot;  this.disposed_ = this.disposed_;&quot;,&quot;  this.onDisposeCallbacks_ = this.onDisposeCallbacks_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @enum {number} Different monitoring modes for Disposable.&quot;,&quot; */&quot;,&quot;goog.Disposable.MonitoringMode = {&quot;,&quot;  /**&quot;,&quot;   * No monitoring.&quot;,&quot;   */&quot;,&quot;  OFF: 0,&quot;,&quot;  /**&quot;,&quot;   * Creating and disposing the goog.Disposable instances is monitored. All&quot;,&quot;   * disposable objects need to call the {@code goog.Disposable} base&quot;,&quot;   * constructor. The PERMANENT mode must be switched on before creating any&quot;,&quot;   * goog.Disposable instances.&quot;,&quot;   */&quot;,&quot;  PERMANENT: 1,&quot;,&quot;  /**&quot;,&quot;   * INTERACTIVE mode can be switched on and off on the fly without producing&quot;,&quot;   * errors. It also doesn&#39;t warn if the disposable objects don&#39;t call the&quot;,&quot;   * {@code goog.Disposable} base constructor.&quot;,&quot;   */&quot;,&quot;  INTERACTIVE: 2&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @define {number} The monitoring mode of the goog.Disposable&quot;,&quot; *     instances. Default is OFF. Switching on the monitoring is only&quot;,&quot; *     recommended for debugging because it has a significant impact on&quot;,&quot; *     performance and memory usage. If switched off, the monitoring code&quot;,&quot; *     compiles down to 0 bytes.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.Disposable.MONITORING_MODE&#39;, 0);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether to attach creation stack to each created disposable&quot;,&quot; *     instance; This is only relevant for when MonitoringMode != OFF.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.Disposable.INCLUDE_STACK_ON_CREATION&#39;, true);&quot;,null,null,&quot;/**&quot;,&quot; * Maps the unique ID of every undisposed {@code goog.Disposable} object to&quot;,&quot; * the object itself.&quot;,&quot; * @type {!Object&lt;number, !goog.Disposable&gt;}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Disposable.instances_ = {};&quot;,null,null,&quot;/**&quot;,&quot; * @return {!Array&lt;!goog.Disposable&gt;} All {@code goog.Disposable} objects that&quot;,&quot; *     haven&#39;t been disposed of.&quot;,&quot; */&quot;,&quot;goog.Disposable.getUndisposedObjects = function() {&quot;,&quot;  var ret = [];&quot;,&quot;  for (var id in goog.Disposable.instances_) {&quot;,&quot;    if (goog.Disposable.instances_.hasOwnProperty(id)) {&quot;,&quot;      ret.push(goog.Disposable.instances_[Number(id)]);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return ret;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Clears the registry of undisposed objects but doesn&#39;t dispose of them.&quot;,&quot; */&quot;,&quot;goog.Disposable.clearUndisposedObjects = function() {&quot;,&quot;  goog.Disposable.instances_ = {};&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Whether the object has been disposed of.&quot;,&quot; * @type {boolean}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Disposable.prototype.disposed_ = false;&quot;,null,null,&quot;/**&quot;,&quot; * Callbacks to invoke when this object is disposed.&quot;,&quot; * @type {Array&lt;!Function&gt;}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Disposable.prototype.onDisposeCallbacks_;&quot;,null,null,&quot;/**&quot;,&quot; * @return {boolean} Whether the object has been disposed of.&quot;,&quot; * @override&quot;,&quot; */&quot;,&quot;goog.Disposable.prototype.isDisposed = function() {&quot;,&quot;  return this.disposed_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {boolean} Whether the object has been disposed of.&quot;,&quot; * @deprecated Use {@link #isDisposed} instead.&quot;,&quot; */&quot;,&quot;goog.Disposable.prototype.getDisposed = goog.Disposable.prototype.isDisposed;&quot;,null,null,&quot;/**&quot;,&quot; * Disposes of the object. If the object hasn&#39;t already been disposed of, calls&quot;,&quot; * {@link #disposeInternal}. Classes that extend {@code goog.Disposable} should&quot;,&quot; * override {@link #disposeInternal} in order to delete references to COM&quot;,&quot; * objects, DOM nodes, and other disposable objects. Reentrant.&quot;,&quot; *&quot;,&quot; * @return {void} Nothing.&quot;,&quot; * @override&quot;,&quot; */&quot;,&quot;goog.Disposable.prototype.dispose = function() {&quot;,&quot;  if (!this.disposed_) {&quot;,&quot;    // Set disposed_ to true first, in case during the chain of disposal this&quot;,&quot;    // gets disposed recursively.&quot;,&quot;    this.disposed_ = true;&quot;,&quot;    this.disposeInternal();&quot;,&quot;    if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {&quot;,&quot;      var uid = goog.getUid(this);&quot;,&quot;      if (goog.Disposable.MONITORING_MODE ==&quot;,&quot;              goog.Disposable.MonitoringMode.PERMANENT &amp;&amp;&quot;,&quot;          !goog.Disposable.instances_.hasOwnProperty(uid)) {&quot;,&quot;        throw new Error(&quot;,&quot;            this + &#39; did not call the goog.Disposable base &#39; +&quot;,&quot;            &#39;constructor or was disposed of after a clearUndisposedObjects &#39; +&quot;,&quot;            &#39;call&#39;);&quot;,&quot;      }&quot;,&quot;      delete goog.Disposable.instances_[uid];&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Associates a disposable object with this object so that they will be disposed&quot;,&quot; * together.&quot;,&quot; * @param {goog.disposable.IDisposable} disposable that will be disposed when&quot;,&quot; *     this object is disposed.&quot;,&quot; */&quot;,&quot;goog.Disposable.prototype.registerDisposable = function(disposable) {&quot;,&quot;  this.addOnDisposeCallback(goog.partial(goog.dispose, disposable));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Invokes a callback function when this object is disposed. Callbacks are&quot;,&quot; * invoked in the order in which they were added. If a callback is added to&quot;,&quot; * an already disposed Disposable, it will be called immediately.&quot;,&quot; * @param {function(this:T):?} callback The callback function.&quot;,&quot; * @param {T=} opt_scope An optional scope to call the callback in.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.Disposable.prototype.addOnDisposeCallback = function(callback, opt_scope) {&quot;,&quot;  if (this.disposed_) {&quot;,&quot;    goog.isDef(opt_scope) ? callback.call(opt_scope) : callback();&quot;,&quot;    return;&quot;,&quot;  }&quot;,&quot;  if (!this.onDisposeCallbacks_) {&quot;,&quot;    this.onDisposeCallbacks_ = [];&quot;,&quot;  }&quot;,null,&quot;  this.onDisposeCallbacks_.push(&quot;,&quot;      goog.isDef(opt_scope) ? goog.bind(callback, opt_scope) : callback);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Deletes or nulls out any references to COM objects, DOM nodes, or other&quot;,&quot; * disposable objects. Classes that extend {@code goog.Disposable} should&quot;,&quot; * override this method.&quot;,&quot; * Not reentrant. To avoid calling it twice, it must only be called from the&quot;,&quot; * subclass&#39; {@code disposeInternal} method. Everywhere else the public&quot;,&quot; * {@code dispose} method must be used.&quot;,&quot; * For example:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; *   mypackage.MyClass = function() {&quot;,&quot; *     mypackage.MyClass.base(this, &#39;constructor&#39;);&quot;,&quot; *     // Constructor logic specific to MyClass.&quot;,&quot; *     ...&quot;,&quot; *   };&quot;,&quot; *   goog.inherits(mypackage.MyClass, goog.Disposable);&quot;,&quot; *&quot;,&quot; *   mypackage.MyClass.prototype.disposeInternal = function() {&quot;,&quot; *     // Dispose logic specific to MyClass.&quot;,&quot; *     ...&quot;,&quot; *     // Call superclass&#39;s disposeInternal at the end of the subclass&#39;s, like&quot;,&quot; *     // in C++, to avoid hard-to-catch issues.&quot;,&quot; *     mypackage.MyClass.base(this, &#39;disposeInternal&#39;);&quot;,&quot; *   };&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;goog.Disposable.prototype.disposeInternal = function() {&quot;,&quot;  if (this.onDisposeCallbacks_) {&quot;,&quot;    while (this.onDisposeCallbacks_.length) {&quot;,&quot;      this.onDisposeCallbacks_.shift()();&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns True if we can verify the object is disposed.&quot;,&quot; * Calls {@code isDisposed} on the argument if it supports it.  If obj&quot;,&quot; * is not an object with an isDisposed() method, return false.&quot;,&quot; * @param {*} obj The object to investigate.&quot;,&quot; * @return {boolean} True if we can verify the object is disposed.&quot;,&quot; */&quot;,&quot;goog.Disposable.isDisposed = function(obj) {&quot;,&quot;  if (obj &amp;&amp; typeof obj.isDisposed == &#39;function&#39;) {&quot;,&quot;    return obj.isDisposed();&quot;,&quot;  }&quot;,&quot;  return false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Calls {@code dispose} on the argument if it supports it. If obj is not an&quot;,&quot; *     object with a dispose() method, this is a no-op.&quot;,&quot; * @param {*} obj The object to dispose of.&quot;,&quot; */&quot;,&quot;goog.dispose = function(obj) {&quot;,&quot;  if (obj &amp;&amp; typeof obj.dispose == &#39;function&#39;) {&quot;,&quot;    obj.dispose();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Calls {@code dispose} on each member of the list that supports it. (If the&quot;,&quot; * member is an ArrayLike, then {@code goog.disposeAll()} will be called&quot;,&quot; * recursively on each of its members.) If the member is not an object with a&quot;,&quot; * {@code dispose()} method, then it is ignored.&quot;,&quot; * @param {...*} var_args The list.&quot;,&quot; */&quot;,&quot;goog.disposeAll = function(var_args) {&quot;,&quot;  for (var i = 0, len = arguments.length; i &lt; len; ++i) {&quot;,&quot;    var disposable = arguments[i];&quot;,&quot;    if (goog.isArrayLike(disposable)) {&quot;,&quot;      goog.disposeAll.apply(null, disposable);&quot;,&quot;    } else {&quot;,&quot;      goog.dispose(disposable);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>