<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>debug.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;debug.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/debug/debug.js&quot;,[&quot;// Copyright 2006 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Logging and debugging utilities.&quot;,&quot; *&quot;,&quot; * @see ../demos/debug.html&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.debug&#39;);&quot;,null,&quot;goog.require(&#39;goog.array&#39;);&quot;,&quot;goog.require(&#39;goog.debug.errorcontext&#39;);&quot;,&quot;goog.require(&#39;goog.userAgent&#39;);&quot;,null,null,&quot;/** @define {boolean} Whether logging should be enabled. */&quot;,&quot;goog.define(&#39;goog.debug.LOGGING_ENABLED&#39;, goog.DEBUG);&quot;,null,null,&quot;/** @define {boolean} Whether to force \&quot;sloppy\&quot; stack building. */&quot;,&quot;goog.define(&#39;goog.debug.FORCE_SLOPPY_STACKS&#39;, false);&quot;,null,null,&quot;/**&quot;,&quot; * Catches onerror events fired by windows and similar objects.&quot;,&quot; * @param {function(Object)} logFunc The function to call with the error&quot;,&quot; *    information.&quot;,&quot; * @param {boolean=} opt_cancel Whether to stop the error from reaching the&quot;,&quot; *    browser.&quot;,&quot; * @param {Object=} opt_target Object that fires onerror events.&quot;,&quot; */&quot;,&quot;goog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {&quot;,&quot;  var target = opt_target || goog.global;&quot;,&quot;  var oldErrorHandler = target.onerror;&quot;,&quot;  var retVal = !!opt_cancel;&quot;,null,&quot;  // Chrome interprets onerror return value backwards (http://crbug.com/92062)&quot;,&quot;  // until it was fixed in webkit revision r94061 (Webkit 535.3). This&quot;,&quot;  // workaround still needs to be skipped in Safari after the webkit change&quot;,&quot;  // gets pushed out in Safari.&quot;,&quot;  // See https://bugs.webkit.org/show_bug.cgi?id=67119&quot;,&quot;  if (goog.userAgent.WEBKIT &amp;&amp; !goog.userAgent.isVersionOrHigher(&#39;535.3&#39;)) {&quot;,&quot;    retVal = !retVal;&quot;,&quot;  }&quot;,null,&quot;  /**&quot;,&quot;   * New onerror handler for this target. This onerror handler follows the spec&quot;,&quot;   * according to&quot;,&quot;   * http://www.whatwg.org/specs/web-apps/current-work/#runtime-script-errors&quot;,&quot;   * The spec was changed in August 2013 to support receiving column information&quot;,&quot;   * and an error object for all scripts on the same origin or cross origin&quot;,&quot;   * scripts with the proper headers. See&quot;,&quot;   * https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror&quot;,&quot;   *&quot;,&quot;   * @param {string} message The error message. For cross-origin errors, this&quot;,&quot;   *     will be scrubbed to just \&quot;Script error.\&quot;. For new browsers that have&quot;,&quot;   *     updated to follow the latest spec, errors that come from origins that&quot;,&quot;   *     have proper cross origin headers will not be scrubbed.&quot;,&quot;   * @param {string} url The URL of the script that caused the error. The URL&quot;,&quot;   *     will be scrubbed to \&quot;\&quot; for cross origin scripts unless the script has&quot;,&quot;   *     proper cross origin headers and the browser has updated to the latest&quot;,&quot;   *     spec.&quot;,&quot;   * @param {number} line The line number in the script that the error&quot;,&quot;   *     occurred on.&quot;,&quot;   * @param {number=} opt_col The optional column number that the error&quot;,&quot;   *     occurred on. Only browsers that have updated to the latest spec will&quot;,&quot;   *     include this.&quot;,&quot;   * @param {Error=} opt_error The optional actual error object for this&quot;,&quot;   *     error that should include the stack. Only browsers that have updated&quot;,&quot;   *     to the latest spec will inlude this parameter.&quot;,&quot;   * @return {boolean} Whether to prevent the error from reaching the browser.&quot;,&quot;   */&quot;,&quot;  target.onerror = function(message, url, line, opt_col, opt_error) {&quot;,&quot;    if (oldErrorHandler) {&quot;,&quot;      oldErrorHandler(message, url, line, opt_col, opt_error);&quot;,&quot;    }&quot;,&quot;    logFunc({&quot;,&quot;      message: message,&quot;,&quot;      fileName: url,&quot;,&quot;      line: line,&quot;,&quot;      lineNumber: line,&quot;,&quot;      col: opt_col,&quot;,&quot;      error: opt_error&quot;,&quot;    });&quot;,&quot;    return retVal;&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a string representing an object and all its properties.&quot;,&quot; * @param {Object|null|undefined} obj Object to expose.&quot;,&quot; * @param {boolean=} opt_showFn Show the functions as well as the properties,&quot;,&quot; *     default is false.&quot;,&quot; * @return {string} The string representation of {@code obj}.&quot;,&quot; */&quot;,&quot;goog.debug.expose = function(obj, opt_showFn) {&quot;,&quot;  if (typeof obj == &#39;undefined&#39;) {&quot;,&quot;    return &#39;undefined&#39;;&quot;,&quot;  }&quot;,&quot;  if (obj == null) {&quot;,&quot;    return &#39;NULL&#39;;&quot;,&quot;  }&quot;,&quot;  var str = [];&quot;,null,&quot;  for (var x in obj) {&quot;,&quot;    if (!opt_showFn &amp;&amp; goog.isFunction(obj[x])) {&quot;,&quot;      continue;&quot;,&quot;    }&quot;,&quot;    var s = x + &#39; = &#39;;&quot;,null,&quot;    try {&quot;,&quot;      s += obj[x];&quot;,&quot;    } catch (e) {&quot;,&quot;      s += &#39;*** &#39; + e + &#39; ***&#39;;&quot;,&quot;    }&quot;,&quot;    str.push(s);&quot;,&quot;  }&quot;,&quot;  return str.join(&#39;\\n&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a string representing a given primitive or object, and for an&quot;,&quot; * object, all its properties and nested objects. NOTE: The output will include&quot;,&quot; * Uids on all objects that were exposed. Any added Uids will be removed before&quot;,&quot; * returning.&quot;,&quot; * @param {*} obj Object to expose.&quot;,&quot; * @param {boolean=} opt_showFn Also show properties that are functions (by&quot;,&quot; *     default, functions are omitted).&quot;,&quot; * @return {string} A string representation of {@code obj}.&quot;,&quot; */&quot;,&quot;goog.debug.deepExpose = function(obj, opt_showFn) {&quot;,&quot;  var str = [];&quot;,null,&quot;  // Track any objects where deepExpose added a Uid, so they can be cleaned up&quot;,&quot;  // before return. We do this globally, rather than only on ancestors so that&quot;,&quot;  // if the same object appears in the output, you can see it.&quot;,&quot;  var uidsToCleanup = [];&quot;,&quot;  var ancestorUids = {};&quot;,null,&quot;  var helper = function(obj, space) {&quot;,&quot;    var nestspace = space + &#39;  &#39;;&quot;,null,&quot;    var indentMultiline = function(str) {&quot;,&quot;      return str.replace(/\\n/g, &#39;\\n&#39; + space);&quot;,&quot;    };&quot;,null,null,&quot;    try {&quot;,&quot;      if (!goog.isDef(obj)) {&quot;,&quot;        str.push(&#39;undefined&#39;);&quot;,&quot;      } else if (goog.isNull(obj)) {&quot;,&quot;        str.push(&#39;NULL&#39;);&quot;,&quot;      } else if (goog.isString(obj)) {&quot;,&quot;        str.push(&#39;\&quot;&#39; + indentMultiline(obj) + &#39;\&quot;&#39;);&quot;,&quot;      } else if (goog.isFunction(obj)) {&quot;,&quot;        str.push(indentMultiline(String(obj)));&quot;,&quot;      } else if (goog.isObject(obj)) {&quot;,&quot;        // Add a Uid if needed. The struct calls implicitly adds them.&quot;,&quot;        if (!goog.hasUid(obj)) {&quot;,&quot;          uidsToCleanup.push(obj);&quot;,&quot;        }&quot;,&quot;        var uid = goog.getUid(obj);&quot;,&quot;        if (ancestorUids[uid]) {&quot;,&quot;          str.push(&#39;*** reference loop detected (id=&#39; + uid + &#39;) ***&#39;);&quot;,&quot;        } else {&quot;,&quot;          ancestorUids[uid] = true;&quot;,&quot;          str.push(&#39;{&#39;);&quot;,&quot;          for (var x in obj) {&quot;,&quot;            if (!opt_showFn &amp;&amp; goog.isFunction(obj[x])) {&quot;,&quot;              continue;&quot;,&quot;            }&quot;,&quot;            str.push(&#39;\\n&#39;);&quot;,&quot;            str.push(nestspace);&quot;,&quot;            str.push(x + &#39; = &#39;);&quot;,&quot;            helper(obj[x], nestspace);&quot;,&quot;          }&quot;,&quot;          str.push(&#39;\\n&#39; + space + &#39;}&#39;);&quot;,&quot;          delete ancestorUids[uid];&quot;,&quot;        }&quot;,&quot;      } else {&quot;,&quot;        str.push(obj);&quot;,&quot;      }&quot;,&quot;    } catch (e) {&quot;,&quot;      str.push(&#39;*** &#39; + e + &#39; ***&#39;);&quot;,&quot;    }&quot;,&quot;  };&quot;,null,&quot;  helper(obj, &#39;&#39;);&quot;,null,&quot;  // Cleanup any Uids that were added by the deepExpose.&quot;,&quot;  for (var i = 0; i &lt; uidsToCleanup.length; i++) {&quot;,&quot;    goog.removeUid(uidsToCleanup[i]);&quot;,&quot;  }&quot;,null,&quot;  return str.join(&#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Recursively outputs a nested array as a string.&quot;,&quot; * @param {Array&lt;?&gt;} arr The array.&quot;,&quot; * @return {string} String representing nested array.&quot;,&quot; */&quot;,&quot;goog.debug.exposeArray = function(arr) {&quot;,&quot;  var str = [];&quot;,&quot;  for (var i = 0; i &lt; arr.length; i++) {&quot;,&quot;    if (goog.isArray(arr[i])) {&quot;,&quot;      str.push(goog.debug.exposeArray(arr[i]));&quot;,&quot;    } else {&quot;,&quot;      str.push(arr[i]);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return &#39;[ &#39; + str.join(&#39;, &#39;) + &#39; ]&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Normalizes the error/exception object between browsers.&quot;,&quot; * @param {*} err Raw error object.&quot;,&quot; * @return {!{&quot;,&quot; *    message: (?|undefined),&quot;,&quot; *    name: (?|undefined),&quot;,&quot; *    lineNumber: (?|undefined),&quot;,&quot; *    fileName: (?|undefined),&quot;,&quot; *    stack: (?|undefined)&quot;,&quot; * }} Normalized error object.&quot;,&quot; */&quot;,&quot;goog.debug.normalizeErrorObject = function(err) {&quot;,&quot;  var href = goog.getObjectByName(&#39;window.location.href&#39;);&quot;,&quot;  if (goog.isString(err)) {&quot;,&quot;    return {&quot;,&quot;      &#39;message&#39;: err,&quot;,&quot;      &#39;name&#39;: &#39;Unknown error&#39;,&quot;,&quot;      &#39;lineNumber&#39;: &#39;Not available&#39;,&quot;,&quot;      &#39;fileName&#39;: href,&quot;,&quot;      &#39;stack&#39;: &#39;Not available&#39;&quot;,&quot;    };&quot;,&quot;  }&quot;,null,&quot;  var lineNumber, fileName;&quot;,&quot;  var threwError = false;&quot;,null,&quot;  try {&quot;,&quot;    lineNumber = err.lineNumber || err.line || &#39;Not available&#39;;&quot;,&quot;  } catch (e) {&quot;,&quot;    // Firefox 2 sometimes throws an error when accessing &#39;lineNumber&#39;:&quot;,&quot;    // Message: Permission denied to get property UnnamedClass.lineNumber&quot;,&quot;    lineNumber = &#39;Not available&#39;;&quot;,&quot;    threwError = true;&quot;,&quot;  }&quot;,null,&quot;  try {&quot;,&quot;    fileName = err.fileName || err.filename || err.sourceURL ||&quot;,&quot;        // $googDebugFname may be set before a call to eval to set the filename&quot;,&quot;        // that the eval is supposed to present.&quot;,&quot;        goog.global[&#39;$googDebugFname&#39;] || href;&quot;,&quot;  } catch (e) {&quot;,&quot;    // Firefox 2 may also throw an error when accessing &#39;filename&#39;.&quot;,&quot;    fileName = &#39;Not available&#39;;&quot;,&quot;    threwError = true;&quot;,&quot;  }&quot;,null,&quot;  // The IE Error object contains only the name and the message.&quot;,&quot;  // The Safari Error object uses the line and sourceURL fields.&quot;,&quot;  if (threwError || !err.lineNumber || !err.fileName || !err.stack ||&quot;,&quot;      !err.message || !err.name) {&quot;,&quot;    return {&quot;,&quot;      &#39;message&#39;: err.message || &#39;Not available&#39;,&quot;,&quot;      &#39;name&#39;: err.name || &#39;UnknownError&#39;,&quot;,&quot;      &#39;lineNumber&#39;: lineNumber,&quot;,&quot;      &#39;fileName&#39;: fileName,&quot;,&quot;      &#39;stack&#39;: err.stack || &#39;Not available&#39;&quot;,&quot;    };&quot;,&quot;  }&quot;,null,&quot;  // Standards error object&quot;,&quot;  // Typed !Object. Should be a subtype of the return type, but it&#39;s not.&quot;,&quot;  return /** @type {?} */ (err);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts an object to an Error using the object&#39;s toString if it&#39;s not&quot;,&quot; * already an Error, adds a stacktrace if there isn&#39;t one, and optionally adds&quot;,&quot; * an extra message.&quot;,&quot; * @param {*} err The original thrown error, object, or string.&quot;,&quot; * @param {string=} opt_message  optional additional message to add to the&quot;,&quot; *     error.&quot;,&quot; * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,&quot;,&quot; *     it is converted to an Error which is enhanced and returned.&quot;,&quot; */&quot;,&quot;goog.debug.enhanceError = function(err, opt_message) {&quot;,&quot;  var error;&quot;,&quot;  if (!(err instanceof Error)) {&quot;,&quot;    error = Error(err);&quot;,&quot;    if (Error.captureStackTrace) {&quot;,&quot;      // Trim this function off the call stack, if we can.&quot;,&quot;      Error.captureStackTrace(error, goog.debug.enhanceError);&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    error = err;&quot;,&quot;  }&quot;,null,&quot;  if (!error.stack) {&quot;,&quot;    error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);&quot;,&quot;  }&quot;,&quot;  if (opt_message) {&quot;,&quot;    // find the first unoccupied &#39;messageX&#39; property&quot;,&quot;    var x = 0;&quot;,&quot;    while (error[&#39;message&#39; + x]) {&quot;,&quot;      ++x;&quot;,&quot;    }&quot;,&quot;    error[&#39;message&#39; + x] = String(opt_message);&quot;,&quot;  }&quot;,&quot;  return error;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts an object to an Error using the object&#39;s toString if it&#39;s not&quot;,&quot; * already an Error, adds a stacktrace if there isn&#39;t one, and optionally adds&quot;,&quot; * context to the Error, which is reported by the closure error reporter.&quot;,&quot; * @param {*} err The original thrown error, object, or string.&quot;,&quot; * @param {!Object&lt;string, string&gt;=} opt_context Key-value context to add to the&quot;,&quot; *     Error.&quot;,&quot; * @return {!Error} If err is an Error, it is enhanced and returned. Otherwise,&quot;,&quot; *     it is converted to an Error which is enhanced and returned.&quot;,&quot; */&quot;,&quot;goog.debug.enhanceErrorWithContext = function(err, opt_context) {&quot;,&quot;  var error = goog.debug.enhanceError(err);&quot;,&quot;  if (opt_context) {&quot;,&quot;    for (var key in opt_context) {&quot;,&quot;      goog.debug.errorcontext.addErrorContext(error, key, opt_context[key]);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return error;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the current stack trace. Simple and iterative - doesn&#39;t worry about&quot;,&quot; * catching circular references or getting the args.&quot;,&quot; * @param {number=} opt_depth Optional maximum depth to trace back to.&quot;,&quot; * @return {string} A string with the function names of all functions in the&quot;,&quot; *     stack, separated by \\n.&quot;,&quot; * @suppress {es5Strict}&quot;,&quot; */&quot;,&quot;goog.debug.getStacktraceSimple = function(opt_depth) {&quot;,&quot;  if (!goog.debug.FORCE_SLOPPY_STACKS) {&quot;,&quot;    var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);&quot;,&quot;    if (stack) {&quot;,&quot;      return stack;&quot;,&quot;    }&quot;,&quot;    // NOTE: browsers that have strict mode support also have native \&quot;stack\&quot;&quot;,&quot;    // properties.  Fall-through for legacy browser support.&quot;,&quot;  }&quot;,null,&quot;  var sb = [];&quot;,&quot;  var fn = arguments.callee.caller;&quot;,&quot;  var depth = 0;&quot;,null,&quot;  while (fn &amp;&amp; (!opt_depth || depth &lt; opt_depth)) {&quot;,&quot;    sb.push(goog.debug.getFunctionName(fn));&quot;,&quot;    sb.push(&#39;()\\n&#39;);&quot;,null,&quot;    try {&quot;,&quot;      fn = fn.caller;&quot;,&quot;    } catch (e) {&quot;,&quot;      sb.push(&#39;[exception trying to get caller]\\n&#39;);&quot;,&quot;      break;&quot;,&quot;    }&quot;,&quot;    depth++;&quot;,&quot;    if (depth &gt;= goog.debug.MAX_STACK_DEPTH) {&quot;,&quot;      sb.push(&#39;[...long stack...]&#39;);&quot;,&quot;      break;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  if (opt_depth &amp;&amp; depth &gt;= opt_depth) {&quot;,&quot;    sb.push(&#39;[...reached max depth limit...]&#39;);&quot;,&quot;  } else {&quot;,&quot;    sb.push(&#39;[end]&#39;);&quot;,&quot;  }&quot;,null,&quot;  return sb.join(&#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Max length of stack to try and output&quot;,&quot; * @type {number}&quot;,&quot; */&quot;,&quot;goog.debug.MAX_STACK_DEPTH = 50;&quot;,null,null,&quot;/**&quot;,&quot; * @param {Function} fn The function to start getting the trace from.&quot;,&quot; * @return {?string}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.getNativeStackTrace_ = function(fn) {&quot;,&quot;  var tempErr = new Error();&quot;,&quot;  if (Error.captureStackTrace) {&quot;,&quot;    Error.captureStackTrace(tempErr, fn);&quot;,&quot;    return String(tempErr.stack);&quot;,&quot;  } else {&quot;,&quot;    // IE10, only adds stack traces when an exception is thrown.&quot;,&quot;    try {&quot;,&quot;      throw tempErr;&quot;,&quot;    } catch (e) {&quot;,&quot;      tempErr = e;&quot;,&quot;    }&quot;,&quot;    var stack = tempErr.stack;&quot;,&quot;    if (stack) {&quot;,&quot;      return String(stack);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the current stack trace, either starting from the caller or starting&quot;,&quot; * from a specified function that&#39;s currently on the call stack.&quot;,&quot; * @param {?Function=} fn If provided, when collecting the stack trace all&quot;,&quot; *     frames above the topmost call to this function, including that call,&quot;,&quot; *     will be left out of the stack trace.&quot;,&quot; * @return {string} Stack trace.&quot;,&quot; * @suppress {es5Strict}&quot;,&quot; */&quot;,&quot;goog.debug.getStacktrace = function(fn) {&quot;,&quot;  var stack;&quot;,&quot;  if (!goog.debug.FORCE_SLOPPY_STACKS) {&quot;,&quot;    // Try to get the stack trace from the environment if it is available.&quot;,&quot;    var contextFn = fn || goog.debug.getStacktrace;&quot;,&quot;    stack = goog.debug.getNativeStackTrace_(contextFn);&quot;,&quot;  }&quot;,&quot;  if (!stack) {&quot;,&quot;    // NOTE: browsers that have strict mode support also have native \&quot;stack\&quot;&quot;,&quot;    // properties. This function will throw in strict mode.&quot;,&quot;    stack = goog.debug.getStacktraceHelper_(fn || arguments.callee.caller, []);&quot;,&quot;  }&quot;,&quot;  return stack;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Private helper for getStacktrace().&quot;,&quot; * @param {?Function} fn If provided, when collecting the stack trace all&quot;,&quot; *     frames above the topmost call to this function, including that call,&quot;,&quot; *     will be left out of the stack trace.&quot;,&quot; * @param {Array&lt;!Function&gt;} visited List of functions visited so far.&quot;,&quot; * @return {string} Stack trace starting from function fn.&quot;,&quot; * @suppress {es5Strict}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.getStacktraceHelper_ = function(fn, visited) {&quot;,&quot;  var sb = [];&quot;,null,&quot;  // Circular reference, certain functions like bind seem to cause a recursive&quot;,&quot;  // loop so we need to catch circular references&quot;,&quot;  if (goog.array.contains(visited, fn)) {&quot;,&quot;    sb.push(&#39;[...circular reference...]&#39;);&quot;,null,&quot;    // Traverse the call stack until function not found or max depth is reached&quot;,&quot;  } else if (fn &amp;&amp; visited.length &lt; goog.debug.MAX_STACK_DEPTH) {&quot;,&quot;    sb.push(goog.debug.getFunctionName(fn) + &#39;(&#39;);&quot;,&quot;    var args = fn.arguments;&quot;,&quot;    // Args may be null for some special functions such as host objects or eval.&quot;,&quot;    for (var i = 0; args &amp;&amp; i &lt; args.length; i++) {&quot;,&quot;      if (i &gt; 0) {&quot;,&quot;        sb.push(&#39;, &#39;);&quot;,&quot;      }&quot;,&quot;      var argDesc;&quot;,&quot;      var arg = args[i];&quot;,&quot;      switch (typeof arg) {&quot;,&quot;        case &#39;object&#39;:&quot;,&quot;          argDesc = arg ? &#39;object&#39; : &#39;null&#39;;&quot;,&quot;          break;&quot;,null,&quot;        case &#39;string&#39;:&quot;,&quot;          argDesc = arg;&quot;,&quot;          break;&quot;,null,&quot;        case &#39;number&#39;:&quot;,&quot;          argDesc = String(arg);&quot;,&quot;          break;&quot;,null,&quot;        case &#39;boolean&#39;:&quot;,&quot;          argDesc = arg ? &#39;true&#39; : &#39;false&#39;;&quot;,&quot;          break;&quot;,null,&quot;        case &#39;function&#39;:&quot;,&quot;          argDesc = goog.debug.getFunctionName(arg);&quot;,&quot;          argDesc = argDesc ? argDesc : &#39;[fn]&#39;;&quot;,&quot;          break;&quot;,null,&quot;        case &#39;undefined&#39;:&quot;,&quot;        default:&quot;,&quot;          argDesc = typeof arg;&quot;,&quot;          break;&quot;,&quot;      }&quot;,null,&quot;      if (argDesc.length &gt; 40) {&quot;,&quot;        argDesc = argDesc.substr(0, 40) + &#39;...&#39;;&quot;,&quot;      }&quot;,&quot;      sb.push(argDesc);&quot;,&quot;    }&quot;,&quot;    visited.push(fn);&quot;,&quot;    sb.push(&#39;)\\n&#39;);&quot;,null,&quot;    try {&quot;,&quot;      sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));&quot;,&quot;    } catch (e) {&quot;,&quot;      sb.push(&#39;[exception trying to get caller]\\n&#39;);&quot;,&quot;    }&quot;,null,&quot;  } else if (fn) {&quot;,&quot;    sb.push(&#39;[...long stack...]&#39;);&quot;,&quot;  } else {&quot;,&quot;    sb.push(&#39;[end]&#39;);&quot;,&quot;  }&quot;,&quot;  return sb.join(&#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Set a custom function name resolver.&quot;,&quot; * @param {function(Function): string} resolver Resolves functions to their&quot;,&quot; *     names.&quot;,&quot; */&quot;,&quot;goog.debug.setFunctionResolver = function(resolver) {&quot;,&quot;  goog.debug.fnNameResolver_ = resolver;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets a function name&quot;,&quot; * @param {Function} fn Function to get name of.&quot;,&quot; * @return {string} Function&#39;s name.&quot;,&quot; */&quot;,&quot;goog.debug.getFunctionName = function(fn) {&quot;,&quot;  if (goog.debug.fnNameCache_[fn]) {&quot;,&quot;    return goog.debug.fnNameCache_[fn];&quot;,&quot;  }&quot;,&quot;  if (goog.debug.fnNameResolver_) {&quot;,&quot;    var name = goog.debug.fnNameResolver_(fn);&quot;,&quot;    if (name) {&quot;,&quot;      goog.debug.fnNameCache_[fn] = name;&quot;,&quot;      return name;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // Heuristically determine function name based on code.&quot;,&quot;  var functionSource = String(fn);&quot;,&quot;  if (!goog.debug.fnNameCache_[functionSource]) {&quot;,&quot;    var matches = /function ([^\\(]+)/.exec(functionSource);&quot;,&quot;    if (matches) {&quot;,&quot;      var method = matches[1];&quot;,&quot;      goog.debug.fnNameCache_[functionSource] = method;&quot;,&quot;    } else {&quot;,&quot;      goog.debug.fnNameCache_[functionSource] = &#39;[Anonymous]&#39;;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  return goog.debug.fnNameCache_[functionSource];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Makes whitespace visible by replacing it with printable characters.&quot;,&quot; * This is useful in finding diffrences between the expected and the actual&quot;,&quot; * output strings of a testcase.&quot;,&quot; * @param {string} string whose whitespace needs to be made visible.&quot;,&quot; * @return {string} string whose whitespace is made visible.&quot;,&quot; */&quot;,&quot;goog.debug.makeWhitespaceVisible = function(string) {&quot;,&quot;  return string.replace(/ /g, &#39;[_]&#39;)&quot;,&quot;      .replace(/\\f/g, &#39;[f]&#39;)&quot;,&quot;      .replace(/\\n/g, &#39;[n]\\n&#39;)&quot;,&quot;      .replace(/\\r/g, &#39;[r]&#39;)&quot;,&quot;      .replace(/\\t/g, &#39;[t]&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the type of a value. If a constructor is passed, and a suitable&quot;,&quot; * string cannot be found, &#39;unknown type name&#39; will be returned.&quot;,&quot; *&quot;,&quot; * &lt;p&gt;Forked rather than moved from {@link goog.asserts.getType_}&quot;,&quot; * to avoid adding a dependency to goog.asserts.&quot;,&quot; * @param {*} value A constructor, object, or primitive.&quot;,&quot; * @return {string} The best display name for the value, or &#39;unknown type name&#39;.&quot;,&quot; */&quot;,&quot;goog.debug.runtimeType = function(value) {&quot;,&quot;  if (value instanceof Function) {&quot;,&quot;    return value.displayName || value.name || &#39;unknown type name&#39;;&quot;,&quot;  } else if (value instanceof Object) {&quot;,&quot;    return value.constructor.displayName || value.constructor.name ||&quot;,&quot;        Object.prototype.toString.call(value);&quot;,&quot;  } else {&quot;,&quot;    return value === null ? &#39;null&#39; : typeof value;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Hash map for storing function names that have already been looked up.&quot;,&quot; * @type {Object}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.fnNameCache_ = {};&quot;,null,null,&quot;/**&quot;,&quot; * Resolves functions to their names.  Resolved function names will be cached.&quot;,&quot; * @type {function(Function):string}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.fnNameResolver_;&quot;,null,null,&quot;/**&quot;,&quot; * Private internal function to support goog.debug.freeze.&quot;,&quot; * @param {T} arg&quot;,&quot; * @return {T}&quot;,&quot; * @template T&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.freezeInternal_ = goog.DEBUG &amp;&amp; Object.freeze || function(arg) {&quot;,&quot;  return arg;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Freezes the given object, but only in debug mode (and in browsers that&quot;,&quot; * support it).  Note that this is a shallow freeze, so for deeply nested&quot;,&quot; * objects it must be called at every level to ensure deep immutability.&quot;,&quot; * @param {T} arg&quot;,&quot; * @return {T}&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.debug.freeze = function(arg) {&quot;,&quot;  // NOTE: this compiles to nothing, but hides the possible side effect of&quot;,&quot;  // freezeInternal_ from the compiler so that the entire call can be&quot;,&quot;  // removed if the result is not used.&quot;,&quot;  return {&quot;,&quot;    valueOf: function() {&quot;,&quot;      return goog.debug.freezeInternal_(arg);&quot;,&quot;    }&quot;,&quot;  }.valueOf();&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>