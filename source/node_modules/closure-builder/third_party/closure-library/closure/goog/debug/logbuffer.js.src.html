<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>logbuffer.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;logbuffer.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/debug/logbuffer.js&quot;,[&quot;// Copyright 2010 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview A buffer for log records. The purpose of this is to improve&quot;,&quot; * logging performance by re-using old objects when the buffer becomes full and&quot;,&quot; * to eliminate the need for each app to implement their own log buffer. The&quot;,&quot; * disadvantage to doing this is that log handlers cannot maintain references to&quot;,&quot; * log records and expect that they are not overwriten at a later point.&quot;,&quot; *&quot;,&quot; * @author agrieve@google.com (Andrew Grieve)&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.debug.LogBuffer&#39;);&quot;,null,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;goog.debug.LogRecord&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * Creates the log buffer.&quot;,&quot; * @constructor&quot;,&quot; * @final&quot;,&quot; */&quot;,&quot;goog.debug.LogBuffer = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      goog.debug.LogBuffer.isBufferingEnabled(),&quot;,&quot;      &#39;Cannot use goog.debug.LogBuffer without defining &#39; +&quot;,&quot;          &#39;goog.debug.LogBuffer.CAPACITY.&#39;);&quot;,&quot;  this.clear();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * A static method that always returns the same instance of LogBuffer.&quot;,&quot; * @return {!goog.debug.LogBuffer} The LogBuffer singleton instance.&quot;,&quot; */&quot;,&quot;goog.debug.LogBuffer.getInstance = function() {&quot;,&quot;  if (!goog.debug.LogBuffer.instance_) {&quot;,&quot;    // This function is written with the return statement after the assignment&quot;,&quot;    // to avoid the jscompiler StripCode bug described in http://b/2608064.&quot;,&quot;    // After that bug is fixed this can be refactored.&quot;,&quot;    goog.debug.LogBuffer.instance_ = new goog.debug.LogBuffer();&quot;,&quot;  }&quot;,&quot;  return goog.debug.LogBuffer.instance_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @define {number} The number of log records to buffer. 0 means disable&quot;,&quot; * buffering.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.debug.LogBuffer.CAPACITY&#39;, 0);&quot;,null,null,&quot;/**&quot;,&quot; * The array to store the records.&quot;,&quot; * @type {!Array&lt;!goog.debug.LogRecord|undefined&gt;}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.LogBuffer.prototype.buffer_;&quot;,null,null,&quot;/**&quot;,&quot; * The index of the most recently added record or -1 if there are no records.&quot;,&quot; * @type {number}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.LogBuffer.prototype.curIndex_;&quot;,null,null,&quot;/**&quot;,&quot; * Whether the buffer is at capacity.&quot;,&quot; * @type {boolean}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.LogBuffer.prototype.isFull_;&quot;,null,null,&quot;/**&quot;,&quot; * Adds a log record to the buffer, possibly overwriting the oldest record.&quot;,&quot; * @param {goog.debug.Logger.Level} level One of the level identifiers.&quot;,&quot; * @param {string} msg The string message.&quot;,&quot; * @param {string} loggerName The name of the source logger.&quot;,&quot; * @return {!goog.debug.LogRecord} The log record.&quot;,&quot; */&quot;,&quot;goog.debug.LogBuffer.prototype.addRecord = function(level, msg, loggerName) {&quot;,&quot;  var curIndex = (this.curIndex_ + 1) % goog.debug.LogBuffer.CAPACITY;&quot;,&quot;  this.curIndex_ = curIndex;&quot;,&quot;  if (this.isFull_) {&quot;,&quot;    var ret = this.buffer_[curIndex];&quot;,&quot;    ret.reset(level, msg, loggerName);&quot;,&quot;    return ret;&quot;,&quot;  }&quot;,&quot;  this.isFull_ = curIndex == goog.debug.LogBuffer.CAPACITY - 1;&quot;,&quot;  return this.buffer_[curIndex] =&quot;,&quot;             new goog.debug.LogRecord(level, msg, loggerName);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {boolean} Whether the log buffer is enabled.&quot;,&quot; */&quot;,&quot;goog.debug.LogBuffer.isBufferingEnabled = function() {&quot;,&quot;  return goog.debug.LogBuffer.CAPACITY &gt; 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes all buffered log records.&quot;,&quot; */&quot;,&quot;goog.debug.LogBuffer.prototype.clear = function() {&quot;,&quot;  this.buffer_ = new Array(goog.debug.LogBuffer.CAPACITY);&quot;,&quot;  this.curIndex_ = -1;&quot;,&quot;  this.isFull_ = false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Calls the given function for each buffered log record, starting with the&quot;,&quot; * oldest one.&quot;,&quot; * @param {function(!goog.debug.LogRecord)} func The function to call.&quot;,&quot; */&quot;,&quot;goog.debug.LogBuffer.prototype.forEachRecord = function(func) {&quot;,&quot;  var buffer = this.buffer_;&quot;,&quot;  // Corner case: no records.&quot;,&quot;  if (!buffer[0]) {&quot;,&quot;    return;&quot;,&quot;  }&quot;,&quot;  var curIndex = this.curIndex_;&quot;,&quot;  var i = this.isFull_ ? curIndex : -1;&quot;,&quot;  do {&quot;,&quot;    i = (i + 1) % goog.debug.LogBuffer.CAPACITY;&quot;,&quot;    func(/** @type {!goog.debug.LogRecord} */ (buffer[i]));&quot;,&quot;  } while (i != curIndex);&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>