<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>logger.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;logger.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/debug/logger.js&quot;,[&quot;// Copyright 2006 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Definition of the Logger class. Please minimize dependencies&quot;,&quot; * this file has on other closure classes as any dependency it takes won&#39;t be&quot;,&quot; * able to use the logging infrastructure.&quot;,&quot; *&quot;,&quot; * @see ../demos/debug.html&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.debug.LogManager&#39;);&quot;,&quot;goog.provide(&#39;goog.debug.Loggable&#39;);&quot;,&quot;goog.provide(&#39;goog.debug.Logger&#39;);&quot;,&quot;goog.provide(&#39;goog.debug.Logger.Level&#39;);&quot;,null,&quot;goog.require(&#39;goog.array&#39;);&quot;,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;goog.debug&#39;);&quot;,&quot;goog.require(&#39;goog.debug.LogBuffer&#39;);&quot;,&quot;goog.require(&#39;goog.debug.LogRecord&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * A message value that can be handled by a Logger.&quot;,&quot; *&quot;,&quot; * Functions are treated like callbacks, but are only called when the event&#39;s&quot;,&quot; * log level is enabled. This is useful for logging messages that are expensive&quot;,&quot; * to construct.&quot;,&quot; *&quot;,&quot; * @typedef {string|function(): string}&quot;,&quot; */&quot;,&quot;goog.debug.Loggable;&quot;,null,null,null,&quot;/**&quot;,&quot; * The Logger is an object used for logging debug messages. Loggers are&quot;,&quot; * normally named, using a hierarchical dot-separated namespace. Logger names&quot;,&quot; * can be arbitrary strings, but they should normally be based on the package&quot;,&quot; * name or class name of the logged component, such as goog.net.BrowserChannel.&quot;,&quot; *&quot;,&quot; * The Logger object is loosely based on the java class&quot;,&quot; * java.util.logging.Logger. It supports different levels of filtering for&quot;,&quot; * different loggers.&quot;,&quot; *&quot;,&quot; * The logger object should never be instantiated by application code. It&quot;,&quot; * should always use the goog.debug.Logger.getLogger function.&quot;,&quot; *&quot;,&quot; * @constructor&quot;,&quot; * @param {string} name The name of the Logger.&quot;,&quot; * @final&quot;,&quot; */&quot;,&quot;goog.debug.Logger = function(name) {&quot;,&quot;  /**&quot;,&quot;   * Name of the Logger. Generally a dot-separated namespace&quot;,&quot;   * @private {string}&quot;,&quot;   */&quot;,&quot;  this.name_ = name;&quot;,null,&quot;  /**&quot;,&quot;   * Parent Logger.&quot;,&quot;   * @private {goog.debug.Logger}&quot;,&quot;   */&quot;,&quot;  this.parent_ = null;&quot;,null,&quot;  /**&quot;,&quot;   * Level that this logger only filters above. Null indicates it should&quot;,&quot;   * inherit from the parent.&quot;,&quot;   * @private {goog.debug.Logger.Level}&quot;,&quot;   */&quot;,&quot;  this.level_ = null;&quot;,null,&quot;  /**&quot;,&quot;   * Map of children loggers. The keys are the leaf names of the children and&quot;,&quot;   * the values are the child loggers.&quot;,&quot;   * @private {Object}&quot;,&quot;   */&quot;,&quot;  this.children_ = null;&quot;,null,&quot;  /**&quot;,&quot;   * Handlers that are listening to this logger.&quot;,&quot;   * @private {Array&lt;Function&gt;}&quot;,&quot;   */&quot;,&quot;  this.handlers_ = null;&quot;,&quot;};&quot;,null,null,&quot;/** @const */&quot;,&quot;goog.debug.Logger.ROOT_LOGGER_NAME = &#39;&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Toggles whether loggers other than the root logger can have&quot;,&quot; *     log handlers attached to them and whether they can have their log level&quot;,&quot; *     set. Logging is a bit faster when this is set to false.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.debug.Logger.ENABLE_HIERARCHY&#39;, true);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Toggles whether active log statements are also recorded&quot;,&quot; *     to the profiler.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.debug.Logger.ENABLE_PROFILER_LOGGING&#39;, false);&quot;,null,null,&quot;if (!goog.debug.Logger.ENABLE_HIERARCHY) {&quot;,&quot;  /**&quot;,&quot;   * @type {!Array&lt;Function&gt;}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.debug.Logger.rootHandlers_ = [];&quot;,null,null,&quot;  /**&quot;,&quot;   * @type {goog.debug.Logger.Level}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  goog.debug.Logger.rootLevel_;&quot;,&quot;}&quot;,null,null,null,&quot;/**&quot;,&quot; * The Level class defines a set of standard logging levels that&quot;,&quot; * can be used to control logging output.  The logging Level objects&quot;,&quot; * are ordered and are specified by ordered integers.  Enabling logging&quot;,&quot; * at a given level also enables logging at all higher levels.&quot;,&quot; * &lt;p&gt;&quot;,&quot; * Clients should normally use the predefined Level constants such&quot;,&quot; * as Level.SEVERE.&quot;,&quot; * &lt;p&gt;&quot;,&quot; * The levels in descending order are:&quot;,&quot; * &lt;ul&gt;&quot;,&quot; * &lt;li&gt;SEVERE (highest value)&quot;,&quot; * &lt;li&gt;WARNING&quot;,&quot; * &lt;li&gt;INFO&quot;,&quot; * &lt;li&gt;CONFIG&quot;,&quot; * &lt;li&gt;FINE&quot;,&quot; * &lt;li&gt;FINER&quot;,&quot; * &lt;li&gt;FINEST  (lowest value)&quot;,&quot; * &lt;/ul&gt;&quot;,&quot; * In addition there is a level OFF that can be used to turn&quot;,&quot; * off logging, and a level ALL that can be used to enable&quot;,&quot; * logging of all messages.&quot;,&quot; *&quot;,&quot; * @param {string} name The name of the level.&quot;,&quot; * @param {number} value The numeric value of the level.&quot;,&quot; * @constructor&quot;,&quot; * @final&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level = function(name, value) {&quot;,&quot;  /**&quot;,&quot;   * The name of the level&quot;,&quot;   * @type {string}&quot;,&quot;   */&quot;,&quot;  this.name = name;&quot;,null,&quot;  /**&quot;,&quot;   * The numeric value of the level&quot;,&quot;   * @type {number}&quot;,&quot;   */&quot;,&quot;  this.value = value;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {string} String representation of the logger level.&quot;,&quot; * @override&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.prototype.toString = function() {&quot;,&quot;  return this.name;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * OFF is a special level that can be used to turn off logging.&quot;,&quot; * This level is initialized to &lt;CODE&gt;Infinity&lt;/CODE&gt;.&quot;,&quot; * @type {!goog.debug.Logger.Level}&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.OFF = new goog.debug.Logger.Level(&#39;OFF&#39;, Infinity);&quot;,null,null,&quot;/**&quot;,&quot; * SHOUT is a message level for extra debugging loudness.&quot;,&quot; * This level is initialized to &lt;CODE&gt;1200&lt;/CODE&gt;.&quot;,&quot; * @type {!goog.debug.Logger.Level}&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.SHOUT = new goog.debug.Logger.Level(&#39;SHOUT&#39;, 1200);&quot;,null,null,&quot;/**&quot;,&quot; * SEVERE is a message level indicating a serious failure.&quot;,&quot; * This level is initialized to &lt;CODE&gt;1000&lt;/CODE&gt;.&quot;,&quot; * @type {!goog.debug.Logger.Level}&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.SEVERE = new goog.debug.Logger.Level(&#39;SEVERE&#39;, 1000);&quot;,null,null,&quot;/**&quot;,&quot; * WARNING is a message level indicating a potential problem.&quot;,&quot; * This level is initialized to &lt;CODE&gt;900&lt;/CODE&gt;.&quot;,&quot; * @type {!goog.debug.Logger.Level}&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.WARNING = new goog.debug.Logger.Level(&#39;WARNING&#39;, 900);&quot;,null,null,&quot;/**&quot;,&quot; * INFO is a message level for informational messages.&quot;,&quot; * This level is initialized to &lt;CODE&gt;800&lt;/CODE&gt;.&quot;,&quot; * @type {!goog.debug.Logger.Level}&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.INFO = new goog.debug.Logger.Level(&#39;INFO&#39;, 800);&quot;,null,null,&quot;/**&quot;,&quot; * CONFIG is a message level for static configuration messages.&quot;,&quot; * This level is initialized to &lt;CODE&gt;700&lt;/CODE&gt;.&quot;,&quot; * @type {!goog.debug.Logger.Level}&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.CONFIG = new goog.debug.Logger.Level(&#39;CONFIG&#39;, 700);&quot;,null,null,&quot;/**&quot;,&quot; * FINE is a message level providing tracing information.&quot;,&quot; * This level is initialized to &lt;CODE&gt;500&lt;/CODE&gt;.&quot;,&quot; * @type {!goog.debug.Logger.Level}&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.FINE = new goog.debug.Logger.Level(&#39;FINE&#39;, 500);&quot;,null,null,&quot;/**&quot;,&quot; * FINER indicates a fairly detailed tracing message.&quot;,&quot; * This level is initialized to &lt;CODE&gt;400&lt;/CODE&gt;.&quot;,&quot; * @type {!goog.debug.Logger.Level}&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.FINER = new goog.debug.Logger.Level(&#39;FINER&#39;, 400);&quot;,null,&quot;/**&quot;,&quot; * FINEST indicates a highly detailed tracing message.&quot;,&quot; * This level is initialized to &lt;CODE&gt;300&lt;/CODE&gt;.&quot;,&quot; * @type {!goog.debug.Logger.Level}&quot;,&quot; */&quot;,null,&quot;goog.debug.Logger.Level.FINEST = new goog.debug.Logger.Level(&#39;FINEST&#39;, 300);&quot;,null,null,&quot;/**&quot;,&quot; * ALL indicates that all messages should be logged.&quot;,&quot; * This level is initialized to &lt;CODE&gt;0&lt;/CODE&gt;.&quot;,&quot; * @type {!goog.debug.Logger.Level}&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.ALL = new goog.debug.Logger.Level(&#39;ALL&#39;, 0);&quot;,null,null,&quot;/**&quot;,&quot; * The predefined levels.&quot;,&quot; * @type {!Array&lt;!goog.debug.Logger.Level&gt;}&quot;,&quot; * @final&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.PREDEFINED_LEVELS = [&quot;,&quot;  goog.debug.Logger.Level.OFF, goog.debug.Logger.Level.SHOUT,&quot;,&quot;  goog.debug.Logger.Level.SEVERE, goog.debug.Logger.Level.WARNING,&quot;,&quot;  goog.debug.Logger.Level.INFO, goog.debug.Logger.Level.CONFIG,&quot;,&quot;  goog.debug.Logger.Level.FINE, goog.debug.Logger.Level.FINER,&quot;,&quot;  goog.debug.Logger.Level.FINEST, goog.debug.Logger.Level.ALL&quot;,&quot;];&quot;,null,null,&quot;/**&quot;,&quot; * A lookup map used to find the level object based on the name or value of&quot;,&quot; * the level object.&quot;,&quot; * @type {Object}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.predefinedLevelsCache_ = null;&quot;,null,null,&quot;/**&quot;,&quot; * Creates the predefined levels cache and populates it.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.createPredefinedLevelsCache_ = function() {&quot;,&quot;  goog.debug.Logger.Level.predefinedLevelsCache_ = {};&quot;,&quot;  for (var i = 0, level; level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i];&quot;,&quot;       i++) {&quot;,&quot;    goog.debug.Logger.Level.predefinedLevelsCache_[level.value] = level;&quot;,&quot;    goog.debug.Logger.Level.predefinedLevelsCache_[level.name] = level;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the predefined level with the given name.&quot;,&quot; * @param {string} name The name of the level.&quot;,&quot; * @return {goog.debug.Logger.Level} The level, or null if none found.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.getPredefinedLevel = function(name) {&quot;,&quot;  if (!goog.debug.Logger.Level.predefinedLevelsCache_) {&quot;,&quot;    goog.debug.Logger.Level.createPredefinedLevelsCache_();&quot;,&quot;  }&quot;,null,&quot;  return goog.debug.Logger.Level.predefinedLevelsCache_[name] || null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the highest predefined level &lt;= #value.&quot;,&quot; * @param {number} value Level value.&quot;,&quot; * @return {goog.debug.Logger.Level} The level, or null if none found.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.Level.getPredefinedLevelByValue = function(value) {&quot;,&quot;  if (!goog.debug.Logger.Level.predefinedLevelsCache_) {&quot;,&quot;    goog.debug.Logger.Level.createPredefinedLevelsCache_();&quot;,&quot;  }&quot;,null,&quot;  if (value in /** @type {!Object} */ (&quot;,&quot;          goog.debug.Logger.Level.predefinedLevelsCache_)) {&quot;,&quot;    return goog.debug.Logger.Level.predefinedLevelsCache_[value];&quot;,&quot;  }&quot;,null,&quot;  for (var i = 0; i &lt; goog.debug.Logger.Level.PREDEFINED_LEVELS.length; ++i) {&quot;,&quot;    var level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i];&quot;,&quot;    if (level.value &lt;= value) {&quot;,&quot;      return level;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Finds or creates a logger for a named subsystem. If a logger has already been&quot;,&quot; * created with the given name it is returned. Otherwise a new logger is&quot;,&quot; * created. If a new logger is created its log level will be configured based&quot;,&quot; * on the LogManager configuration and it will configured to also send logging&quot;,&quot; * output to its parent&#39;s handlers. It will be registered in the LogManager&quot;,&quot; * global namespace.&quot;,&quot; *&quot;,&quot; * @param {string} name A name for the logger. This should be a dot-separated&quot;,&quot; * name and should normally be based on the package name or class name of the&quot;,&quot; * subsystem, such as goog.net.BrowserChannel.&quot;,&quot; * @return {!goog.debug.Logger} The named logger.&quot;,&quot; * @deprecated use {@link goog.log} instead.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.getLogger = function(name) {&quot;,&quot;  return goog.debug.LogManager.getLogger(name);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Logs a message to profiling tools, if available.&quot;,&quot; * {@see https://developers.google.com/web-toolkit/speedtracer/logging-api}&quot;,&quot; * {@see http://msdn.microsoft.com/en-us/library/dd433074(VS.85).aspx}&quot;,&quot; * @param {string} msg The message to log.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.logToProfilers = function(msg) {&quot;,&quot;  // Some browsers also log timeStamp calls to the console, only log&quot;,&quot;  // if actually asked.&quot;,&quot;  if (goog.debug.Logger.ENABLE_PROFILER_LOGGING) {&quot;,&quot;    var msWriteProfilerMark = goog.global[&#39;msWriteProfilerMark&#39;];&quot;,&quot;    if (msWriteProfilerMark) {&quot;,&quot;      // Logs a message to the Microsoft profiler&quot;,&quot;      // On IE, console[&#39;timeStamp&#39;] may output to console&quot;,&quot;      msWriteProfilerMark(msg);&quot;,&quot;      return;&quot;,&quot;    }&quot;,null,&quot;    // Using goog.global, as loggers might be used in window-less contexts.&quot;,&quot;    var console = goog.global[&#39;console&#39;];&quot;,&quot;    if (console &amp;&amp; console[&#39;timeStamp&#39;]) {&quot;,&quot;      // Logs a message to Firebug, Web Inspector, SpeedTracer, etc.&quot;,&quot;      console[&#39;timeStamp&#39;](msg);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the name of this logger.&quot;,&quot; * @return {string} The name of this logger.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.getName = function() {&quot;,&quot;  return this.name_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds a handler to the logger. This doesn&#39;t use the event system because&quot;,&quot; * we want to be able to add logging to the event system.&quot;,&quot; * @param {Function} handler Handler function to add.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.addHandler = function(handler) {&quot;,&quot;  if (goog.debug.LOGGING_ENABLED) {&quot;,&quot;    if (goog.debug.Logger.ENABLE_HIERARCHY) {&quot;,&quot;      if (!this.handlers_) {&quot;,&quot;        this.handlers_ = [];&quot;,&quot;      }&quot;,&quot;      this.handlers_.push(handler);&quot;,&quot;    } else {&quot;,&quot;      goog.asserts.assert(&quot;,&quot;          !this.name_, &#39;Cannot call addHandler on a non-root logger when &#39; +&quot;,&quot;              &#39;goog.debug.Logger.ENABLE_HIERARCHY is false.&#39;);&quot;,&quot;      goog.debug.Logger.rootHandlers_.push(handler);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes a handler from the logger. This doesn&#39;t use the event system because&quot;,&quot; * we want to be able to add logging to the event system.&quot;,&quot; * @param {Function} handler Handler function to remove.&quot;,&quot; * @return {boolean} Whether the handler was removed.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.removeHandler = function(handler) {&quot;,&quot;  if (goog.debug.LOGGING_ENABLED) {&quot;,&quot;    var handlers = goog.debug.Logger.ENABLE_HIERARCHY ?&quot;,&quot;        this.handlers_ :&quot;,&quot;        goog.debug.Logger.rootHandlers_;&quot;,&quot;    return !!handlers &amp;&amp; goog.array.remove(handlers, handler);&quot;,&quot;  } else {&quot;,&quot;    return false;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the parent of this logger.&quot;,&quot; * @return {goog.debug.Logger} The parent logger or null if this is the root.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.getParent = function() {&quot;,&quot;  return this.parent_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the children of this logger as a map of the child name to the logger.&quot;,&quot; * @return {!Object} The map where the keys are the child leaf names and the&quot;,&quot; *     values are the Logger objects.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.getChildren = function() {&quot;,&quot;  if (!this.children_) {&quot;,&quot;    this.children_ = {};&quot;,&quot;  }&quot;,&quot;  return this.children_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Set the log level specifying which message levels will be logged by this&quot;,&quot; * logger. Message levels lower than this value will be discarded.&quot;,&quot; * The level value Level.OFF can be used to turn off logging. If the new level&quot;,&quot; * is null, it means that this node should inherit its level from its nearest&quot;,&quot; * ancestor with a specific (non-null) level value.&quot;,&quot; *&quot;,&quot; * @param {goog.debug.Logger.Level} level The new level.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.setLevel = function(level) {&quot;,&quot;  if (goog.debug.LOGGING_ENABLED) {&quot;,&quot;    if (goog.debug.Logger.ENABLE_HIERARCHY) {&quot;,&quot;      this.level_ = level;&quot;,&quot;    } else {&quot;,&quot;      goog.asserts.assert(&quot;,&quot;          !this.name_, &#39;Cannot call setLevel() on a non-root logger when &#39; +&quot;,&quot;              &#39;goog.debug.Logger.ENABLE_HIERARCHY is false.&#39;);&quot;,&quot;      goog.debug.Logger.rootLevel_ = level;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the log level specifying which message levels will be logged by this&quot;,&quot; * logger. Message levels lower than this value will be discarded.&quot;,&quot; * The level value Level.OFF can be used to turn off logging. If the level&quot;,&quot; * is null, it means that this node should inherit its level from its nearest&quot;,&quot; * ancestor with a specific (non-null) level value.&quot;,&quot; *&quot;,&quot; * @return {goog.debug.Logger.Level} The level.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.getLevel = function() {&quot;,&quot;  return goog.debug.LOGGING_ENABLED ? this.level_ : goog.debug.Logger.Level.OFF;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the effective level of the logger based on its ancestors&#39; levels.&quot;,&quot; * @return {goog.debug.Logger.Level} The level.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.getEffectiveLevel = function() {&quot;,&quot;  if (!goog.debug.LOGGING_ENABLED) {&quot;,&quot;    return goog.debug.Logger.Level.OFF;&quot;,&quot;  }&quot;,null,&quot;  if (!goog.debug.Logger.ENABLE_HIERARCHY) {&quot;,&quot;    return goog.debug.Logger.rootLevel_;&quot;,&quot;  }&quot;,&quot;  if (this.level_) {&quot;,&quot;    return this.level_;&quot;,&quot;  }&quot;,&quot;  if (this.parent_) {&quot;,&quot;    return this.parent_.getEffectiveLevel();&quot;,&quot;  }&quot;,&quot;  goog.asserts.fail(&#39;Root logger has no level set.&#39;);&quot;,&quot;  return null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Checks if a message of the given level would actually be logged by this&quot;,&quot; * logger. This check is based on the Loggers effective level, which may be&quot;,&quot; * inherited from its parent.&quot;,&quot; * @param {goog.debug.Logger.Level} level The level to check.&quot;,&quot; * @return {boolean} Whether the message would be logged.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.isLoggable = function(level) {&quot;,&quot;  return goog.debug.LOGGING_ENABLED &amp;&amp;&quot;,&quot;      level.value &gt;= this.getEffectiveLevel().value;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Logs a message. If the logger is currently enabled for the&quot;,&quot; * given message level then the given message is forwarded to all the&quot;,&quot; * registered output Handler objects.&quot;,&quot; * @param {goog.debug.Logger.Level} level One of the level identifiers.&quot;,&quot; * @param {goog.debug.Loggable} msg The message to log.&quot;,&quot; * @param {Error|Object=} opt_exception An exception associated with the&quot;,&quot; *     message.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.log = function(level, msg, opt_exception) {&quot;,&quot;  // java caches the effective level, not sure it&#39;s necessary here&quot;,&quot;  if (goog.debug.LOGGING_ENABLED &amp;&amp; this.isLoggable(level)) {&quot;,&quot;    // Message callbacks can be useful when a log message is expensive to build.&quot;,&quot;    if (goog.isFunction(msg)) {&quot;,&quot;      msg = msg();&quot;,&quot;    }&quot;,null,&quot;    this.doLogRecord_(this.getLogRecord(level, msg, opt_exception));&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a new log record and adds the exception (if present) to it.&quot;,&quot; * @param {goog.debug.Logger.Level} level One of the level identifiers.&quot;,&quot; * @param {string} msg The string message.&quot;,&quot; * @param {Error|Object=} opt_exception An exception associated with the&quot;,&quot; *     message.&quot;,&quot; * @return {!goog.debug.LogRecord} A log record.&quot;,&quot; * @suppress {es5Strict}&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.getLogRecord = function(level, msg, opt_exception) {&quot;,&quot;  if (goog.debug.LogBuffer.isBufferingEnabled()) {&quot;,&quot;    var logRecord =&quot;,&quot;        goog.debug.LogBuffer.getInstance().addRecord(level, msg, this.name_);&quot;,&quot;  } else {&quot;,&quot;    logRecord = new goog.debug.LogRecord(level, String(msg), this.name_);&quot;,&quot;  }&quot;,&quot;  if (opt_exception) {&quot;,&quot;    logRecord.setException(opt_exception);&quot;,&quot;  }&quot;,&quot;  return logRecord;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Logs a message at the Logger.Level.SHOUT level.&quot;,&quot; * If the logger is currently enabled for the given message level then the&quot;,&quot; * given message is forwarded to all the registered output Handler objects.&quot;,&quot; * @param {goog.debug.Loggable} msg The message to log.&quot;,&quot; * @param {Error=} opt_exception An exception associated with the message.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.shout = function(msg, opt_exception) {&quot;,&quot;  if (goog.debug.LOGGING_ENABLED) {&quot;,&quot;    this.log(goog.debug.Logger.Level.SHOUT, msg, opt_exception);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Logs a message at the Logger.Level.SEVERE level.&quot;,&quot; * If the logger is currently enabled for the given message level then the&quot;,&quot; * given message is forwarded to all the registered output Handler objects.&quot;,&quot; * @param {goog.debug.Loggable} msg The message to log.&quot;,&quot; * @param {Error=} opt_exception An exception associated with the message.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.severe = function(msg, opt_exception) {&quot;,&quot;  if (goog.debug.LOGGING_ENABLED) {&quot;,&quot;    this.log(goog.debug.Logger.Level.SEVERE, msg, opt_exception);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Logs a message at the Logger.Level.WARNING level.&quot;,&quot; * If the logger is currently enabled for the given message level then the&quot;,&quot; * given message is forwarded to all the registered output Handler objects.&quot;,&quot; * @param {goog.debug.Loggable} msg The message to log.&quot;,&quot; * @param {Error=} opt_exception An exception associated with the message.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.warning = function(msg, opt_exception) {&quot;,&quot;  if (goog.debug.LOGGING_ENABLED) {&quot;,&quot;    this.log(goog.debug.Logger.Level.WARNING, msg, opt_exception);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Logs a message at the Logger.Level.INFO level.&quot;,&quot; * If the logger is currently enabled for the given message level then the&quot;,&quot; * given message is forwarded to all the registered output Handler objects.&quot;,&quot; * @param {goog.debug.Loggable} msg The message to log.&quot;,&quot; * @param {Error=} opt_exception An exception associated with the message.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.info = function(msg, opt_exception) {&quot;,&quot;  if (goog.debug.LOGGING_ENABLED) {&quot;,&quot;    this.log(goog.debug.Logger.Level.INFO, msg, opt_exception);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Logs a message at the Logger.Level.CONFIG level.&quot;,&quot; * If the logger is currently enabled for the given message level then the&quot;,&quot; * given message is forwarded to all the registered output Handler objects.&quot;,&quot; * @param {goog.debug.Loggable} msg The message to log.&quot;,&quot; * @param {Error=} opt_exception An exception associated with the message.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.config = function(msg, opt_exception) {&quot;,&quot;  if (goog.debug.LOGGING_ENABLED) {&quot;,&quot;    this.log(goog.debug.Logger.Level.CONFIG, msg, opt_exception);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Logs a message at the Logger.Level.FINE level.&quot;,&quot; * If the logger is currently enabled for the given message level then the&quot;,&quot; * given message is forwarded to all the registered output Handler objects.&quot;,&quot; * @param {goog.debug.Loggable} msg The message to log.&quot;,&quot; * @param {Error=} opt_exception An exception associated with the message.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.fine = function(msg, opt_exception) {&quot;,&quot;  if (goog.debug.LOGGING_ENABLED) {&quot;,&quot;    this.log(goog.debug.Logger.Level.FINE, msg, opt_exception);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Logs a message at the Logger.Level.FINER level.&quot;,&quot; * If the logger is currently enabled for the given message level then the&quot;,&quot; * given message is forwarded to all the registered output Handler objects.&quot;,&quot; * @param {goog.debug.Loggable} msg The message to log.&quot;,&quot; * @param {Error=} opt_exception An exception associated with the message.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.finer = function(msg, opt_exception) {&quot;,&quot;  if (goog.debug.LOGGING_ENABLED) {&quot;,&quot;    this.log(goog.debug.Logger.Level.FINER, msg, opt_exception);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Logs a message at the Logger.Level.FINEST level.&quot;,&quot; * If the logger is currently enabled for the given message level then the&quot;,&quot; * given message is forwarded to all the registered output Handler objects.&quot;,&quot; * @param {goog.debug.Loggable} msg The message to log.&quot;,&quot; * @param {Error=} opt_exception An exception associated with the message.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.finest = function(msg, opt_exception) {&quot;,&quot;  if (goog.debug.LOGGING_ENABLED) {&quot;,&quot;    this.log(goog.debug.Logger.Level.FINEST, msg, opt_exception);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Logs a LogRecord. If the logger is currently enabled for the&quot;,&quot; * given message level then the given message is forwarded to all the&quot;,&quot; * registered output Handler objects.&quot;,&quot; * @param {goog.debug.LogRecord} logRecord A log record to log.&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.logRecord = function(logRecord) {&quot;,&quot;  if (goog.debug.LOGGING_ENABLED &amp;&amp; this.isLoggable(logRecord.getLevel())) {&quot;,&quot;    this.doLogRecord_(logRecord);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Logs a LogRecord.&quot;,&quot; * @param {goog.debug.LogRecord} logRecord A log record to log.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.doLogRecord_ = function(logRecord) {&quot;,&quot;  if (goog.debug.Logger.ENABLE_PROFILER_LOGGING) {&quot;,&quot;    goog.debug.Logger.logToProfilers(&#39;log:&#39; + logRecord.getMessage());&quot;,&quot;  }&quot;,&quot;  if (goog.debug.Logger.ENABLE_HIERARCHY) {&quot;,&quot;    var target = this;&quot;,&quot;    while (target) {&quot;,&quot;      target.callPublish_(logRecord);&quot;,&quot;      target = target.getParent();&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    for (var i = 0, handler; handler = goog.debug.Logger.rootHandlers_[i++];) {&quot;,&quot;      handler(logRecord);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Calls the handlers for publish.&quot;,&quot; * @param {goog.debug.LogRecord} logRecord The log record to publish.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.callPublish_ = function(logRecord) {&quot;,&quot;  if (this.handlers_) {&quot;,&quot;    for (var i = 0, handler; handler = this.handlers_[i]; i++) {&quot;,&quot;      handler(logRecord);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the parent of this logger. This is used for setting up the logger tree.&quot;,&quot; * @param {goog.debug.Logger} parent The parent logger.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.setParent_ = function(parent) {&quot;,&quot;  this.parent_ = parent;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds a child to this logger. This is used for setting up the logger tree.&quot;,&quot; * @param {string} name The leaf name of the child.&quot;,&quot; * @param {goog.debug.Logger} logger The child logger.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.Logger.prototype.addChild_ = function(name, logger) {&quot;,&quot;  this.getChildren()[name] = logger;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * There is a single global LogManager object that is used to maintain a set of&quot;,&quot; * shared state about Loggers and log services. This is loosely based on the&quot;,&quot; * java class java.util.logging.LogManager.&quot;,&quot; * @const&quot;,&quot; */&quot;,&quot;goog.debug.LogManager = {};&quot;,null,null,&quot;/**&quot;,&quot; * Map of logger names to logger objects.&quot;,&quot; *&quot;,&quot; * @type {!Object&lt;string, !goog.debug.Logger&gt;}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.LogManager.loggers_ = {};&quot;,null,null,&quot;/**&quot;,&quot; * The root logger which is the root of the logger tree.&quot;,&quot; * @type {goog.debug.Logger}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.LogManager.rootLogger_ = null;&quot;,null,null,&quot;/**&quot;,&quot; * Initializes the LogManager if not already initialized.&quot;,&quot; */&quot;,&quot;goog.debug.LogManager.initialize = function() {&quot;,&quot;  if (!goog.debug.LogManager.rootLogger_) {&quot;,&quot;    goog.debug.LogManager.rootLogger_ =&quot;,&quot;        new goog.debug.Logger(goog.debug.Logger.ROOT_LOGGER_NAME);&quot;,&quot;    goog.debug.LogManager.loggers_[goog.debug.Logger.ROOT_LOGGER_NAME] =&quot;,&quot;        goog.debug.LogManager.rootLogger_;&quot;,&quot;    goog.debug.LogManager.rootLogger_.setLevel(goog.debug.Logger.Level.CONFIG);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns all the loggers.&quot;,&quot; * @return {!Object&lt;string, !goog.debug.Logger&gt;} Map of logger names to logger&quot;,&quot; *     objects.&quot;,&quot; */&quot;,&quot;goog.debug.LogManager.getLoggers = function() {&quot;,&quot;  return goog.debug.LogManager.loggers_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the root of the logger tree namespace, the logger with the empty&quot;,&quot; * string as its name.&quot;,&quot; *&quot;,&quot; * @return {!goog.debug.Logger} The root logger.&quot;,&quot; */&quot;,&quot;goog.debug.LogManager.getRoot = function() {&quot;,&quot;  goog.debug.LogManager.initialize();&quot;,&quot;  return /** @type {!goog.debug.Logger} */ (goog.debug.LogManager.rootLogger_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Finds a named logger.&quot;,&quot; *&quot;,&quot; * @param {string} name A name for the logger. This should be a dot-separated&quot;,&quot; * name and should normally be based on the package name or class name of the&quot;,&quot; * subsystem, such as goog.net.BrowserChannel.&quot;,&quot; * @return {!goog.debug.Logger} The named logger.&quot;,&quot; */&quot;,&quot;goog.debug.LogManager.getLogger = function(name) {&quot;,&quot;  goog.debug.LogManager.initialize();&quot;,&quot;  var ret = goog.debug.LogManager.loggers_[name];&quot;,&quot;  return ret || goog.debug.LogManager.createLogger_(name);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a function that can be passed to goog.debug.catchErrors. The function&quot;,&quot; * will log all reported errors using the given logger.&quot;,&quot; * @param {goog.debug.Logger=} opt_logger The logger to log the errors to.&quot;,&quot; *     Defaults to the root logger.&quot;,&quot; * @return {function(Object)} The created function.&quot;,&quot; */&quot;,&quot;goog.debug.LogManager.createFunctionForCatchErrors = function(opt_logger) {&quot;,&quot;  return function(info) {&quot;,&quot;    var logger = opt_logger || goog.debug.LogManager.getRoot();&quot;,&quot;    logger.severe(&quot;,&quot;        &#39;Error: &#39; + info.message + &#39; (&#39; + info.fileName + &#39; @ Line: &#39; +&quot;,&quot;        info.line + &#39;)&#39;);&quot;,&quot;  };&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates the named logger. Will also create the parents of the named logger&quot;,&quot; * if they don&#39;t yet exist.&quot;,&quot; * @param {string} name The name of the logger.&quot;,&quot; * @return {!goog.debug.Logger} The named logger.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.debug.LogManager.createLogger_ = function(name) {&quot;,&quot;  // find parent logger&quot;,&quot;  var logger = new goog.debug.Logger(name);&quot;,&quot;  if (goog.debug.Logger.ENABLE_HIERARCHY) {&quot;,&quot;    var lastDotIndex = name.lastIndexOf(&#39;.&#39;);&quot;,&quot;    var parentName = name.substr(0, lastDotIndex);&quot;,&quot;    var leafName = name.substr(lastDotIndex + 1);&quot;,&quot;    var parentLogger = goog.debug.LogManager.getLogger(parentName);&quot;,null,&quot;    // tell the parent about the child and the child about the parent&quot;,&quot;    parentLogger.addChild_(leafName, logger);&quot;,&quot;    logger.setParent_(parentLogger);&quot;,&quot;  }&quot;,null,&quot;  goog.debug.LogManager.loggers_[name] = logger;&quot;,&quot;  return logger;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>