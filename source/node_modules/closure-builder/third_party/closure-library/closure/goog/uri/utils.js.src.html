<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>utils.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;utils.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/uri/utils.js&quot;,[&quot;// Copyright 2008 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Simple utilities for dealing with URI strings.&quot;,&quot; *&quot;,&quot; * This is intended to be a lightweight alternative to constructing goog.Uri&quot;,&quot; * objects.  Whereas goog.Uri adds several kilobytes to the binary regardless&quot;,&quot; * of how much of its functionality you use, this is designed to be a set of&quot;,&quot; * mostly-independent utilities so that the compiler includes only what is&quot;,&quot; * necessary for the task.  Estimated savings of porting is 5k pre-gzip and&quot;,&quot; * 1.5k post-gzip.  To ensure the savings remain, future developers should&quot;,&quot; * avoid adding new functionality to existing functions, but instead create&quot;,&quot; * new ones and factor out shared code.&quot;,&quot; *&quot;,&quot; * Many of these utilities have limited functionality, tailored to common&quot;,&quot; * cases.  The query parameter utilities assume that the parameter keys are&quot;,&quot; * already encoded, since most keys are compile-time alphanumeric strings.  The&quot;,&quot; * query parameter mutation utilities also do not tolerate fragment identifiers.&quot;,&quot; *&quot;,&quot; * By design, these functions can be slower than goog.Uri equivalents.&quot;,&quot; * Repeated calls to some of functions may be quadratic in behavior for IE,&quot;,&quot; * although the effect is somewhat limited given the 2kb limit.&quot;,&quot; *&quot;,&quot; * One advantage of the limited functionality here is that this approach is&quot;,&quot; * less sensitive to differences in URI encodings than goog.Uri, since these&quot;,&quot; * functions operate on strings directly, rather than decoding them and&quot;,&quot; * then re-encoding.&quot;,&quot; *&quot;,&quot; * Uses features of RFC 3986 for parsing/formatting URIs:&quot;,&quot; *   http://www.ietf.org/rfc/rfc3986.txt&quot;,&quot; *&quot;,&quot; * @author gboyer@google.com (Garrett Boyer) - The \&quot;lightened\&quot; design.&quot;,&quot; * @author msamuel@google.com (Mike Samuel) - Domain knowledge and regexes.&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.uri.utils&#39;);&quot;,&quot;goog.provide(&#39;goog.uri.utils.ComponentIndex&#39;);&quot;,&quot;goog.provide(&#39;goog.uri.utils.QueryArray&#39;);&quot;,&quot;goog.provide(&#39;goog.uri.utils.QueryValue&#39;);&quot;,&quot;goog.provide(&#39;goog.uri.utils.StandardQueryParam&#39;);&quot;,null,&quot;goog.require(&#39;goog.array&#39;);&quot;,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;goog.string&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * Character codes inlined to avoid object allocations due to charCode.&quot;,&quot; * @enum {number}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.CharCode_ = {&quot;,&quot;  AMPERSAND: 38,&quot;,&quot;  EQUAL: 61,&quot;,&quot;  HASH: 35,&quot;,&quot;  QUESTION: 63&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Builds a URI string from already-encoded parts.&quot;,&quot; *&quot;,&quot; * No encoding is performed.  Any component may be omitted as either null or&quot;,&quot; * undefined.&quot;,&quot; *&quot;,&quot; * @param {?string=} opt_scheme The scheme such as &#39;http&#39;.&quot;,&quot; * @param {?string=} opt_userInfo The user name before the &#39;@&#39;.&quot;,&quot; * @param {?string=} opt_domain The domain such as &#39;www.google.com&#39;, already&quot;,&quot; *     URI-encoded.&quot;,&quot; * @param {(string|number|null)=} opt_port The port number.&quot;,&quot; * @param {?string=} opt_path The path, already URI-encoded.  If it is not&quot;,&quot; *     empty, it must begin with a slash.&quot;,&quot; * @param {?string=} opt_queryData The URI-encoded query data.&quot;,&quot; * @param {?string=} opt_fragment The URI-encoded fragment identifier.&quot;,&quot; * @return {string} The fully combined URI.&quot;,&quot; */&quot;,&quot;goog.uri.utils.buildFromEncodedParts = function(&quot;,&quot;    opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData,&quot;,&quot;    opt_fragment) {&quot;,&quot;  var out = &#39;&#39;;&quot;,null,&quot;  if (opt_scheme) {&quot;,&quot;    out += opt_scheme + &#39;:&#39;;&quot;,&quot;  }&quot;,null,&quot;  if (opt_domain) {&quot;,&quot;    out += &#39;//&#39;;&quot;,null,&quot;    if (opt_userInfo) {&quot;,&quot;      out += opt_userInfo + &#39;@&#39;;&quot;,&quot;    }&quot;,null,&quot;    out += opt_domain;&quot;,null,&quot;    if (opt_port) {&quot;,&quot;      out += &#39;:&#39; + opt_port;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  if (opt_path) {&quot;,&quot;    out += opt_path;&quot;,&quot;  }&quot;,null,&quot;  if (opt_queryData) {&quot;,&quot;    out += &#39;?&#39; + opt_queryData;&quot;,&quot;  }&quot;,null,&quot;  if (opt_fragment) {&quot;,&quot;    out += &#39;#&#39; + opt_fragment;&quot;,&quot;  }&quot;,null,&quot;  return out;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * A regular expression for breaking a URI into its component parts.&quot;,&quot; *&quot;,&quot; * {@link http://www.ietf.org/rfc/rfc3986.txt} says in Appendix B&quot;,&quot; * As the \&quot;first-match-wins\&quot; algorithm is identical to the \&quot;greedy\&quot;&quot;,&quot; * disambiguation method used by POSIX regular expressions, it is natural and&quot;,&quot; * commonplace to use a regular expression for parsing the potential five&quot;,&quot; * components of a URI reference.&quot;,&quot; *&quot;,&quot; * The following line is the regular expression for breaking-down a&quot;,&quot; * well-formed URI reference into its components.&quot;,&quot; *&quot;,&quot; * &lt;pre&gt;&quot;,&quot; * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?&quot;,&quot; *  12            3  4          5       6  7        8 9&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * The numbers in the second line above are only to assist readability; they&quot;,&quot; * indicate the reference points for each subexpression (i.e., each paired&quot;,&quot; * parenthesis). We refer to the value matched for subexpression &lt;n&gt; as $&lt;n&gt;.&quot;,&quot; * For example, matching the above expression to&quot;,&quot; * &lt;pre&gt;&quot;,&quot; *     http://www.ics.uci.edu/pub/ietf/uri/#Related&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; * results in the following subexpression matches:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; *    $1 = http:&quot;,&quot; *    $2 = http&quot;,&quot; *    $3 = //www.ics.uci.edu&quot;,&quot; *    $4 = www.ics.uci.edu&quot;,&quot; *    $5 = /pub/ietf/uri/&quot;,&quot; *    $6 = &lt;undefined&gt;&quot;,&quot; *    $7 = &lt;undefined&gt;&quot;,&quot; *    $8 = #Related&quot;,&quot; *    $9 = Related&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; * where &lt;undefined&gt; indicates that the component is not present, as is the&quot;,&quot; * case for the query component in the above example. Therefore, we can&quot;,&quot; * determine the value of the five components as&quot;,&quot; * &lt;pre&gt;&quot;,&quot; *    scheme    = $2&quot;,&quot; *    authority = $4&quot;,&quot; *    path      = $5&quot;,&quot; *    query     = $7&quot;,&quot; *    fragment  = $9&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * The regular expression has been modified slightly to expose the&quot;,&quot; * userInfo, domain, and port separately from the authority.&quot;,&quot; * The modified version yields&quot;,&quot; * &lt;pre&gt;&quot;,&quot; *    $1 = http              scheme&quot;,&quot; *    $2 = &lt;undefined&gt;       userInfo -\\&quot;,&quot; *    $3 = www.ics.uci.edu   domain     | authority&quot;,&quot; *    $4 = &lt;undefined&gt;       port     -/&quot;,&quot; *    $5 = /pub/ietf/uri/    path&quot;,&quot; *    $6 = &lt;undefined&gt;       query without ?&quot;,&quot; *    $7 = Related           fragment without #&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; * @type {!RegExp}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.splitRe_ = new RegExp(&quot;,&quot;    &#39;^&#39; +&quot;,&quot;    &#39;(?:&#39; +&quot;,&quot;    &#39;([^:/?#.]+)&#39; +  // scheme - ignore special characters&quot;,&quot;                     // used by other URL parts such as :,&quot;,&quot;                     // ?, /, #, and .&quot;,&quot;    &#39;:)?&#39; +&quot;,&quot;    &#39;(?://&#39; +&quot;,&quot;    &#39;(?:([^/?#]*)@)?&#39; +  // userInfo&quot;,&quot;    &#39;([^/#?]*?)&#39; +       // domain&quot;,&quot;    &#39;(?::([0-9]+))?&#39; +   // port&quot;,&quot;    &#39;(?=[/#?]|$)&#39; +      // authority-terminating character&quot;,&quot;    &#39;)?&#39; +&quot;,&quot;    &#39;([^?#]+)?&#39; +          // path&quot;,&quot;    &#39;(?:\\\\?([^#]*))?&#39; +    // query&quot;,&quot;    &#39;(?:#([\\\\s\\\\S]*))?&#39; +  // fragment&quot;,&quot;    &#39;$&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * The index of each URI component in the return value of goog.uri.utils.split.&quot;,&quot; * @enum {number}&quot;,&quot; */&quot;,&quot;goog.uri.utils.ComponentIndex = {&quot;,&quot;  SCHEME: 1,&quot;,&quot;  USER_INFO: 2,&quot;,&quot;  DOMAIN: 3,&quot;,&quot;  PORT: 4,&quot;,&quot;  PATH: 5,&quot;,&quot;  QUERY_DATA: 6,&quot;,&quot;  FRAGMENT: 7&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Splits a URI into its component parts.&quot;,&quot; *&quot;,&quot; * Each component can be accessed via the component indices; for example:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; * goog.uri.utils.split(someStr)[goog.uri.utils.ComponentIndex.QUERY_DATA];&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * @param {string} uri The URI string to examine.&quot;,&quot; * @return {!Array&lt;string|undefined&gt;} Each component still URI-encoded.&quot;,&quot; *     Each component that is present will contain the encoded value, whereas&quot;,&quot; *     components that are not present will be undefined or empty, depending&quot;,&quot; *     on the browser&#39;s regular expression implementation.  Never null, since&quot;,&quot; *     arbitrary strings may still look like path names.&quot;,&quot; */&quot;,&quot;goog.uri.utils.split = function(uri) {&quot;,&quot;  // See @return comment -- never null.&quot;,&quot;  return /** @type {!Array&lt;string|undefined&gt;} */ (&quot;,&quot;      uri.match(goog.uri.utils.splitRe_));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {?string} uri A possibly null string.&quot;,&quot; * @param {boolean=} opt_preserveReserved If true, percent-encoding of RFC-3986&quot;,&quot; *     reserved characters will not be removed.&quot;,&quot; * @return {?string} The string URI-decoded, or null if uri is null.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.decodeIfPossible_ = function(uri, opt_preserveReserved) {&quot;,&quot;  if (!uri) {&quot;,&quot;    return uri;&quot;,&quot;  }&quot;,null,&quot;  return opt_preserveReserved ? decodeURI(uri) : decodeURIComponent(uri);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets a URI component by index.&quot;,&quot; *&quot;,&quot; * It is preferred to use the getPathEncoded() variety of functions ahead,&quot;,&quot; * since they are more readable.&quot;,&quot; *&quot;,&quot; * @param {goog.uri.utils.ComponentIndex} componentIndex The component index.&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {?string} The still-encoded component, or null if the component&quot;,&quot; *     is not present.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.getComponentByIndex_ = function(componentIndex, uri) {&quot;,&quot;  // Convert undefined, null, and empty string into null.&quot;,&quot;  return goog.uri.utils.split(uri)[componentIndex] || null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {?string} The protocol or scheme, or null if none.  Does not&quot;,&quot; *     include trailing colons or slashes.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getScheme = function(uri) {&quot;,&quot;  return goog.uri.utils.getComponentByIndex_(&quot;,&quot;      goog.uri.utils.ComponentIndex.SCHEME, uri);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the effective scheme for the URL.  If the URL is relative then the&quot;,&quot; * scheme is derived from the page&#39;s location.&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {string} The protocol or scheme, always lower case.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getEffectiveScheme = function(uri) {&quot;,&quot;  var scheme = goog.uri.utils.getScheme(uri);&quot;,&quot;  if (!scheme &amp;&amp; goog.global.self &amp;&amp; goog.global.self.location) {&quot;,&quot;    var protocol = goog.global.self.location.protocol;&quot;,&quot;    scheme = protocol.substr(0, protocol.length - 1);&quot;,&quot;  }&quot;,&quot;  // NOTE: When called from a web worker in Firefox 3.5, location maybe null.&quot;,&quot;  // All other browsers with web workers support self.location from the worker.&quot;,&quot;  return scheme ? scheme.toLowerCase() : &#39;&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {?string} The user name still encoded, or null if none.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getUserInfoEncoded = function(uri) {&quot;,&quot;  return goog.uri.utils.getComponentByIndex_(&quot;,&quot;      goog.uri.utils.ComponentIndex.USER_INFO, uri);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {?string} The decoded user info, or null if none.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getUserInfo = function(uri) {&quot;,&quot;  return goog.uri.utils.decodeIfPossible_(&quot;,&quot;      goog.uri.utils.getUserInfoEncoded(uri));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {?string} The domain name still encoded, or null if none.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getDomainEncoded = function(uri) {&quot;,&quot;  return goog.uri.utils.getComponentByIndex_(&quot;,&quot;      goog.uri.utils.ComponentIndex.DOMAIN, uri);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {?string} The decoded domain, or null if none.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getDomain = function(uri) {&quot;,&quot;  return goog.uri.utils.decodeIfPossible_(&quot;,&quot;      goog.uri.utils.getDomainEncoded(uri), true /* opt_preserveReserved */);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {?number} The port number, or null if none.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getPort = function(uri) {&quot;,&quot;  // Coerce to a number.  If the result of getComponentByIndex_ is null or&quot;,&quot;  // non-numeric, the number coersion yields NaN.  This will then return&quot;,&quot;  // null for all non-numeric cases (though also zero, which isn&#39;t a relevant&quot;,&quot;  // port number).&quot;,&quot;  return Number(&quot;,&quot;             goog.uri.utils.getComponentByIndex_(&quot;,&quot;                 goog.uri.utils.ComponentIndex.PORT, uri)) ||&quot;,&quot;      null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {?string} The path still encoded, or null if none. Includes the&quot;,&quot; *     leading slash, if any.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getPathEncoded = function(uri) {&quot;,&quot;  return goog.uri.utils.getComponentByIndex_(&quot;,&quot;      goog.uri.utils.ComponentIndex.PATH, uri);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {?string} The decoded path, or null if none.  Includes the leading&quot;,&quot; *     slash, if any.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getPath = function(uri) {&quot;,&quot;  return goog.uri.utils.decodeIfPossible_(&quot;,&quot;      goog.uri.utils.getPathEncoded(uri), true /* opt_preserveReserved */);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {?string} The query data still encoded, or null if none.  Does not&quot;,&quot; *     include the question mark itself.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getQueryData = function(uri) {&quot;,&quot;  return goog.uri.utils.getComponentByIndex_(&quot;,&quot;      goog.uri.utils.ComponentIndex.QUERY_DATA, uri);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {?string} The fragment identifier, or null if none.  Does not&quot;,&quot; *     include the hash mark itself.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getFragmentEncoded = function(uri) {&quot;,&quot;  // The hash mark may not appear in any other part of the URL.&quot;,&quot;  var hashIndex = uri.indexOf(&#39;#&#39;);&quot;,&quot;  return hashIndex &lt; 0 ? null : uri.substr(hashIndex + 1);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @param {?string} fragment The encoded fragment identifier, or null if none.&quot;,&quot; *     Does not include the hash mark itself.&quot;,&quot; * @return {string} The URI with the fragment set.&quot;,&quot; */&quot;,&quot;goog.uri.utils.setFragmentEncoded = function(uri, fragment) {&quot;,&quot;  return goog.uri.utils.removeFragment(uri) + (fragment ? &#39;#&#39; + fragment : &#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {?string} The decoded fragment identifier, or null if none.  Does&quot;,&quot; *     not include the hash mark.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getFragment = function(uri) {&quot;,&quot;  return goog.uri.utils.decodeIfPossible_(&quot;,&quot;      goog.uri.utils.getFragmentEncoded(uri));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Extracts everything up to the port of the URI.&quot;,&quot; * @param {string} uri The URI string.&quot;,&quot; * @return {string} Everything up to and including the port.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getHost = function(uri) {&quot;,&quot;  var pieces = goog.uri.utils.split(uri);&quot;,&quot;  return goog.uri.utils.buildFromEncodedParts(&quot;,&quot;      pieces[goog.uri.utils.ComponentIndex.SCHEME],&quot;,&quot;      pieces[goog.uri.utils.ComponentIndex.USER_INFO],&quot;,&quot;      pieces[goog.uri.utils.ComponentIndex.DOMAIN],&quot;,&quot;      pieces[goog.uri.utils.ComponentIndex.PORT]);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the origin for a given URL.&quot;,&quot; * @param {string} uri The URI string.&quot;,&quot; * @return {string} Everything up to and including the port.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getOrigin = function(uri) {&quot;,&quot;  var pieces = goog.uri.utils.split(uri);&quot;,&quot;  return goog.uri.utils.buildFromEncodedParts(&quot;,&quot;      pieces[goog.uri.utils.ComponentIndex.SCHEME], null /* opt_userInfo */,&quot;,&quot;      pieces[goog.uri.utils.ComponentIndex.DOMAIN],&quot;,&quot;      pieces[goog.uri.utils.ComponentIndex.PORT]);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Extracts the path of the URL and everything after.&quot;,&quot; * @param {string} uri The URI string.&quot;,&quot; * @return {string} The URI, starting at the path and including the query&quot;,&quot; *     parameters and fragment identifier.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getPathAndAfter = function(uri) {&quot;,&quot;  var pieces = goog.uri.utils.split(uri);&quot;,&quot;  return goog.uri.utils.buildFromEncodedParts(&quot;,&quot;      null, null, null, null, pieces[goog.uri.utils.ComponentIndex.PATH],&quot;,&quot;      pieces[goog.uri.utils.ComponentIndex.QUERY_DATA],&quot;,&quot;      pieces[goog.uri.utils.ComponentIndex.FRAGMENT]);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the URI with the fragment identifier removed.&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @return {string} Everything preceding the hash mark.&quot;,&quot; */&quot;,&quot;goog.uri.utils.removeFragment = function(uri) {&quot;,&quot;  // The hash mark may not appear in any other part of the URL.&quot;,&quot;  var hashIndex = uri.indexOf(&#39;#&#39;);&quot;,&quot;  return hashIndex &lt; 0 ? uri : uri.substr(0, hashIndex);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Ensures that two URI&#39;s have the exact same domain, scheme, and port.&quot;,&quot; *&quot;,&quot; * Unlike the version in goog.Uri, this checks protocol, and therefore is&quot;,&quot; * suitable for checking against the browser&#39;s same-origin policy.&quot;,&quot; *&quot;,&quot; * @param {string} uri1 The first URI.&quot;,&quot; * @param {string} uri2 The second URI.&quot;,&quot; * @return {boolean} Whether they have the same scheme, domain and port.&quot;,&quot; */&quot;,&quot;goog.uri.utils.haveSameDomain = function(uri1, uri2) {&quot;,&quot;  var pieces1 = goog.uri.utils.split(uri1);&quot;,&quot;  var pieces2 = goog.uri.utils.split(uri2);&quot;,&quot;  return pieces1[goog.uri.utils.ComponentIndex.DOMAIN] ==&quot;,&quot;      pieces2[goog.uri.utils.ComponentIndex.DOMAIN] &amp;&amp;&quot;,&quot;      pieces1[goog.uri.utils.ComponentIndex.SCHEME] ==&quot;,&quot;      pieces2[goog.uri.utils.ComponentIndex.SCHEME] &amp;&amp;&quot;,&quot;      pieces1[goog.uri.utils.ComponentIndex.PORT] ==&quot;,&quot;      pieces2[goog.uri.utils.ComponentIndex.PORT];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Asserts that there are no fragment or query identifiers, only in uncompiled&quot;,&quot; * mode.&quot;,&quot; * @param {string} uri The URI to examine.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.assertNoFragmentsOrQueries_ = function(uri) {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      uri.indexOf(&#39;#&#39;) &lt; 0 &amp;&amp; uri.indexOf(&#39;?&#39;) &lt; 0,&quot;,&quot;      &#39;goog.uri.utils: Fragment or query identifiers are not supported: [%s]&#39;,&quot;,&quot;      uri);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Supported query parameter values by the parameter serializing utilities.&quot;,&quot; *&quot;,&quot; * If a value is null or undefined, the key-value pair is skipped, as an easy&quot;,&quot; * way to omit parameters conditionally.  Non-array parameters are converted&quot;,&quot; * to a string and URI encoded.  Array values are expanded into multiple&quot;,&quot; * &amp;key=value pairs, with each element stringized and URI-encoded.&quot;,&quot; *&quot;,&quot; * @typedef {*}&quot;,&quot; */&quot;,&quot;goog.uri.utils.QueryValue;&quot;,null,null,&quot;/**&quot;,&quot; * An array representing a set of query parameters with alternating keys&quot;,&quot; * and values.&quot;,&quot; *&quot;,&quot; * Keys are assumed to be URI encoded already and live at even indices.  See&quot;,&quot; * goog.uri.utils.QueryValue for details on how parameter values are encoded.&quot;,&quot; *&quot;,&quot; * Example:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; * var data = [&quot;,&quot; *   // Simple param: ?name=BobBarker&quot;,&quot; *   &#39;name&#39;, &#39;BobBarker&#39;,&quot;,&quot; *   // Conditional param -- may be omitted entirely.&quot;,&quot; *   &#39;specialDietaryNeeds&#39;, hasDietaryNeeds() ? getDietaryNeeds() : null,&quot;,&quot; *   // Multi-valued param: &amp;house=LosAngeles&amp;house=NewYork&amp;house=null&quot;,&quot; *   &#39;house&#39;, [&#39;LosAngeles&#39;, &#39;NewYork&#39;, null]&quot;,&quot; * ];&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * @typedef {!Array&lt;string|goog.uri.utils.QueryValue&gt;}&quot;,&quot; */&quot;,&quot;goog.uri.utils.QueryArray;&quot;,null,null,&quot;/**&quot;,&quot; * Parses encoded query parameters and calls callback function for every&quot;,&quot; * parameter found in the string.&quot;,&quot; *&quot;,&quot; * Missing value of parameter (e.g. “…&amp;key&amp;…”) is treated as if the value was an&quot;,&quot; * empty string.  Keys may be empty strings (e.g. “…&amp;=value&amp;…”) which also means&quot;,&quot; * that “…&amp;=&amp;…” and “…&amp;&amp;…” will result in an empty key and value.&quot;,&quot; *&quot;,&quot; * @param {string} encodedQuery Encoded query string excluding question mark at&quot;,&quot; *     the beginning.&quot;,&quot; * @param {function(string, string)} callback Function called for every&quot;,&quot; *     parameter found in query string.  The first argument (name) will not be&quot;,&quot; *     urldecoded (so the function is consistent with buildQueryData), but the&quot;,&quot; *     second will.  If the parameter has no value (i.e. “=” was not present)&quot;,&quot; *     the second argument (value) will be an empty string.&quot;,&quot; */&quot;,&quot;goog.uri.utils.parseQueryData = function(encodedQuery, callback) {&quot;,&quot;  if (!encodedQuery) {&quot;,&quot;    return;&quot;,&quot;  }&quot;,&quot;  var pairs = encodedQuery.split(&#39;&amp;&#39;);&quot;,&quot;  for (var i = 0; i &lt; pairs.length; i++) {&quot;,&quot;    var indexOfEquals = pairs[i].indexOf(&#39;=&#39;);&quot;,&quot;    var name = null;&quot;,&quot;    var value = null;&quot;,&quot;    if (indexOfEquals &gt;= 0) {&quot;,&quot;      name = pairs[i].substring(0, indexOfEquals);&quot;,&quot;      value = pairs[i].substring(indexOfEquals + 1);&quot;,&quot;    } else {&quot;,&quot;      name = pairs[i];&quot;,&quot;    }&quot;,&quot;    callback(name, value ? goog.string.urlDecode(value) : &#39;&#39;);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Split the URI into 3 parts where the [1] is the queryData without a leading&quot;,&quot; * &#39;?&#39;. For example, the URI http://foo.com/bar?a=b#abc returns&quot;,&quot; * [&#39;http://foo.com/bar&#39;,&#39;a=b&#39;,&#39;#abc&#39;].&quot;,&quot; * @param {string} uri The URI to parse.&quot;,&quot; * @return {!Array&lt;string&gt;} An array representation of uri of length 3 where the&quot;,&quot; *     middle value is the queryData without a leading &#39;?&#39;.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.splitQueryData_ = function(uri) {&quot;,&quot;  // Find the query data and and hash.&quot;,&quot;  var hashIndex = uri.indexOf(&#39;#&#39;);&quot;,&quot;  if (hashIndex &lt; 0) {&quot;,&quot;    hashIndex = uri.length;&quot;,&quot;  }&quot;,&quot;  var questionIndex = uri.indexOf(&#39;?&#39;);&quot;,&quot;  var queryData;&quot;,&quot;  if (questionIndex &lt; 0 || questionIndex &gt; hashIndex) {&quot;,&quot;    questionIndex = hashIndex;&quot;,&quot;    queryData = &#39;&#39;;&quot;,&quot;  } else {&quot;,&quot;    queryData = uri.substring(questionIndex + 1, hashIndex);&quot;,&quot;  }&quot;,&quot;  return [uri.substr(0, questionIndex), queryData, uri.substr(hashIndex)];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Join an array created by splitQueryData_ back into a URI.&quot;,&quot; * @param {!Array&lt;string&gt;} parts A URI in the form generated by splitQueryData_.&quot;,&quot; * @return {string} The joined URI.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.joinQueryData_ = function(parts) {&quot;,&quot;  return parts[0] + (parts[1] ? &#39;?&#39; + parts[1] : &#39;&#39;) + parts[2];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} queryData&quot;,&quot; * @param {string} newData&quot;,&quot; * @return {string}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.appendQueryData_ = function(queryData, newData) {&quot;,&quot;  if (!newData) {&quot;,&quot;    return queryData;&quot;,&quot;  }&quot;,&quot;  return queryData ? queryData + &#39;&amp;&#39; + newData : newData;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} uri&quot;,&quot; * @param {string} queryData&quot;,&quot; * @return {string}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.appendQueryDataToUri_ = function(uri, queryData) {&quot;,&quot;  if (!queryData) {&quot;,&quot;    return uri;&quot;,&quot;  }&quot;,&quot;  var parts = goog.uri.utils.splitQueryData_(uri);&quot;,&quot;  parts[1] = goog.uri.utils.appendQueryData_(parts[1], queryData);&quot;,&quot;  return goog.uri.utils.joinQueryData_(parts);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Appends key=value pairs to an array, supporting multi-valued objects.&quot;,&quot; * @param {*} key The key prefix.&quot;,&quot; * @param {goog.uri.utils.QueryValue} value The value to serialize.&quot;,&quot; * @param {!Array&lt;string&gt;} pairs The array to which the &#39;key=value&#39; strings&quot;,&quot; *     should be appended.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.appendKeyValuePairs_ = function(key, value, pairs) {&quot;,&quot;  goog.asserts.assertString(key);&quot;,&quot;  if (goog.isArray(value)) {&quot;,&quot;    // Convince the compiler it&#39;s an array.&quot;,&quot;    goog.asserts.assertArray(value);&quot;,&quot;    for (var j = 0; j &lt; value.length; j++) {&quot;,&quot;      // Convert to string explicitly, to short circuit the null and array&quot;,&quot;      // logic in this function -- this ensures that null and undefined get&quot;,&quot;      // written as literal &#39;null&#39; and &#39;undefined&#39;, and arrays don&#39;t get&quot;,&quot;      // expanded out but instead encoded in the default way.&quot;,&quot;      goog.uri.utils.appendKeyValuePairs_(key, String(value[j]), pairs);&quot;,&quot;    }&quot;,&quot;  } else if (value != null) {&quot;,&quot;    // Skip a top-level null or undefined entirely.&quot;,&quot;    pairs.push(&quot;,&quot;        key +&quot;,&quot;        // Check for empty string. Zero gets encoded into the url as literal&quot;,&quot;        // strings.  For empty string, skip the equal sign, to be consistent&quot;,&quot;        // with UriBuilder.java.&quot;,&quot;        (value === &#39;&#39; ? &#39;&#39; : &#39;=&#39; + goog.string.urlEncode(value)));&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Builds a query data string from a sequence of alternating keys and values.&quot;,&quot; * Currently generates \&quot;&amp;key&amp;\&quot; for empty args.&quot;,&quot; *&quot;,&quot; * @param {!IArrayLike&lt;string|goog.uri.utils.QueryValue&gt;} keysAndValues&quot;,&quot; *     Alternating keys and values. See the QueryArray typedef.&quot;,&quot; * @param {number=} opt_startIndex A start offset into the arary, defaults to 0.&quot;,&quot; * @return {string} The encoded query string, in the form &#39;a=1&amp;b=2&#39;.&quot;,&quot; */&quot;,&quot;goog.uri.utils.buildQueryData = function(keysAndValues, opt_startIndex) {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      Math.max(keysAndValues.length - (opt_startIndex || 0), 0) % 2 == 0,&quot;,&quot;      &#39;goog.uri.utils: Key/value lists must be even in length.&#39;);&quot;,null,&quot;  var params = [];&quot;,&quot;  for (var i = opt_startIndex || 0; i &lt; keysAndValues.length; i += 2) {&quot;,&quot;    var key = /** @type {string} */ (keysAndValues[i]);&quot;,&quot;    goog.uri.utils.appendKeyValuePairs_(key, keysAndValues[i + 1], params);&quot;,&quot;  }&quot;,&quot;  return params.join(&#39;&amp;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Builds a query data string from a map.&quot;,&quot; * Currently generates \&quot;&amp;key&amp;\&quot; for empty args.&quot;,&quot; *&quot;,&quot; * @param {!Object&lt;string, goog.uri.utils.QueryValue&gt;} map An object where keys&quot;,&quot; *     are URI-encoded parameter keys, and the values are arbitrary types&quot;,&quot; *     or arrays. Keys with a null value are dropped.&quot;,&quot; * @return {string} The encoded query string, in the form &#39;a=1&amp;b=2&#39;.&quot;,&quot; */&quot;,&quot;goog.uri.utils.buildQueryDataFromMap = function(map) {&quot;,&quot;  var params = [];&quot;,&quot;  for (var key in map) {&quot;,&quot;    goog.uri.utils.appendKeyValuePairs_(key, map[key], params);&quot;,&quot;  }&quot;,&quot;  return params.join(&#39;&amp;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Appends URI parameters to an existing URI.&quot;,&quot; *&quot;,&quot; * The variable arguments may contain alternating keys and values.  Keys are&quot;,&quot; * assumed to be already URI encoded.  The values should not be URI-encoded,&quot;,&quot; * and will instead be encoded by this function.&quot;,&quot; * &lt;pre&gt;&quot;,&quot; * appendParams(&#39;http://www.foo.com?existing=true&#39;,&quot;,&quot; *     &#39;key1&#39;, &#39;value1&#39;,&quot;,&quot; *     &#39;key2&#39;, &#39;value?willBeEncoded&#39;,&quot;,&quot; *     &#39;key3&#39;, [&#39;valueA&#39;, &#39;valueB&#39;, &#39;valueC&#39;],&quot;,&quot; *     &#39;key4&#39;, null);&quot;,&quot; * result: &#39;http://www.foo.com?existing=true&amp;&#39; +&quot;,&quot; *     &#39;key1=value1&amp;&#39; +&quot;,&quot; *     &#39;key2=value%3FwillBeEncoded&amp;&#39; +&quot;,&quot; *     &#39;key3=valueA&amp;key3=valueB&amp;key3=valueC&#39;&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * A single call to this function will not exhibit quadratic behavior in IE,&quot;,&quot; * whereas multiple repeated calls may, although the effect is limited by&quot;,&quot; * fact that URL&#39;s generally can&#39;t exceed 2kb.&quot;,&quot; *&quot;,&quot; * @param {string} uri The original URI, which may already have query data.&quot;,&quot; * @param {...(goog.uri.utils.QueryArray|goog.uri.utils.QueryValue)}&quot;,&quot; * var_args&quot;,&quot; *     An array or argument list conforming to goog.uri.utils.QueryArray.&quot;,&quot; * @return {string} The URI with all query parameters added.&quot;,&quot; */&quot;,&quot;goog.uri.utils.appendParams = function(uri, var_args) {&quot;,&quot;  var queryData = arguments.length == 2 ?&quot;,&quot;      goog.uri.utils.buildQueryData(arguments[1], 0) :&quot;,&quot;      goog.uri.utils.buildQueryData(arguments, 1);&quot;,&quot;  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Appends query parameters from a map.&quot;,&quot; *&quot;,&quot; * @param {string} uri The original URI, which may already have query data.&quot;,&quot; * @param {!Object&lt;goog.uri.utils.QueryValue&gt;} map An object where keys are&quot;,&quot; *     URI-encoded parameter keys, and the values are arbitrary types or arrays.&quot;,&quot; *     Keys with a null value are dropped.&quot;,&quot; * @return {string} The new parameters.&quot;,&quot; */&quot;,&quot;goog.uri.utils.appendParamsFromMap = function(uri, map) {&quot;,&quot;  var queryData = goog.uri.utils.buildQueryDataFromMap(map);&quot;,&quot;  return goog.uri.utils.appendQueryDataToUri_(uri, queryData);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Appends a single URI parameter.&quot;,&quot; *&quot;,&quot; * Repeated calls to this can exhibit quadratic behavior in IE6 due to the&quot;,&quot; * way string append works, though it should be limited given the 2kb limit.&quot;,&quot; *&quot;,&quot; * @param {string} uri The original URI, which may already have query data.&quot;,&quot; * @param {string} key The key, which must already be URI encoded.&quot;,&quot; * @param {*=} opt_value The value, which will be stringized and encoded&quot;,&quot; *     (assumed not already to be encoded).  If omitted, undefined, or null, the&quot;,&quot; *     key will be added as a valueless parameter.&quot;,&quot; * @return {string} The URI with the query parameter added.&quot;,&quot; */&quot;,&quot;goog.uri.utils.appendParam = function(uri, key, opt_value) {&quot;,&quot;  var value = goog.isDefAndNotNull(opt_value) ?&quot;,&quot;      &#39;=&#39; + goog.string.urlEncode(opt_value) :&quot;,&quot;      &#39;&#39;;&quot;,&quot;  return goog.uri.utils.appendQueryDataToUri_(uri, key + value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Finds the next instance of a query parameter with the specified name.&quot;,&quot; *&quot;,&quot; * Does not instantiate any objects.&quot;,&quot; *&quot;,&quot; * @param {string} uri The URI to search.  May contain a fragment identifier&quot;,&quot; *     if opt_hashIndex is specified.&quot;,&quot; * @param {number} startIndex The index to begin searching for the key at.  A&quot;,&quot; *     match may be found even if this is one character after the ampersand.&quot;,&quot; * @param {string} keyEncoded The URI-encoded key.&quot;,&quot; * @param {number} hashOrEndIndex Index to stop looking at.  If a hash&quot;,&quot; *     mark is present, it should be its index, otherwise it should be the&quot;,&quot; *     length of the string.&quot;,&quot; * @return {number} The position of the first character in the key&#39;s name,&quot;,&quot; *     immediately after either a question mark or a dot.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.findParam_ = function(&quot;,&quot;    uri, startIndex, keyEncoded, hashOrEndIndex) {&quot;,&quot;  var index = startIndex;&quot;,&quot;  var keyLength = keyEncoded.length;&quot;,null,&quot;  // Search for the key itself and post-filter for surronuding punctuation,&quot;,&quot;  // rather than expensively building a regexp.&quot;,&quot;  while ((index = uri.indexOf(keyEncoded, index)) &gt;= 0 &amp;&amp;&quot;,&quot;         index &lt; hashOrEndIndex) {&quot;,&quot;    var precedingChar = uri.charCodeAt(index - 1);&quot;,&quot;    // Ensure that the preceding character is &#39;&amp;&#39; or &#39;?&#39;.&quot;,&quot;    if (precedingChar == goog.uri.utils.CharCode_.AMPERSAND ||&quot;,&quot;        precedingChar == goog.uri.utils.CharCode_.QUESTION) {&quot;,&quot;      // Ensure the following character is &#39;&amp;&#39;, &#39;=&#39;, &#39;#&#39;, or NaN&quot;,&quot;      // (end of string).&quot;,&quot;      var followingChar = uri.charCodeAt(index + keyLength);&quot;,&quot;      if (!followingChar || followingChar == goog.uri.utils.CharCode_.EQUAL ||&quot;,&quot;          followingChar == goog.uri.utils.CharCode_.AMPERSAND ||&quot;,&quot;          followingChar == goog.uri.utils.CharCode_.HASH) {&quot;,&quot;        return index;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    index += keyLength + 1;&quot;,&quot;  }&quot;,null,&quot;  return -1;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Regular expression for finding a hash mark or end of string.&quot;,&quot; * @type {RegExp}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.hashOrEndRe_ = /#|$/;&quot;,null,null,&quot;/**&quot;,&quot; * Determines if the URI contains a specific key.&quot;,&quot; *&quot;,&quot; * Performs no object instantiations.&quot;,&quot; *&quot;,&quot; * @param {string} uri The URI to process.  May contain a fragment&quot;,&quot; *     identifier.&quot;,&quot; * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.&quot;,&quot; * @return {boolean} Whether the key is present.&quot;,&quot; */&quot;,&quot;goog.uri.utils.hasParam = function(uri, keyEncoded) {&quot;,&quot;  return goog.uri.utils.findParam_(&quot;,&quot;             uri, 0, keyEncoded, uri.search(goog.uri.utils.hashOrEndRe_)) &gt;= 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the first value of a query parameter.&quot;,&quot; * @param {string} uri The URI to process.  May contain a fragment.&quot;,&quot; * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.&quot;,&quot; * @return {?string} The first value of the parameter (URI-decoded), or null&quot;,&quot; *     if the parameter is not found.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getParamValue = function(uri, keyEncoded) {&quot;,&quot;  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);&quot;,&quot;  var foundIndex =&quot;,&quot;      goog.uri.utils.findParam_(uri, 0, keyEncoded, hashOrEndIndex);&quot;,null,&quot;  if (foundIndex &lt; 0) {&quot;,&quot;    return null;&quot;,&quot;  } else {&quot;,&quot;    var endPosition = uri.indexOf(&#39;&amp;&#39;, foundIndex);&quot;,&quot;    if (endPosition &lt; 0 || endPosition &gt; hashOrEndIndex) {&quot;,&quot;      endPosition = hashOrEndIndex;&quot;,&quot;    }&quot;,&quot;    // Progress forth to the end of the \&quot;key=\&quot; or \&quot;key&amp;\&quot; substring.&quot;,&quot;    foundIndex += keyEncoded.length + 1;&quot;,&quot;    // Use substr, because it (unlike substring) will return empty string&quot;,&quot;    // if foundIndex &gt; endPosition.&quot;,&quot;    return goog.string.urlDecode(&quot;,&quot;        uri.substr(foundIndex, endPosition - foundIndex));&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets all values of a query parameter.&quot;,&quot; * @param {string} uri The URI to process.  May contain a fragment.&quot;,&quot; * @param {string} keyEncoded The URI-encoded key.  Case-sensitive.&quot;,&quot; * @return {!Array&lt;string&gt;} All URI-decoded values with the given key.&quot;,&quot; *     If the key is not found, this will have length 0, but never be null.&quot;,&quot; */&quot;,&quot;goog.uri.utils.getParamValues = function(uri, keyEncoded) {&quot;,&quot;  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);&quot;,&quot;  var position = 0;&quot;,&quot;  var foundIndex;&quot;,&quot;  var result = [];&quot;,null,&quot;  while ((foundIndex = goog.uri.utils.findParam_(&quot;,&quot;              uri, position, keyEncoded, hashOrEndIndex)) &gt;= 0) {&quot;,&quot;    // Find where this parameter ends, either the &#39;&amp;&#39; or the end of the&quot;,&quot;    // query parameters.&quot;,&quot;    position = uri.indexOf(&#39;&amp;&#39;, foundIndex);&quot;,&quot;    if (position &lt; 0 || position &gt; hashOrEndIndex) {&quot;,&quot;      position = hashOrEndIndex;&quot;,&quot;    }&quot;,null,&quot;    // Progress forth to the end of the \&quot;key=\&quot; or \&quot;key&amp;\&quot; substring.&quot;,&quot;    foundIndex += keyEncoded.length + 1;&quot;,&quot;    // Use substr, because it (unlike substring) will return empty string&quot;,&quot;    // if foundIndex &gt; position.&quot;,&quot;    result.push(&quot;,&quot;        goog.string.urlDecode(uri.substr(foundIndex, position - foundIndex)));&quot;,&quot;  }&quot;,null,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Regexp to find trailing question marks and ampersands.&quot;,&quot; * @type {RegExp}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.uri.utils.trailingQueryPunctuationRe_ = /[?&amp;]($|#)/;&quot;,null,null,&quot;/**&quot;,&quot; * Removes all instances of a query parameter.&quot;,&quot; * @param {string} uri The URI to process.  Must not contain a fragment.&quot;,&quot; * @param {string} keyEncoded The URI-encoded key.&quot;,&quot; * @return {string} The URI with all instances of the parameter removed.&quot;,&quot; */&quot;,&quot;goog.uri.utils.removeParam = function(uri, keyEncoded) {&quot;,&quot;  var hashOrEndIndex = uri.search(goog.uri.utils.hashOrEndRe_);&quot;,&quot;  var position = 0;&quot;,&quot;  var foundIndex;&quot;,&quot;  var buffer = [];&quot;,null,&quot;  // Look for a query parameter.&quot;,&quot;  while ((foundIndex = goog.uri.utils.findParam_(&quot;,&quot;              uri, position, keyEncoded, hashOrEndIndex)) &gt;= 0) {&quot;,&quot;    // Get the portion of the query string up to, but not including, the ?&quot;,&quot;    // or &amp; starting the parameter.&quot;,&quot;    buffer.push(uri.substring(position, foundIndex));&quot;,&quot;    // Progress to immediately after the &#39;&amp;&#39;.  If not found, go to the end.&quot;,&quot;    // Avoid including the hash mark.&quot;,&quot;    position = Math.min(&quot;,&quot;        (uri.indexOf(&#39;&amp;&#39;, foundIndex) + 1) || hashOrEndIndex, hashOrEndIndex);&quot;,&quot;  }&quot;,null,&quot;  // Append everything that is remaining.&quot;,&quot;  buffer.push(uri.substr(position));&quot;,null,&quot;  // Join the buffer, and remove trailing punctuation that remains.&quot;,&quot;  return buffer.join(&#39;&#39;).replace(&quot;,&quot;      goog.uri.utils.trailingQueryPunctuationRe_, &#39;$1&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Replaces all existing definitions of a parameter with a single definition.&quot;,&quot; *&quot;,&quot; * Repeated calls to this can exhibit quadratic behavior due to the need to&quot;,&quot; * find existing instances and reconstruct the string, though it should be&quot;,&quot; * limited given the 2kb limit.  Consider using appendParams or setParamsFromMap&quot;,&quot; * to update multiple parameters in bulk.&quot;,&quot; *&quot;,&quot; * @param {string} uri The original URI, which may already have query data.&quot;,&quot; * @param {string} keyEncoded The key, which must already be URI encoded.&quot;,&quot; * @param {*} value The value, which will be stringized and encoded (assumed&quot;,&quot; *     not already to be encoded).&quot;,&quot; * @return {string} The URI with the query parameter added.&quot;,&quot; */&quot;,&quot;goog.uri.utils.setParam = function(uri, keyEncoded, value) {&quot;,&quot;  return goog.uri.utils.appendParam(&quot;,&quot;      goog.uri.utils.removeParam(uri, keyEncoded), keyEncoded, value);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Effeciently set or remove multiple query parameters in a URI. Order of&quot;,&quot; * unchanged parameters will not be modified, all updated parameters will be&quot;,&quot; * appended to the end of the query. Params with values of null or undefined are&quot;,&quot; * removed.&quot;,&quot; *&quot;,&quot; * @param {string} uri The URI to process.&quot;,&quot; * @param {!Object&lt;string, goog.uri.utils.QueryValue&gt;} params A list of&quot;,&quot; *     parameters to update. If null or undefined, the param will be removed.&quot;,&quot; * @return {string} An updated URI where the query data has been updated with&quot;,&quot; *     the params.&quot;,&quot; */&quot;,&quot;goog.uri.utils.setParamsFromMap = function(uri, params) {&quot;,&quot;  var parts = goog.uri.utils.splitQueryData_(uri);&quot;,&quot;  var queryData = parts[1];&quot;,&quot;  var buffer = [];&quot;,&quot;  if (queryData) {&quot;,&quot;    goog.array.forEach(queryData.split(&#39;&amp;&#39;), function(pair) {&quot;,&quot;      var indexOfEquals = pair.indexOf(&#39;=&#39;);&quot;,&quot;      var name = indexOfEquals &gt;= 0 ? pair.substr(0, indexOfEquals) : pair;&quot;,&quot;      if (!params.hasOwnProperty(name)) {&quot;,&quot;        buffer.push(pair);&quot;,&quot;      }&quot;,&quot;    });&quot;,&quot;  }&quot;,&quot;  parts[1] = goog.uri.utils.appendQueryData_(&quot;,&quot;      buffer.join(&#39;&amp;&#39;), goog.uri.utils.buildQueryDataFromMap(params));&quot;,&quot;  return goog.uri.utils.joinQueryData_(parts);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Generates a URI path using a given URI and a path with checks to&quot;,&quot; * prevent consecutive \&quot;//\&quot;. The baseUri passed in must not contain&quot;,&quot; * query or fragment identifiers. The path to append may not contain query or&quot;,&quot; * fragment identifiers.&quot;,&quot; *&quot;,&quot; * @param {string} baseUri URI to use as the base.&quot;,&quot; * @param {string} path Path to append.&quot;,&quot; * @return {string} Updated URI.&quot;,&quot; */&quot;,&quot;goog.uri.utils.appendPath = function(baseUri, path) {&quot;,&quot;  goog.uri.utils.assertNoFragmentsOrQueries_(baseUri);&quot;,null,&quot;  // Remove any trailing &#39;/&#39;&quot;,&quot;  if (goog.string.endsWith(baseUri, &#39;/&#39;)) {&quot;,&quot;    baseUri = baseUri.substr(0, baseUri.length - 1);&quot;,&quot;  }&quot;,&quot;  // Remove any leading &#39;/&#39;&quot;,&quot;  if (goog.string.startsWith(path, &#39;/&#39;)) {&quot;,&quot;    path = path.substr(1);&quot;,&quot;  }&quot;,&quot;  return goog.string.buildString(baseUri, &#39;/&#39;, path);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Replaces the path.&quot;,&quot; * @param {string} uri URI to use as the base.&quot;,&quot; * @param {string} path New path.&quot;,&quot; * @return {string} Updated URI.&quot;,&quot; */&quot;,&quot;goog.uri.utils.setPath = function(uri, path) {&quot;,&quot;  // Add any missing &#39;/&#39;.&quot;,&quot;  if (!goog.string.startsWith(path, &#39;/&#39;)) {&quot;,&quot;    path = &#39;/&#39; + path;&quot;,&quot;  }&quot;,&quot;  var parts = goog.uri.utils.split(uri);&quot;,&quot;  return goog.uri.utils.buildFromEncodedParts(&quot;,&quot;      parts[goog.uri.utils.ComponentIndex.SCHEME],&quot;,&quot;      parts[goog.uri.utils.ComponentIndex.USER_INFO],&quot;,&quot;      parts[goog.uri.utils.ComponentIndex.DOMAIN],&quot;,&quot;      parts[goog.uri.utils.ComponentIndex.PORT], path,&quot;,&quot;      parts[goog.uri.utils.ComponentIndex.QUERY_DATA],&quot;,&quot;      parts[goog.uri.utils.ComponentIndex.FRAGMENT]);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Standard supported query parameters.&quot;,&quot; * @enum {string}&quot;,&quot; */&quot;,&quot;goog.uri.utils.StandardQueryParam = {&quot;,null,&quot;  /** Unused parameter for unique-ifying. */&quot;,&quot;  RANDOM: &#39;zx&#39;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the zx parameter of a URI to a random value.&quot;,&quot; * @param {string} uri Any URI.&quot;,&quot; * @return {string} That URI with the \&quot;zx\&quot; parameter added or replaced to&quot;,&quot; *     contain a random string.&quot;,&quot; */&quot;,&quot;goog.uri.utils.makeUnique = function(uri) {&quot;,&quot;  return goog.uri.utils.setParam(&quot;,&quot;      uri, goog.uri.utils.StandardQueryParam.RANDOM,&quot;,&quot;      goog.string.getRandomString());&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>