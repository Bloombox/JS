<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>math.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;math.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/math/math.js&quot;,[&quot;// Copyright 2006 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Additional mathematical functions.&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.math&#39;);&quot;,null,&quot;goog.require(&#39;goog.array&#39;);&quot;,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * Returns a random integer greater than or equal to 0 and less than {@code a}.&quot;,&quot; * @param {number} a  The upper bound for the random integer (exclusive).&quot;,&quot; * @return {number} A random integer N such that 0 &lt;= N &lt; a.&quot;,&quot; */&quot;,&quot;goog.math.randomInt = function(a) {&quot;,&quot;  return Math.floor(Math.random() * a);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns a random number greater than or equal to {@code a} and less than&quot;,&quot; * {@code b}.&quot;,&quot; * @param {number} a  The lower bound for the random number (inclusive).&quot;,&quot; * @param {number} b  The upper bound for the random number (exclusive).&quot;,&quot; * @return {number} A random number N such that a &lt;= N &lt; b.&quot;,&quot; */&quot;,&quot;goog.math.uniformRandom = function(a, b) {&quot;,&quot;  return a + Math.random() * (b - a);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Takes a number and clamps it to within the provided bounds.&quot;,&quot; * @param {number} value The input number.&quot;,&quot; * @param {number} min The minimum value to return.&quot;,&quot; * @param {number} max The maximum value to return.&quot;,&quot; * @return {number} The input number if it is within bounds, or the nearest&quot;,&quot; *     number within the bounds.&quot;,&quot; */&quot;,&quot;goog.math.clamp = function(value, min, max) {&quot;,&quot;  return Math.min(Math.max(value, min), max);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * The % operator in JavaScript returns the remainder of a / b, but differs from&quot;,&quot; * some other languages in that the result will have the same sign as the&quot;,&quot; * dividend. For example, -1 % 8 == -1, whereas in some other languages&quot;,&quot; * (such as Python) the result would be 7. This function emulates the more&quot;,&quot; * correct modulo behavior, which is useful for certain applications such as&quot;,&quot; * calculating an offset index in a circular list.&quot;,&quot; *&quot;,&quot; * @param {number} a The dividend.&quot;,&quot; * @param {number} b The divisor.&quot;,&quot; * @return {number} a % b where the result is between 0 and b (either 0 &lt;= x &lt; b&quot;,&quot; *     or b &lt; x &lt;= 0, depending on the sign of b).&quot;,&quot; */&quot;,&quot;goog.math.modulo = function(a, b) {&quot;,&quot;  var r = a % b;&quot;,&quot;  // If r and b differ in sign, add b to wrap the result to the correct sign.&quot;,&quot;  return (r * b &lt; 0) ? r + b : r;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Performs linear interpolation between values a and b. Returns the value&quot;,&quot; * between a and b proportional to x (when x is between 0 and 1. When x is&quot;,&quot; * outside this range, the return value is a linear extrapolation).&quot;,&quot; * @param {number} a A number.&quot;,&quot; * @param {number} b A number.&quot;,&quot; * @param {number} x The proportion between a and b.&quot;,&quot; * @return {number} The interpolated value between a and b.&quot;,&quot; */&quot;,&quot;goog.math.lerp = function(a, b, x) {&quot;,&quot;  return a + x * (b - a);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Tests whether the two values are equal to each other, within a certain&quot;,&quot; * tolerance to adjust for floating point errors.&quot;,&quot; * @param {number} a A number.&quot;,&quot; * @param {number} b A number.&quot;,&quot; * @param {number=} opt_tolerance Optional tolerance range. Defaults&quot;,&quot; *     to 0.000001. If specified, should be greater than 0.&quot;,&quot; * @return {boolean} Whether {@code a} and {@code b} are nearly equal.&quot;,&quot; */&quot;,&quot;goog.math.nearlyEquals = function(a, b, opt_tolerance) {&quot;,&quot;  return Math.abs(a - b) &lt;= (opt_tolerance || 0.000001);&quot;,&quot;};&quot;,null,null,&quot;// TODO(user): Rename to normalizeAngle, retaining old name as deprecated&quot;,&quot;// alias.&quot;,&quot;/**&quot;,&quot; * Normalizes an angle to be in range [0-360). Angles outside this range will&quot;,&quot; * be normalized to be the equivalent angle with that range.&quot;,&quot; * @param {number} angle Angle in degrees.&quot;,&quot; * @return {number} Standardized angle.&quot;,&quot; */&quot;,&quot;goog.math.standardAngle = function(angle) {&quot;,&quot;  return goog.math.modulo(angle, 360);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Normalizes an angle to be in range [0-2*PI). Angles outside this range will&quot;,&quot; * be normalized to be the equivalent angle with that range.&quot;,&quot; * @param {number} angle Angle in radians.&quot;,&quot; * @return {number} Standardized angle.&quot;,&quot; */&quot;,&quot;goog.math.standardAngleInRadians = function(angle) {&quot;,&quot;  return goog.math.modulo(angle, 2 * Math.PI);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts degrees to radians.&quot;,&quot; * @param {number} angleDegrees Angle in degrees.&quot;,&quot; * @return {number} Angle in radians.&quot;,&quot; */&quot;,&quot;goog.math.toRadians = function(angleDegrees) {&quot;,&quot;  return angleDegrees * Math.PI / 180;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts radians to degrees.&quot;,&quot; * @param {number} angleRadians Angle in radians.&quot;,&quot; * @return {number} Angle in degrees.&quot;,&quot; */&quot;,&quot;goog.math.toDegrees = function(angleRadians) {&quot;,&quot;  return angleRadians * 180 / Math.PI;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * For a given angle and radius, finds the X portion of the offset.&quot;,&quot; * @param {number} degrees Angle in degrees (zero points in +X direction).&quot;,&quot; * @param {number} radius Radius.&quot;,&quot; * @return {number} The x-distance for the angle and radius.&quot;,&quot; */&quot;,&quot;goog.math.angleDx = function(degrees, radius) {&quot;,&quot;  return radius * Math.cos(goog.math.toRadians(degrees));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * For a given angle and radius, finds the Y portion of the offset.&quot;,&quot; * @param {number} degrees Angle in degrees (zero points in +X direction).&quot;,&quot; * @param {number} radius Radius.&quot;,&quot; * @return {number} The y-distance for the angle and radius.&quot;,&quot; */&quot;,&quot;goog.math.angleDy = function(degrees, radius) {&quot;,&quot;  return radius * Math.sin(goog.math.toRadians(degrees));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Computes the angle between two points (x1,y1) and (x2,y2).&quot;,&quot; * Angle zero points in the +X direction, 90 degrees points in the +Y&quot;,&quot; * direction (down) and from there we grow clockwise towards 360 degrees.&quot;,&quot; * @param {number} x1 x of first point.&quot;,&quot; * @param {number} y1 y of first point.&quot;,&quot; * @param {number} x2 x of second point.&quot;,&quot; * @param {number} y2 y of second point.&quot;,&quot; * @return {number} Standardized angle in degrees of the vector from&quot;,&quot; *     x1,y1 to x2,y2.&quot;,&quot; */&quot;,&quot;goog.math.angle = function(x1, y1, x2, y2) {&quot;,&quot;  return goog.math.standardAngle(&quot;,&quot;      goog.math.toDegrees(Math.atan2(y2 - y1, x2 - x1)));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Computes the difference between startAngle and endAngle (angles in degrees).&quot;,&quot; * @param {number} startAngle  Start angle in degrees.&quot;,&quot; * @param {number} endAngle  End angle in degrees.&quot;,&quot; * @return {number} The number of degrees that when added to&quot;,&quot; *     startAngle will result in endAngle. Positive numbers mean that the&quot;,&quot; *     direction is clockwise. Negative numbers indicate a counter-clockwise&quot;,&quot; *     direction.&quot;,&quot; *     The shortest route (clockwise vs counter-clockwise) between the angles&quot;,&quot; *     is used.&quot;,&quot; *     When the difference is 180 degrees, the function returns 180 (not -180)&quot;,&quot; *     angleDifference(30, 40) is 10, and angleDifference(40, 30) is -10.&quot;,&quot; *     angleDifference(350, 10) is 20, and angleDifference(10, 350) is -20.&quot;,&quot; */&quot;,&quot;goog.math.angleDifference = function(startAngle, endAngle) {&quot;,&quot;  var d =&quot;,&quot;      goog.math.standardAngle(endAngle) - goog.math.standardAngle(startAngle);&quot;,&quot;  if (d &gt; 180) {&quot;,&quot;    d = d - 360;&quot;,&quot;  } else if (d &lt;= -180) {&quot;,&quot;    d = 360 + d;&quot;,&quot;  }&quot;,&quot;  return d;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the sign of a number as per the \&quot;sign\&quot; or \&quot;signum\&quot; function.&quot;,&quot; * @param {number} x The number to take the sign of.&quot;,&quot; * @return {number} -1 when negative, 1 when positive, 0 when 0. Preserves&quot;,&quot; *     signed zeros and NaN.&quot;,&quot; */&quot;,&quot;goog.math.sign = function(x) {&quot;,&quot;  if (x &gt; 0) {&quot;,&quot;    return 1;&quot;,&quot;  }&quot;,&quot;  if (x &lt; 0) {&quot;,&quot;    return -1;&quot;,&quot;  }&quot;,&quot;  return x;  // Preserves signed zeros and NaN.&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * JavaScript implementation of Longest Common Subsequence problem.&quot;,&quot; * http://en.wikipedia.org/wiki/Longest_common_subsequence&quot;,&quot; *&quot;,&quot; * Returns the longest possible array that is subarray of both of given arrays.&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;S&gt;} array1 First array of objects.&quot;,&quot; * @param {IArrayLike&lt;T&gt;} array2 Second array of objects.&quot;,&quot; * @param {Function=} opt_compareFn Function that acts as a custom comparator&quot;,&quot; *     for the array ojects. Function should return true if objects are equal,&quot;,&quot; *     otherwise false.&quot;,&quot; * @param {Function=} opt_collectorFn Function used to decide what to return&quot;,&quot; *     as a result subsequence. It accepts 2 arguments: index of common element&quot;,&quot; *     in the first array and index in the second. The default function returns&quot;,&quot; *     element from the first array.&quot;,&quot; * @return {!Array&lt;S|T&gt;} A list of objects that are common to both arrays&quot;,&quot; *     such that there is no common subsequence with size greater than the&quot;,&quot; *     length of the list.&quot;,&quot; * @template S,T&quot;,&quot; */&quot;,&quot;goog.math.longestCommonSubsequence = function(&quot;,&quot;    array1, array2, opt_compareFn, opt_collectorFn) {&quot;,null,&quot;  var compare = opt_compareFn || function(a, b) { return a == b; };&quot;,null,&quot;  var collect = opt_collectorFn || function(i1, i2) { return array1[i1]; };&quot;,null,&quot;  var length1 = array1.length;&quot;,&quot;  var length2 = array2.length;&quot;,null,&quot;  var arr = [];&quot;,&quot;  for (var i = 0; i &lt; length1 + 1; i++) {&quot;,&quot;    arr[i] = [];&quot;,&quot;    arr[i][0] = 0;&quot;,&quot;  }&quot;,null,&quot;  for (var j = 0; j &lt; length2 + 1; j++) {&quot;,&quot;    arr[0][j] = 0;&quot;,&quot;  }&quot;,null,&quot;  for (i = 1; i &lt;= length1; i++) {&quot;,&quot;    for (j = 1; j &lt;= length2; j++) {&quot;,&quot;      if (compare(array1[i - 1], array2[j - 1])) {&quot;,&quot;        arr[i][j] = arr[i - 1][j - 1] + 1;&quot;,&quot;      } else {&quot;,&quot;        arr[i][j] = Math.max(arr[i - 1][j], arr[i][j - 1]);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // Backtracking&quot;,&quot;  var result = [];&quot;,&quot;  var i = length1, j = length2;&quot;,&quot;  while (i &gt; 0 &amp;&amp; j &gt; 0) {&quot;,&quot;    if (compare(array1[i - 1], array2[j - 1])) {&quot;,&quot;      result.unshift(collect(i - 1, j - 1));&quot;,&quot;      i--;&quot;,&quot;      j--;&quot;,&quot;    } else {&quot;,&quot;      if (arr[i - 1][j] &gt; arr[i][j - 1]) {&quot;,&quot;        i--;&quot;,&quot;      } else {&quot;,&quot;        j--;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the sum of the arguments.&quot;,&quot; * @param {...number} var_args Numbers to add.&quot;,&quot; * @return {number} The sum of the arguments (0 if no arguments were provided,&quot;,&quot; *     {@code NaN} if any of the arguments is not a valid number).&quot;,&quot; */&quot;,&quot;goog.math.sum = function(var_args) {&quot;,&quot;  return /** @type {number} */ (&quot;,&quot;      goog.array.reduce(&quot;,&quot;          arguments, function(sum, value) { return sum + value; }, 0));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the arithmetic mean of the arguments.&quot;,&quot; * @param {...number} var_args Numbers to average.&quot;,&quot; * @return {number} The average of the arguments ({@code NaN} if no arguments&quot;,&quot; *     were provided or any of the arguments is not a valid number).&quot;,&quot; */&quot;,&quot;goog.math.average = function(var_args) {&quot;,&quot;  return goog.math.sum.apply(null, arguments) / arguments.length;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the unbiased sample variance of the arguments. For a definition,&quot;,&quot; * see e.g. http://en.wikipedia.org/wiki/Variance&quot;,&quot; * @param {...number} var_args Number samples to analyze.&quot;,&quot; * @return {number} The unbiased sample variance of the arguments (0 if fewer&quot;,&quot; *     than two samples were provided, or {@code NaN} if any of the samples is&quot;,&quot; *     not a valid number).&quot;,&quot; */&quot;,&quot;goog.math.sampleVariance = function(var_args) {&quot;,&quot;  var sampleSize = arguments.length;&quot;,&quot;  if (sampleSize &lt; 2) {&quot;,&quot;    return 0;&quot;,&quot;  }&quot;,null,&quot;  var mean = goog.math.average.apply(null, arguments);&quot;,&quot;  var variance =&quot;,&quot;      goog.math.sum.apply(null, goog.array.map(arguments, function(val) {&quot;,&quot;        return Math.pow(val - mean, 2);&quot;,&quot;      })) / (sampleSize - 1);&quot;,null,&quot;  return variance;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the sample standard deviation of the arguments.  For a definition of&quot;,&quot; * sample standard deviation, see e.g.&quot;,&quot; * http://en.wikipedia.org/wiki/Standard_deviation&quot;,&quot; * @param {...number} var_args Number samples to analyze.&quot;,&quot; * @return {number} The sample standard deviation of the arguments (0 if fewer&quot;,&quot; *     than two samples were provided, or {@code NaN} if any of the samples is&quot;,&quot; *     not a valid number).&quot;,&quot; */&quot;,&quot;goog.math.standardDeviation = function(var_args) {&quot;,&quot;  return Math.sqrt(goog.math.sampleVariance.apply(null, arguments));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns whether the supplied number represents an integer, i.e. that is has&quot;,&quot; * no fractional component.  No range-checking is performed on the number.&quot;,&quot; * @param {number} num The number to test.&quot;,&quot; * @return {boolean} Whether {@code num} is an integer.&quot;,&quot; */&quot;,&quot;goog.math.isInt = function(num) {&quot;,&quot;  return isFinite(num) &amp;&amp; num % 1 == 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns whether the supplied number is finite and not NaN.&quot;,&quot; * @param {number} num The number to test.&quot;,&quot; * @return {boolean} Whether {@code num} is a finite number.&quot;,&quot; * @deprecated Use {@link isFinite} instead.&quot;,&quot; */&quot;,&quot;goog.math.isFiniteNumber = function(num) {&quot;,&quot;  return isFinite(num);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {number} num The number to test.&quot;,&quot; * @return {boolean} Whether it is negative zero.&quot;,&quot; */&quot;,&quot;goog.math.isNegativeZero = function(num) {&quot;,&quot;  return num == 0 &amp;&amp; 1 / num &lt; 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the precise value of floor(log10(num)).&quot;,&quot; * Simpler implementations didn&#39;t work because of floating point rounding&quot;,&quot; * errors. For example&quot;,&quot; * &lt;ul&gt;&quot;,&quot; * &lt;li&gt;Math.floor(Math.log(num) / Math.LN10) is off by one for num == 1e+3.&quot;,&quot; * &lt;li&gt;Math.floor(Math.log(num) * Math.LOG10E) is off by one for num == 1e+15.&quot;,&quot; * &lt;li&gt;Math.floor(Math.log10(num)) is off by one for num == 1e+15 - 1.&quot;,&quot; * &lt;/ul&gt;&quot;,&quot; * @param {number} num A floating point number.&quot;,&quot; * @return {number} Its logarithm to base 10 rounded down to the nearest&quot;,&quot; *     integer if num &gt; 0. -Infinity if num == 0. NaN if num &lt; 0.&quot;,&quot; */&quot;,&quot;goog.math.log10Floor = function(num) {&quot;,&quot;  if (num &gt; 0) {&quot;,&quot;    var x = Math.round(Math.log(num) * Math.LOG10E);&quot;,&quot;    return x - (parseFloat(&#39;1e&#39; + x) &gt; num ? 1 : 0);&quot;,&quot;  }&quot;,&quot;  return num == 0 ? -Infinity : NaN;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * A tweaked variant of {@code Math.floor} which tolerates if the passed number&quot;,&quot; * is infinitesimally smaller than the closest integer. It often happens with&quot;,&quot; * the results of floating point calculations because of the finite precision&quot;,&quot; * of the intermediate results. For example {@code Math.floor(Math.log(1000) /&quot;,&quot; * Math.LN10) == 2}, not 3 as one would expect.&quot;,&quot; * @param {number} num A number.&quot;,&quot; * @param {number=} opt_epsilon An infinitesimally small positive number, the&quot;,&quot; *     rounding error to tolerate.&quot;,&quot; * @return {number} The largest integer less than or equal to {@code num}.&quot;,&quot; */&quot;,&quot;goog.math.safeFloor = function(num, opt_epsilon) {&quot;,&quot;  goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon &gt; 0);&quot;,&quot;  return Math.floor(num + (opt_epsilon || 2e-15));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * A tweaked variant of {@code Math.ceil}. See {@code goog.math.safeFloor} for&quot;,&quot; * details.&quot;,&quot; * @param {number} num A number.&quot;,&quot; * @param {number=} opt_epsilon An infinitesimally small positive number, the&quot;,&quot; *     rounding error to tolerate.&quot;,&quot; * @return {number} The smallest integer greater than or equal to {@code num}.&quot;,&quot; */&quot;,&quot;goog.math.safeCeil = function(num, opt_epsilon) {&quot;,&quot;  goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon &gt; 0);&quot;,&quot;  return Math.ceil(num - (opt_epsilon || 2e-15));&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>