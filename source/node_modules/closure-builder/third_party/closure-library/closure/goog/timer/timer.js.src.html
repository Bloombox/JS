<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>timer.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;timer.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/timer/timer.js&quot;,[&quot;// Copyright 2006 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview A timer class to which other classes and objects can listen on.&quot;,&quot; * This is only an abstraction above {@code setInterval}.&quot;,&quot; *&quot;,&quot; * @see ../demos/timers.html&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.Timer&#39;);&quot;,null,&quot;goog.require(&#39;goog.Promise&#39;);&quot;,&quot;goog.require(&#39;goog.events.EventTarget&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * Class for handling timing events.&quot;,&quot; *&quot;,&quot; * @param {number=} opt_interval Number of ms between ticks (default: 1ms).&quot;,&quot; * @param {Object=} opt_timerObject  An object that has {@code setTimeout},&quot;,&quot; *     {@code setInterval}, {@code clearTimeout} and {@code clearInterval}&quot;,&quot; *     (e.g., {@code window}).&quot;,&quot; * @constructor&quot;,&quot; * @extends {goog.events.EventTarget}&quot;,&quot; */&quot;,&quot;goog.Timer = function(opt_interval, opt_timerObject) {&quot;,&quot;  goog.events.EventTarget.call(this);&quot;,null,&quot;  /**&quot;,&quot;   * Number of ms between ticks&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.interval_ = opt_interval || 1;&quot;,null,&quot;  /**&quot;,&quot;   * An object that implements {@code setTimeout}, {@code setInterval},&quot;,&quot;   * {@code clearTimeout} and {@code clearInterval}. We default to the window&quot;,&quot;   * object. Changing this on {@link goog.Timer.prototype} changes the object&quot;,&quot;   * for all timer instances which can be useful if your environment has some&quot;,&quot;   * other implementation of timers than the {@code window} object.&quot;,&quot;   * @private {{setTimeout:!Function, clearTimeout:!Function}}&quot;,&quot;   */&quot;,&quot;  this.timerObject_ = /** @type {{setTimeout, clearTimeout}} */ (&quot;,&quot;      opt_timerObject || goog.Timer.defaultTimerObject);&quot;,null,&quot;  /**&quot;,&quot;   * Cached {@code tick_} bound to the object for later use in the timer.&quot;,&quot;   * @private {Function}&quot;,&quot;   * @const&quot;,&quot;   */&quot;,&quot;  this.boundTick_ = goog.bind(this.tick_, this);&quot;,null,&quot;  /**&quot;,&quot;   * Firefox browser often fires the timer event sooner (sometimes MUCH sooner)&quot;,&quot;   * than the requested timeout. So we compare the time to when the event was&quot;,&quot;   * last fired, and reschedule if appropriate. See also&quot;,&quot;   * {@link goog.Timer.intervalScale}.&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.last_ = goog.now();&quot;,&quot;};&quot;,&quot;goog.inherits(goog.Timer, goog.events.EventTarget);&quot;,null,null,&quot;/**&quot;,&quot; * Maximum timeout value.&quot;,&quot; *&quot;,&quot; * Timeout values too big to fit into a signed 32-bit integer may cause overflow&quot;,&quot; * in FF, Safari, and Chrome, resulting in the timeout being scheduled&quot;,&quot; * immediately. It makes more sense simply not to schedule these timeouts, since&quot;,&quot; * 24.8 days is beyond a reasonable expectation for the browser to stay open.&quot;,&quot; *&quot;,&quot; * @private {number}&quot;,&quot; * @const&quot;,&quot; */&quot;,&quot;goog.Timer.MAX_TIMEOUT_ = 2147483647;&quot;,null,null,&quot;/**&quot;,&quot; * A timer ID that cannot be returned by any known implementation of&quot;,&quot; * {@code window.setTimeout}. Passing this value to {@code window.clearTimeout}&quot;,&quot; * should therefore be a no-op.&quot;,&quot; *&quot;,&quot; * @private {number}&quot;,&quot; * @const&quot;,&quot; */&quot;,&quot;goog.Timer.INVALID_TIMEOUT_ID_ = -1;&quot;,null,null,&quot;/**&quot;,&quot; * Whether this timer is enabled&quot;,&quot; * @type {boolean}&quot;,&quot; */&quot;,&quot;goog.Timer.prototype.enabled = false;&quot;,null,null,&quot;/**&quot;,&quot; * An object that implements {@code setTimeout}, {@code setInterval},&quot;,&quot; * {@code clearTimeout} and {@code clearInterval}. We default to the global&quot;,&quot; * object. Changing {@code goog.Timer.defaultTimerObject} changes the object for&quot;,&quot; * all timer instances which can be useful if your environment has some other&quot;,&quot; * implementation of timers you&#39;d like to use.&quot;,&quot; * @type {{setTimeout, clearTimeout}}&quot;,&quot; */&quot;,&quot;goog.Timer.defaultTimerObject = goog.global;&quot;,null,null,&quot;/**&quot;,&quot; * Variable that controls the timer error correction. If the timer is called&quot;,&quot; * before the requested interval times {@code intervalScale}, which often&quot;,&quot; * happens on Mozilla, the timer is rescheduled.&quot;,&quot; * @see {@link #last_}&quot;,&quot; * @type {number}&quot;,&quot; */&quot;,&quot;goog.Timer.intervalScale = 0.8;&quot;,null,null,&quot;/**&quot;,&quot; * Variable for storing the result of {@code setInterval}.&quot;,&quot; * @private {?number}&quot;,&quot; */&quot;,&quot;goog.Timer.prototype.timer_ = null;&quot;,null,null,&quot;/**&quot;,&quot; * Gets the interval of the timer.&quot;,&quot; * @return {number} interval Number of ms between ticks.&quot;,&quot; */&quot;,&quot;goog.Timer.prototype.getInterval = function() {&quot;,&quot;  return this.interval_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the interval of the timer.&quot;,&quot; * @param {number} interval Number of ms between ticks.&quot;,&quot; */&quot;,&quot;goog.Timer.prototype.setInterval = function(interval) {&quot;,&quot;  this.interval_ = interval;&quot;,&quot;  if (this.timer_ &amp;&amp; this.enabled) {&quot;,&quot;    // Stop and then start the timer to reset the interval.&quot;,&quot;    this.stop();&quot;,&quot;    this.start();&quot;,&quot;  } else if (this.timer_) {&quot;,&quot;    this.stop();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Callback for the {@code setTimeout} used by the timer.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.Timer.prototype.tick_ = function() {&quot;,&quot;  if (this.enabled) {&quot;,&quot;    var elapsed = goog.now() - this.last_;&quot;,&quot;    if (elapsed &gt; 0 &amp;&amp; elapsed &lt; this.interval_ * goog.Timer.intervalScale) {&quot;,&quot;      this.timer_ = this.timerObject_.setTimeout(&quot;,&quot;          this.boundTick_, this.interval_ - elapsed);&quot;,&quot;      return;&quot;,&quot;    }&quot;,null,&quot;    // Prevents setInterval from registering a duplicate timeout when called&quot;,&quot;    // in the timer event handler.&quot;,&quot;    if (this.timer_) {&quot;,&quot;      this.timerObject_.clearTimeout(this.timer_);&quot;,&quot;      this.timer_ = null;&quot;,&quot;    }&quot;,null,&quot;    this.dispatchTick();&quot;,&quot;    // The timer could be stopped in the timer event handler.&quot;,&quot;    if (this.enabled) {&quot;,&quot;      this.timer_ =&quot;,&quot;          this.timerObject_.setTimeout(this.boundTick_, this.interval_);&quot;,&quot;      this.last_ = goog.now();&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Dispatches the TICK event. This is its own method so subclasses can override.&quot;,&quot; */&quot;,&quot;goog.Timer.prototype.dispatchTick = function() {&quot;,&quot;  this.dispatchEvent(goog.Timer.TICK);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Starts the timer.&quot;,&quot; */&quot;,&quot;goog.Timer.prototype.start = function() {&quot;,&quot;  this.enabled = true;&quot;,null,&quot;  // If there is no interval already registered, start it now&quot;,&quot;  if (!this.timer_) {&quot;,&quot;    // IMPORTANT!&quot;,&quot;    // window.setInterval in FireFox has a bug - it fires based on&quot;,&quot;    // absolute time, rather than on relative time. What this means&quot;,&quot;    // is that if a computer is sleeping/hibernating for 24 hours&quot;,&quot;    // and the timer interval was configured to fire every 1000ms,&quot;,&quot;    // then after the PC wakes up the timer will fire, in rapid&quot;,&quot;    // succession, 3600*24 times.&quot;,&quot;    // This bug is described here and is already fixed, but it will&quot;,&quot;    // take time to propagate, so for now I am switching this over&quot;,&quot;    // to setTimeout logic.&quot;,&quot;    //     https://bugzilla.mozilla.org/show_bug.cgi?id=376643&quot;,&quot;    //&quot;,&quot;    this.timer_ = this.timerObject_.setTimeout(this.boundTick_, this.interval_);&quot;,&quot;    this.last_ = goog.now();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Stops the timer.&quot;,&quot; */&quot;,&quot;goog.Timer.prototype.stop = function() {&quot;,&quot;  this.enabled = false;&quot;,&quot;  if (this.timer_) {&quot;,&quot;    this.timerObject_.clearTimeout(this.timer_);&quot;,&quot;    this.timer_ = null;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.Timer.prototype.disposeInternal = function() {&quot;,&quot;  goog.Timer.superClass_.disposeInternal.call(this);&quot;,&quot;  this.stop();&quot;,&quot;  delete this.timerObject_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Constant for the timer&#39;s event type.&quot;,&quot; * @const&quot;,&quot; */&quot;,&quot;goog.Timer.TICK = &#39;tick&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * Calls the given function once, after the optional pause.&quot;,&quot; * &lt;p&gt;&quot;,&quot; * The function is always called asynchronously, even if the delay is 0. This&quot;,&quot; * is a common trick to schedule a function to run after a batch of browser&quot;,&quot; * event processing.&quot;,&quot; *&quot;,&quot; * @param {function(this:SCOPE)|{handleEvent:function()}|null} listener Function&quot;,&quot; *     or object that has a handleEvent method.&quot;,&quot; * @param {number=} opt_delay Milliseconds to wait; default is 0.&quot;,&quot; * @param {SCOPE=} opt_handler Object in whose scope to call the listener.&quot;,&quot; * @return {number} A handle to the timer ID.&quot;,&quot; * @template SCOPE&quot;,&quot; */&quot;,&quot;goog.Timer.callOnce = function(listener, opt_delay, opt_handler) {&quot;,&quot;  if (goog.isFunction(listener)) {&quot;,&quot;    if (opt_handler) {&quot;,&quot;      listener = goog.bind(listener, opt_handler);&quot;,&quot;    }&quot;,&quot;  } else if (listener &amp;&amp; typeof listener.handleEvent == &#39;function&#39;) {&quot;,&quot;    // using typeof to prevent strict js warning&quot;,&quot;    listener = goog.bind(listener.handleEvent, listener);&quot;,&quot;  } else {&quot;,&quot;    throw new Error(&#39;Invalid listener argument&#39;);&quot;,&quot;  }&quot;,null,&quot;  if (Number(opt_delay) &gt; goog.Timer.MAX_TIMEOUT_) {&quot;,&quot;    // Timeouts greater than MAX_INT return immediately due to integer&quot;,&quot;    // overflow in many browsers.  Since MAX_INT is 24.8 days, just don&#39;t&quot;,&quot;    // schedule anything at all.&quot;,&quot;    return goog.Timer.INVALID_TIMEOUT_ID_;&quot;,&quot;  } else {&quot;,&quot;    return goog.Timer.defaultTimerObject.setTimeout(listener, opt_delay || 0);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Clears a timeout initiated by {@link #callOnce}.&quot;,&quot; * @param {?number} timerId A timer ID.&quot;,&quot; */&quot;,&quot;goog.Timer.clear = function(timerId) {&quot;,&quot;  goog.Timer.defaultTimerObject.clearTimeout(timerId);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {number} delay Milliseconds to wait.&quot;,&quot; * @param {(RESULT|goog.Thenable&lt;RESULT&gt;|Thenable)=} opt_result The value&quot;,&quot; *     with which the promise will be resolved.&quot;,&quot; * @return {!goog.Promise&lt;RESULT&gt;} A promise that will be resolved after&quot;,&quot; *     the specified delay, unless it is canceled first.&quot;,&quot; * @template RESULT&quot;,&quot; */&quot;,&quot;goog.Timer.promise = function(delay, opt_result) {&quot;,&quot;  var timerKey = null;&quot;,&quot;  return new goog&quot;,&quot;      .Promise(function(resolve, reject) {&quot;,&quot;        timerKey =&quot;,&quot;            goog.Timer.callOnce(function() { resolve(opt_result); }, delay);&quot;,&quot;        if (timerKey == goog.Timer.INVALID_TIMEOUT_ID_) {&quot;,&quot;          reject(new Error(&#39;Failed to schedule timer.&#39;));&quot;,&quot;        }&quot;,&quot;      })&quot;,&quot;      .thenCatch(function(error) {&quot;,&quot;        // Clear the timer. The most likely reason is \&quot;cancel\&quot; signal.&quot;,&quot;        goog.Timer.clear(timerKey);&quot;,&quot;        throw error;&quot;,&quot;      });&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>