<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>array.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;array.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/array/array.js&quot;,[&quot;// Copyright 2006 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Utilities for manipulating arrays.&quot;,&quot; *&quot;,&quot; * @author arv@google.com (Erik Arvidsson)&quot;,&quot; */&quot;,null,null,&quot;goog.provide(&#39;goog.array&#39;);&quot;,null,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should&quot;,&quot; * rely on Array.prototype functions, if available.&quot;,&quot; *&quot;,&quot; * The Array.prototype functions can be defined by external libraries like&quot;,&quot; * Prototype and setting this flag to false forces closure to use its own&quot;,&quot; * goog.array implementation.&quot;,&quot; *&quot;,&quot; * If your javascript can be loaded by a third party site and you are wary about&quot;,&quot; * relying on the prototype functions, specify&quot;,&quot; * \&quot;--define goog.NATIVE_ARRAY_PROTOTYPES=false\&quot; to the JSCompiler.&quot;,&quot; *&quot;,&quot; * Setting goog.TRUSTED_SITE to false will automatically set&quot;,&quot; * NATIVE_ARRAY_PROTOTYPES to false.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.NATIVE_ARRAY_PROTOTYPES&#39;, goog.TRUSTED_SITE);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} If true, JSCompiler will use the native implementation of&quot;,&quot; * array functions where appropriate (e.g., {@code Array#filter}) and remove the&quot;,&quot; * unused pure JS implementation.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.array.ASSUME_NATIVE_FUNCTIONS&#39;, false);&quot;,null,null,&quot;/**&quot;,&quot; * Returns the last element in an array without removing it.&quot;,&quot; * Same as goog.array.last.&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} array The array.&quot;,&quot; * @return {T} Last item in array.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.peek = function(array) {&quot;,&quot;  return array[array.length - 1];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the last element in an array without removing it.&quot;,&quot; * Same as goog.array.peek.&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} array The array.&quot;,&quot; * @return {T} Last item in array.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.last = goog.array.peek;&quot;,null,&quot;// NOTE(arv): Since most of the array functions are generic it allows you to&quot;,&quot;// pass an array-like object. Strings have a length and are considered array-&quot;,&quot;// like. However, the &#39;in&#39; operator does not work on strings so we cannot just&quot;,&quot;// use the array path even if the browser supports indexing into strings. We&quot;,&quot;// therefore end up splitting the string.&quot;,null,null,&quot;/**&quot;,&quot; * Returns the index of the first element of an array with a specified value, or&quot;,&quot; * -1 if the element is not present in the array.&quot;,&quot; *&quot;,&quot; * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr The array to be searched.&quot;,&quot; * @param {T} obj The object for which we are searching.&quot;,&quot; * @param {number=} opt_fromIndex The index at which to start the search. If&quot;,&quot; *     omitted the search starts at index 0.&quot;,&quot; * @return {number} The index of the first matching array element.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES &amp;&amp;&quot;,&quot;        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf) ?&quot;,&quot;    function(arr, obj, opt_fromIndex) {&quot;,&quot;      goog.asserts.assert(arr.length != null);&quot;,null,&quot;      return Array.prototype.indexOf.call(arr, obj, opt_fromIndex);&quot;,&quot;    } :&quot;,&quot;    function(arr, obj, opt_fromIndex) {&quot;,&quot;      var fromIndex = opt_fromIndex == null ?&quot;,&quot;          0 :&quot;,&quot;          (opt_fromIndex &lt; 0 ? Math.max(0, arr.length + opt_fromIndex) :&quot;,&quot;                               opt_fromIndex);&quot;,null,&quot;      if (goog.isString(arr)) {&quot;,&quot;        // Array.prototype.indexOf uses === so only strings should be found.&quot;,&quot;        if (!goog.isString(obj) || obj.length != 1) {&quot;,&quot;          return -1;&quot;,&quot;        }&quot;,&quot;        return arr.indexOf(obj, fromIndex);&quot;,&quot;      }&quot;,null,&quot;      for (var i = fromIndex; i &lt; arr.length; i++) {&quot;,&quot;        if (i in arr &amp;&amp; arr[i] === obj) return i;&quot;,&quot;      }&quot;,&quot;      return -1;&quot;,&quot;    };&quot;,null,null,&quot;/**&quot;,&quot; * Returns the index of the last element of an array with a specified value, or&quot;,&quot; * -1 if the element is not present in the array.&quot;,&quot; *&quot;,&quot; * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}&quot;,&quot; *&quot;,&quot; * @param {!IArrayLike&lt;T&gt;|string} arr The array to be searched.&quot;,&quot; * @param {T} obj The object for which we are searching.&quot;,&quot; * @param {?number=} opt_fromIndex The index at which to start the search. If&quot;,&quot; *     omitted the search starts at the end of the array.&quot;,&quot; * @return {number} The index of the last matching array element.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES &amp;&amp;&quot;,&quot;        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf) ?&quot;,&quot;    function(arr, obj, opt_fromIndex) {&quot;,&quot;      goog.asserts.assert(arr.length != null);&quot;,null,&quot;      // Firefox treats undefined and null as 0 in the fromIndex argument which&quot;,&quot;      // leads it to always return -1&quot;,&quot;      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;&quot;,&quot;      return Array.prototype.lastIndexOf.call(arr, obj, fromIndex);&quot;,&quot;    } :&quot;,&quot;    function(arr, obj, opt_fromIndex) {&quot;,&quot;      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;&quot;,null,&quot;      if (fromIndex &lt; 0) {&quot;,&quot;        fromIndex = Math.max(0, arr.length + fromIndex);&quot;,&quot;      }&quot;,null,&quot;      if (goog.isString(arr)) {&quot;,&quot;        // Array.prototype.lastIndexOf uses === so only strings should be found.&quot;,&quot;        if (!goog.isString(obj) || obj.length != 1) {&quot;,&quot;          return -1;&quot;,&quot;        }&quot;,&quot;        return arr.lastIndexOf(obj, fromIndex);&quot;,&quot;      }&quot;,null,&quot;      for (var i = fromIndex; i &gt;= 0; i--) {&quot;,&quot;        if (i in arr &amp;&amp; arr[i] === obj) return i;&quot;,&quot;      }&quot;,&quot;      return -1;&quot;,&quot;    };&quot;,null,null,&quot;/**&quot;,&quot; * Calls a function for each element in an array. Skips holes in the array.&quot;,&quot; * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr Array or array like object over&quot;,&quot; *     which to iterate.&quot;,&quot; * @param {?function(this: S, T, number, ?): ?} f The function to call for every&quot;,&quot; *     element. This function takes 3 arguments (the element, the index and the&quot;,&quot; *     array). The return value is ignored.&quot;,&quot; * @param {S=} opt_obj The object to be used as the value of &#39;this&#39; within f.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES &amp;&amp;&quot;,&quot;        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach) ?&quot;,&quot;    function(arr, f, opt_obj) {&quot;,&quot;      goog.asserts.assert(arr.length != null);&quot;,null,&quot;      Array.prototype.forEach.call(arr, f, opt_obj);&quot;,&quot;    } :&quot;,&quot;    function(arr, f, opt_obj) {&quot;,&quot;      var l = arr.length;  // must be fixed during loop... see docs&quot;,&quot;      var arr2 = goog.isString(arr) ? arr.split(&#39;&#39;) : arr;&quot;,&quot;      for (var i = 0; i &lt; l; i++) {&quot;,&quot;        if (i in arr2) {&quot;,&quot;          f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    };&quot;,null,null,&quot;/**&quot;,&quot; * Calls a function for each element in an array, starting from the last&quot;,&quot; * element rather than the first.&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr Array or array&quot;,&quot; *     like object over which to iterate.&quot;,&quot; * @param {?function(this: S, T, number, ?): ?} f The function to call for every&quot;,&quot; *     element. This function&quot;,&quot; *     takes 3 arguments (the element, the index and the array). The return&quot;,&quot; *     value is ignored.&quot;,&quot; * @param {S=} opt_obj The object to be used as the value of &#39;this&#39;&quot;,&quot; *     within f.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.forEachRight = function(arr, f, opt_obj) {&quot;,&quot;  var l = arr.length;  // must be fixed during loop... see docs&quot;,&quot;  var arr2 = goog.isString(arr) ? arr.split(&#39;&#39;) : arr;&quot;,&quot;  for (var i = l - 1; i &gt;= 0; --i) {&quot;,&quot;    if (i in arr2) {&quot;,&quot;      f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Calls a function for each element in an array, and if the function returns&quot;,&quot; * true adds the element to a new array.&quot;,&quot; *&quot;,&quot; * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr Array or array&quot;,&quot; *     like object over which to iterate.&quot;,&quot; * @param {?function(this:S, T, number, ?):boolean} f The function to call for&quot;,&quot; *     every element. This function&quot;,&quot; *     takes 3 arguments (the element, the index and the array) and must&quot;,&quot; *     return a Boolean. If the return value is true the element is added to the&quot;,&quot; *     result array. If it is false the element is not included.&quot;,&quot; * @param {S=} opt_obj The object to be used as the value of &#39;this&#39;&quot;,&quot; *     within f.&quot;,&quot; * @return {!Array&lt;T&gt;} a new array in which only elements that passed the test&quot;,&quot; *     are present.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES &amp;&amp;&quot;,&quot;        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter) ?&quot;,&quot;    function(arr, f, opt_obj) {&quot;,&quot;      goog.asserts.assert(arr.length != null);&quot;,null,&quot;      return Array.prototype.filter.call(arr, f, opt_obj);&quot;,&quot;    } :&quot;,&quot;    function(arr, f, opt_obj) {&quot;,&quot;      var l = arr.length;  // must be fixed during loop... see docs&quot;,&quot;      var res = [];&quot;,&quot;      var resLength = 0;&quot;,&quot;      var arr2 = goog.isString(arr) ? arr.split(&#39;&#39;) : arr;&quot;,&quot;      for (var i = 0; i &lt; l; i++) {&quot;,&quot;        if (i in arr2) {&quot;,&quot;          var val = arr2[i];  // in case f mutates arr2&quot;,&quot;          if (f.call(/** @type {?} */ (opt_obj), val, i, arr)) {&quot;,&quot;            res[resLength++] = val;&quot;,&quot;          }&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;      return res;&quot;,&quot;    };&quot;,null,null,&quot;/**&quot;,&quot; * Calls a function for each element in an array and inserts the result into a&quot;,&quot; * new array.&quot;,&quot; *&quot;,&quot; * See {@link http://tinyurl.com/developer-mozilla-org-array-map}&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;VALUE&gt;|string} arr Array or array like object&quot;,&quot; *     over which to iterate.&quot;,&quot; * @param {function(this:THIS, VALUE, number, ?): RESULT} f The function to call&quot;,&quot; *     for every element. This function takes 3 arguments (the element,&quot;,&quot; *     the index and the array) and should return something. The result will be&quot;,&quot; *     inserted into a new array.&quot;,&quot; * @param {THIS=} opt_obj The object to be used as the value of &#39;this&#39; within f.&quot;,&quot; * @return {!Array&lt;RESULT&gt;} a new array with the results from f.&quot;,&quot; * @template THIS, VALUE, RESULT&quot;,&quot; */&quot;,&quot;goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES &amp;&amp;&quot;,&quot;        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.map) ?&quot;,&quot;    function(arr, f, opt_obj) {&quot;,&quot;      goog.asserts.assert(arr.length != null);&quot;,null,&quot;      return Array.prototype.map.call(arr, f, opt_obj);&quot;,&quot;    } :&quot;,&quot;    function(arr, f, opt_obj) {&quot;,&quot;      var l = arr.length;  // must be fixed during loop... see docs&quot;,&quot;      var res = new Array(l);&quot;,&quot;      var arr2 = goog.isString(arr) ? arr.split(&#39;&#39;) : arr;&quot;,&quot;      for (var i = 0; i &lt; l; i++) {&quot;,&quot;        if (i in arr2) {&quot;,&quot;          res[i] = f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr);&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;      return res;&quot;,&quot;    };&quot;,null,null,&quot;/**&quot;,&quot; * Passes every element of an array into a function and accumulates the result.&quot;,&quot; *&quot;,&quot; * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}&quot;,&quot; *&quot;,&quot; * For example:&quot;,&quot; * var a = [1, 2, 3, 4];&quot;,&quot; * goog.array.reduce(a, function(r, v, i, arr) {return r + v;}, 0);&quot;,&quot; * returns 10&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr Array or array&quot;,&quot; *     like object over which to iterate.&quot;,&quot; * @param {function(this:S, R, T, number, ?) : R} f The function to call for&quot;,&quot; *     every element. This function&quot;,&quot; *     takes 4 arguments (the function&#39;s previous result or the initial value,&quot;,&quot; *     the value of the current array element, the current array index, and the&quot;,&quot; *     array itself)&quot;,&quot; *     function(previousValue, currentValue, index, array).&quot;,&quot; * @param {?} val The initial value to pass into the function on the first call.&quot;,&quot; * @param {S=} opt_obj  The object to be used as the value of &#39;this&#39;&quot;,&quot; *     within f.&quot;,&quot; * @return {R} Result of evaluating f repeatedly across the values of the array.&quot;,&quot; * @template T,S,R&quot;,&quot; */&quot;,&quot;goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES &amp;&amp;&quot;,&quot;        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce) ?&quot;,&quot;    function(arr, f, val, opt_obj) {&quot;,&quot;      goog.asserts.assert(arr.length != null);&quot;,&quot;      if (opt_obj) {&quot;,&quot;        f = goog.bind(f, opt_obj);&quot;,&quot;      }&quot;,&quot;      return Array.prototype.reduce.call(arr, f, val);&quot;,&quot;    } :&quot;,&quot;    function(arr, f, val, opt_obj) {&quot;,&quot;      var rval = val;&quot;,&quot;      goog.array.forEach(arr, function(val, index) {&quot;,&quot;        rval = f.call(/** @type {?} */ (opt_obj), rval, val, index, arr);&quot;,&quot;      });&quot;,&quot;      return rval;&quot;,&quot;    };&quot;,null,null,&quot;/**&quot;,&quot; * Passes every element of an array into a function and accumulates the result,&quot;,&quot; * starting from the last element and working towards the first.&quot;,&quot; *&quot;,&quot; * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}&quot;,&quot; *&quot;,&quot; * For example:&quot;,&quot; * var a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];&quot;,&quot; * goog.array.reduceRight(a, function(r, v, i, arr) {return r + v;}, &#39;&#39;);&quot;,&quot; * returns &#39;cba&#39;&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr Array or array&quot;,&quot; *     like object over which to iterate.&quot;,&quot; * @param {?function(this:S, R, T, number, ?) : R} f The function to call for&quot;,&quot; *     every element. This function&quot;,&quot; *     takes 4 arguments (the function&#39;s previous result or the initial value,&quot;,&quot; *     the value of the current array element, the current array index, and the&quot;,&quot; *     array itself)&quot;,&quot; *     function(previousValue, currentValue, index, array).&quot;,&quot; * @param {?} val The initial value to pass into the function on the first call.&quot;,&quot; * @param {S=} opt_obj The object to be used as the value of &#39;this&#39;&quot;,&quot; *     within f.&quot;,&quot; * @return {R} Object returned as a result of evaluating f repeatedly across the&quot;,&quot; *     values of the array.&quot;,&quot; * @template T,S,R&quot;,&quot; */&quot;,&quot;goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES &amp;&amp;&quot;,&quot;        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight) ?&quot;,&quot;    function(arr, f, val, opt_obj) {&quot;,&quot;      goog.asserts.assert(arr.length != null);&quot;,&quot;      goog.asserts.assert(f != null);&quot;,&quot;      if (opt_obj) {&quot;,&quot;        f = goog.bind(f, opt_obj);&quot;,&quot;      }&quot;,&quot;      return Array.prototype.reduceRight.call(arr, f, val);&quot;,&quot;    } :&quot;,&quot;    function(arr, f, val, opt_obj) {&quot;,&quot;      var rval = val;&quot;,&quot;      goog.array.forEachRight(arr, function(val, index) {&quot;,&quot;        rval = f.call(/** @type {?} */ (opt_obj), rval, val, index, arr);&quot;,&quot;      });&quot;,&quot;      return rval;&quot;,&quot;    };&quot;,null,null,&quot;/**&quot;,&quot; * Calls f for each element of an array. If any call returns true, some()&quot;,&quot; * returns true (without checking the remaining elements). If all calls&quot;,&quot; * return false, some() returns false.&quot;,&quot; *&quot;,&quot; * See {@link http://tinyurl.com/developer-mozilla-org-array-some}&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr Array or array&quot;,&quot; *     like object over which to iterate.&quot;,&quot; * @param {?function(this:S, T, number, ?) : boolean} f The function to call for&quot;,&quot; *     for every element. This function takes 3 arguments (the element, the&quot;,&quot; *     index and the array) and should return a boolean.&quot;,&quot; * @param {S=} opt_obj  The object to be used as the value of &#39;this&#39;&quot;,&quot; *     within f.&quot;,&quot; * @return {boolean} true if any element passes the test.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES &amp;&amp;&quot;,&quot;        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.some) ?&quot;,&quot;    function(arr, f, opt_obj) {&quot;,&quot;      goog.asserts.assert(arr.length != null);&quot;,null,&quot;      return Array.prototype.some.call(arr, f, opt_obj);&quot;,&quot;    } :&quot;,&quot;    function(arr, f, opt_obj) {&quot;,&quot;      var l = arr.length;  // must be fixed during loop... see docs&quot;,&quot;      var arr2 = goog.isString(arr) ? arr.split(&#39;&#39;) : arr;&quot;,&quot;      for (var i = 0; i &lt; l; i++) {&quot;,&quot;        if (i in arr2 &amp;&amp; f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {&quot;,&quot;          return true;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;      return false;&quot;,&quot;    };&quot;,null,null,&quot;/**&quot;,&quot; * Call f for each element of an array. If all calls return true, every()&quot;,&quot; * returns true. If any call returns false, every() returns false and&quot;,&quot; * does not continue to check the remaining elements.&quot;,&quot; *&quot;,&quot; * See {@link http://tinyurl.com/developer-mozilla-org-array-every}&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr Array or array&quot;,&quot; *     like object over which to iterate.&quot;,&quot; * @param {?function(this:S, T, number, ?) : boolean} f The function to call for&quot;,&quot; *     for every element. This function takes 3 arguments (the element, the&quot;,&quot; *     index and the array) and should return a boolean.&quot;,&quot; * @param {S=} opt_obj The object to be used as the value of &#39;this&#39;&quot;,&quot; *     within f.&quot;,&quot; * @return {boolean} false if any element fails the test.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES &amp;&amp;&quot;,&quot;        (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.every) ?&quot;,&quot;    function(arr, f, opt_obj) {&quot;,&quot;      goog.asserts.assert(arr.length != null);&quot;,null,&quot;      return Array.prototype.every.call(arr, f, opt_obj);&quot;,&quot;    } :&quot;,&quot;    function(arr, f, opt_obj) {&quot;,&quot;      var l = arr.length;  // must be fixed during loop... see docs&quot;,&quot;      var arr2 = goog.isString(arr) ? arr.split(&#39;&#39;) : arr;&quot;,&quot;      for (var i = 0; i &lt; l; i++) {&quot;,&quot;        if (i in arr2 &amp;&amp; !f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {&quot;,&quot;          return false;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;      return true;&quot;,&quot;    };&quot;,null,null,&quot;/**&quot;,&quot; * Counts the array elements that fulfill the predicate, i.e. for which the&quot;,&quot; * callback function returns true. Skips holes in the array.&quot;,&quot; *&quot;,&quot; * @param {!IArrayLike&lt;T&gt;|string} arr Array or array like object&quot;,&quot; *     over which to iterate.&quot;,&quot; * @param {function(this: S, T, number, ?): boolean} f The function to call for&quot;,&quot; *     every element. Takes 3 arguments (the element, the index and the array).&quot;,&quot; * @param {S=} opt_obj The object to be used as the value of &#39;this&#39; within f.&quot;,&quot; * @return {number} The number of the matching elements.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.count = function(arr, f, opt_obj) {&quot;,&quot;  var count = 0;&quot;,&quot;  goog.array.forEach(arr, function(element, index, arr) {&quot;,&quot;    if (f.call(/** @type {?} */ (opt_obj), element, index, arr)) {&quot;,&quot;      ++count;&quot;,&quot;    }&quot;,&quot;  }, opt_obj);&quot;,&quot;  return count;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Search an array for the first element that satisfies a given condition and&quot;,&quot; * return that element.&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr Array or array&quot;,&quot; *     like object over which to iterate.&quot;,&quot; * @param {?function(this:S, T, number, ?) : boolean} f The function to call&quot;,&quot; *     for every element. This function takes 3 arguments (the element, the&quot;,&quot; *     index and the array) and should return a boolean.&quot;,&quot; * @param {S=} opt_obj An optional \&quot;this\&quot; context for the function.&quot;,&quot; * @return {T|null} The first array element that passes the test, or null if no&quot;,&quot; *     element is found.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.find = function(arr, f, opt_obj) {&quot;,&quot;  var i = goog.array.findIndex(arr, f, opt_obj);&quot;,&quot;  return i &lt; 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Search an array for the first element that satisfies a given condition and&quot;,&quot; * return its index.&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr Array or array&quot;,&quot; *     like object over which to iterate.&quot;,&quot; * @param {?function(this:S, T, number, ?) : boolean} f The function to call for&quot;,&quot; *     every element. This function&quot;,&quot; *     takes 3 arguments (the element, the index and the array) and should&quot;,&quot; *     return a boolean.&quot;,&quot; * @param {S=} opt_obj An optional \&quot;this\&quot; context for the function.&quot;,&quot; * @return {number} The index of the first array element that passes the test,&quot;,&quot; *     or -1 if no element is found.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.findIndex = function(arr, f, opt_obj) {&quot;,&quot;  var l = arr.length;  // must be fixed during loop... see docs&quot;,&quot;  var arr2 = goog.isString(arr) ? arr.split(&#39;&#39;) : arr;&quot;,&quot;  for (var i = 0; i &lt; l; i++) {&quot;,&quot;    if (i in arr2 &amp;&amp; f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {&quot;,&quot;      return i;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return -1;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Search an array (in reverse order) for the last element that satisfies a&quot;,&quot; * given condition and return that element.&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr Array or array&quot;,&quot; *     like object over which to iterate.&quot;,&quot; * @param {?function(this:S, T, number, ?) : boolean} f The function to call&quot;,&quot; *     for every element. This function&quot;,&quot; *     takes 3 arguments (the element, the index and the array) and should&quot;,&quot; *     return a boolean.&quot;,&quot; * @param {S=} opt_obj An optional \&quot;this\&quot; context for the function.&quot;,&quot; * @return {T|null} The last array element that passes the test, or null if no&quot;,&quot; *     element is found.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.findRight = function(arr, f, opt_obj) {&quot;,&quot;  var i = goog.array.findIndexRight(arr, f, opt_obj);&quot;,&quot;  return i &lt; 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Search an array (in reverse order) for the last element that satisfies a&quot;,&quot; * given condition and return its index.&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr Array or array&quot;,&quot; *     like object over which to iterate.&quot;,&quot; * @param {?function(this:S, T, number, ?) : boolean} f The function to call&quot;,&quot; *     for every element. This function&quot;,&quot; *     takes 3 arguments (the element, the index and the array) and should&quot;,&quot; *     return a boolean.&quot;,&quot; * @param {S=} opt_obj An optional \&quot;this\&quot; context for the function.&quot;,&quot; * @return {number} The index of the last array element that passes the test,&quot;,&quot; *     or -1 if no element is found.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.findIndexRight = function(arr, f, opt_obj) {&quot;,&quot;  var l = arr.length;  // must be fixed during loop... see docs&quot;,&quot;  var arr2 = goog.isString(arr) ? arr.split(&#39;&#39;) : arr;&quot;,&quot;  for (var i = l - 1; i &gt;= 0; i--) {&quot;,&quot;    if (i in arr2 &amp;&amp; f.call(/** @type {?} */ (opt_obj), arr2[i], i, arr)) {&quot;,&quot;      return i;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return -1;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Whether the array contains the given object.&quot;,&quot; * @param {IArrayLike&lt;?&gt;|string} arr The array to test for the presence of the&quot;,&quot; *     element.&quot;,&quot; * @param {*} obj The object for which to test.&quot;,&quot; * @return {boolean} true if obj is present.&quot;,&quot; */&quot;,&quot;goog.array.contains = function(arr, obj) {&quot;,&quot;  return goog.array.indexOf(arr, obj) &gt;= 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Whether the array is empty.&quot;,&quot; * @param {IArrayLike&lt;?&gt;|string} arr The array to test.&quot;,&quot; * @return {boolean} true if empty.&quot;,&quot; */&quot;,&quot;goog.array.isEmpty = function(arr) {&quot;,&quot;  return arr.length == 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Clears the array.&quot;,&quot; * @param {IArrayLike&lt;?&gt;} arr Array or array like object to clear.&quot;,&quot; */&quot;,&quot;goog.array.clear = function(arr) {&quot;,&quot;  // For non real arrays we don&#39;t have the magic length so we delete the&quot;,&quot;  // indices.&quot;,&quot;  if (!goog.isArray(arr)) {&quot;,&quot;    for (var i = arr.length - 1; i &gt;= 0; i--) {&quot;,&quot;      delete arr[i];&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  arr.length = 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Pushes an item into an array, if it&#39;s not already in the array.&quot;,&quot; * @param {Array&lt;T&gt;} arr Array into which to insert the item.&quot;,&quot; * @param {T} obj Value to add.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.insert = function(arr, obj) {&quot;,&quot;  if (!goog.array.contains(arr, obj)) {&quot;,&quot;    arr.push(obj);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Inserts an object at the given index of the array.&quot;,&quot; * @param {IArrayLike&lt;?&gt;} arr The array to modify.&quot;,&quot; * @param {*} obj The object to insert.&quot;,&quot; * @param {number=} opt_i The index at which to insert the object. If omitted,&quot;,&quot; *      treated as 0. A negative index is counted from the end of the array.&quot;,&quot; */&quot;,&quot;goog.array.insertAt = function(arr, obj, opt_i) {&quot;,&quot;  goog.array.splice(arr, opt_i, 0, obj);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Inserts at the given index of the array, all elements of another array.&quot;,&quot; * @param {IArrayLike&lt;?&gt;} arr The array to modify.&quot;,&quot; * @param {IArrayLike&lt;?&gt;} elementsToAdd The array of elements to add.&quot;,&quot; * @param {number=} opt_i The index at which to insert the object. If omitted,&quot;,&quot; *      treated as 0. A negative index is counted from the end of the array.&quot;,&quot; */&quot;,&quot;goog.array.insertArrayAt = function(arr, elementsToAdd, opt_i) {&quot;,&quot;  goog.partial(goog.array.splice, arr, opt_i, 0).apply(null, elementsToAdd);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Inserts an object into an array before a specified object.&quot;,&quot; * @param {Array&lt;T&gt;} arr The array to modify.&quot;,&quot; * @param {T} obj The object to insert.&quot;,&quot; * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2&quot;,&quot; *     is omitted or not found, obj is inserted at the end of the array.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.insertBefore = function(arr, obj, opt_obj2) {&quot;,&quot;  var i;&quot;,&quot;  if (arguments.length == 2 || (i = goog.array.indexOf(arr, opt_obj2)) &lt; 0) {&quot;,&quot;    arr.push(obj);&quot;,&quot;  } else {&quot;,&quot;    goog.array.insertAt(arr, obj, i);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes the first occurrence of a particular value from an array.&quot;,&quot; * @param {IArrayLike&lt;T&gt;} arr Array from which to remove&quot;,&quot; *     value.&quot;,&quot; * @param {T} obj Object to remove.&quot;,&quot; * @return {boolean} True if an element was removed.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.remove = function(arr, obj) {&quot;,&quot;  var i = goog.array.indexOf(arr, obj);&quot;,&quot;  var rv;&quot;,&quot;  if ((rv = i &gt;= 0)) {&quot;,&quot;    goog.array.removeAt(arr, i);&quot;,&quot;  }&quot;,&quot;  return rv;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes the last occurrence of a particular value from an array.&quot;,&quot; * @param {!IArrayLike&lt;T&gt;} arr Array from which to remove value.&quot;,&quot; * @param {T} obj Object to remove.&quot;,&quot; * @return {boolean} True if an element was removed.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.removeLast = function(arr, obj) {&quot;,&quot;  var i = goog.array.lastIndexOf(arr, obj);&quot;,&quot;  if (i &gt;= 0) {&quot;,&quot;    goog.array.removeAt(arr, i);&quot;,&quot;    return true;&quot;,&quot;  }&quot;,&quot;  return false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes from an array the element at index i&quot;,&quot; * @param {IArrayLike&lt;?&gt;} arr Array or array like object from which to&quot;,&quot; *     remove value.&quot;,&quot; * @param {number} i The index to remove.&quot;,&quot; * @return {boolean} True if an element was removed.&quot;,&quot; */&quot;,&quot;goog.array.removeAt = function(arr, i) {&quot;,&quot;  goog.asserts.assert(arr.length != null);&quot;,null,&quot;  // use generic form of splice&quot;,&quot;  // splice returns the removed items and if successful the length of that&quot;,&quot;  // will be 1&quot;,&quot;  return Array.prototype.splice.call(arr, i, 1).length == 1;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes the first value that satisfies the given condition.&quot;,&quot; * @param {IArrayLike&lt;T&gt;} arr Array or array&quot;,&quot; *     like object over which to iterate.&quot;,&quot; * @param {?function(this:S, T, number, ?) : boolean} f The function to call&quot;,&quot; *     for every element. This function&quot;,&quot; *     takes 3 arguments (the element, the index and the array) and should&quot;,&quot; *     return a boolean.&quot;,&quot; * @param {S=} opt_obj An optional \&quot;this\&quot; context for the function.&quot;,&quot; * @return {boolean} True if an element was removed.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.removeIf = function(arr, f, opt_obj) {&quot;,&quot;  var i = goog.array.findIndex(arr, f, opt_obj);&quot;,&quot;  if (i &gt;= 0) {&quot;,&quot;    goog.array.removeAt(arr, i);&quot;,&quot;    return true;&quot;,&quot;  }&quot;,&quot;  return false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes all values that satisfy the given condition.&quot;,&quot; * @param {IArrayLike&lt;T&gt;} arr Array or array&quot;,&quot; *     like object over which to iterate.&quot;,&quot; * @param {?function(this:S, T, number, ?) : boolean} f The function to call&quot;,&quot; *     for every element. This function&quot;,&quot; *     takes 3 arguments (the element, the index and the array) and should&quot;,&quot; *     return a boolean.&quot;,&quot; * @param {S=} opt_obj An optional \&quot;this\&quot; context for the function.&quot;,&quot; * @return {number} The number of items removed&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.removeAllIf = function(arr, f, opt_obj) {&quot;,&quot;  var removedCount = 0;&quot;,&quot;  goog.array.forEachRight(arr, function(val, index) {&quot;,&quot;    if (f.call(/** @type {?} */ (opt_obj), val, index, arr)) {&quot;,&quot;      if (goog.array.removeAt(arr, index)) {&quot;,&quot;        removedCount++;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  });&quot;,&quot;  return removedCount;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns a new array that is the result of joining the arguments.  If arrays&quot;,&quot; * are passed then their items are added, however, if non-arrays are passed they&quot;,&quot; * will be added to the return array as is.&quot;,&quot; *&quot;,&quot; * Note that ArrayLike objects will be added as is, rather than having their&quot;,&quot; * items added.&quot;,&quot; *&quot;,&quot; * goog.array.concat([1, 2], [3, 4]) -&gt; [1, 2, 3, 4]&quot;,&quot; * goog.array.concat(0, [1, 2]) -&gt; [0, 1, 2]&quot;,&quot; * goog.array.concat([1, 2], null) -&gt; [1, 2, null]&quot;,&quot; *&quot;,&quot; * There is bug in all current versions of IE (6, 7 and 8) where arrays created&quot;,&quot; * in an iframe become corrupted soon (not immediately) after the iframe is&quot;,&quot; * destroyed. This is common if loading data via goog.net.IframeIo, for example.&quot;,&quot; * This corruption only affects the concat method which will start throwing&quot;,&quot; * Catastrophic Errors (#-2147418113).&quot;,&quot; *&quot;,&quot; * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.&quot;,&quot; *&quot;,&quot; * Internally goog.array should use this, so that all methods will continue to&quot;,&quot; * work on these broken array objects.&quot;,&quot; *&quot;,&quot; * @param {...*} var_args Items to concatenate.  Arrays will have each item&quot;,&quot; *     added, while primitives and objects will be added as is.&quot;,&quot; * @return {!Array&lt;?&gt;} The new resultant array.&quot;,&quot; */&quot;,&quot;goog.array.concat = function(var_args) {&quot;,&quot;  return Array.prototype.concat.apply([], arguments);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns a new array that contains the contents of all the arrays passed.&quot;,&quot; * @param {...!Array&lt;T&gt;} var_args&quot;,&quot; * @return {!Array&lt;T&gt;}&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.join = function(var_args) {&quot;,&quot;  return Array.prototype.concat.apply([], arguments);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts an object to an array.&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} object  The object to convert to an&quot;,&quot; *     array.&quot;,&quot; * @return {!Array&lt;T&gt;} The object converted into an array. If object has a&quot;,&quot; *     length property, every property indexed with a non-negative number&quot;,&quot; *     less than length will be included in the result. If object does not&quot;,&quot; *     have a length property, an empty array will be returned.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.toArray = function(object) {&quot;,&quot;  var length = object.length;&quot;,null,&quot;  // If length is not a number the following it false. This case is kept for&quot;,&quot;  // backwards compatibility since there are callers that pass objects that are&quot;,&quot;  // not array like.&quot;,&quot;  if (length &gt; 0) {&quot;,&quot;    var rv = new Array(length);&quot;,&quot;    for (var i = 0; i &lt; length; i++) {&quot;,&quot;      rv[i] = object[i];&quot;,&quot;    }&quot;,&quot;    return rv;&quot;,&quot;  }&quot;,&quot;  return [];&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Does a shallow copy of an array.&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr  Array or array-like object to&quot;,&quot; *     clone.&quot;,&quot; * @return {!Array&lt;T&gt;} Clone of the input array.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.clone = goog.array.toArray;&quot;,null,null,&quot;/**&quot;,&quot; * Extends an array with another array, element, or \&quot;array like\&quot; object.&quot;,&quot; * This function operates &#39;in-place&#39;, it does not create a new Array.&quot;,&quot; *&quot;,&quot; * Example:&quot;,&quot; * var a = [];&quot;,&quot; * goog.array.extend(a, [0, 1]);&quot;,&quot; * a; // [0, 1]&quot;,&quot; * goog.array.extend(a, 2);&quot;,&quot; * a; // [0, 1, 2]&quot;,&quot; *&quot;,&quot; * @param {Array&lt;VALUE&gt;} arr1  The array to modify.&quot;,&quot; * @param {...(Array&lt;VALUE&gt;|VALUE)} var_args The elements or arrays of elements&quot;,&quot; *     to add to arr1.&quot;,&quot; * @template VALUE&quot;,&quot; */&quot;,&quot;goog.array.extend = function(arr1, var_args) {&quot;,&quot;  for (var i = 1; i &lt; arguments.length; i++) {&quot;,&quot;    var arr2 = arguments[i];&quot;,&quot;    if (goog.isArrayLike(arr2)) {&quot;,&quot;      var len1 = arr1.length || 0;&quot;,&quot;      var len2 = arr2.length || 0;&quot;,&quot;      arr1.length = len1 + len2;&quot;,&quot;      for (var j = 0; j &lt; len2; j++) {&quot;,&quot;        arr1[len1 + j] = arr2[j];&quot;,&quot;      }&quot;,&quot;    } else {&quot;,&quot;      arr1.push(arr2);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds or removes elements from an array. This is a generic version of Array&quot;,&quot; * splice. This means that it might work on other objects similar to arrays,&quot;,&quot; * such as the arguments object.&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;T&gt;} arr The array to modify.&quot;,&quot; * @param {number|undefined} index The index at which to start changing the&quot;,&quot; *     array. If not defined, treated as 0.&quot;,&quot; * @param {number} howMany How many elements to remove (0 means no removal. A&quot;,&quot; *     value below 0 is treated as zero and so is any other non number. Numbers&quot;,&quot; *     are floored).&quot;,&quot; * @param {...T} var_args Optional, additional elements to insert into the&quot;,&quot; *     array.&quot;,&quot; * @return {!Array&lt;T&gt;} the removed elements.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.splice = function(arr, index, howMany, var_args) {&quot;,&quot;  goog.asserts.assert(arr.length != null);&quot;,null,&quot;  return Array.prototype.splice.apply(arr, goog.array.slice(arguments, 1));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns a new array from a segment of an array. This is a generic version of&quot;,&quot; * Array slice. This means that it might work on other objects similar to&quot;,&quot; * arrays, such as the arguments object.&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;T&gt;|string} arr The array from&quot;,&quot; * which to copy a segment.&quot;,&quot; * @param {number} start The index of the first element to copy.&quot;,&quot; * @param {number=} opt_end The index after the last element to copy.&quot;,&quot; * @return {!Array&lt;T&gt;} A new array containing the specified segment of the&quot;,&quot; *     original array.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.slice = function(arr, start, opt_end) {&quot;,&quot;  goog.asserts.assert(arr.length != null);&quot;,null,&quot;  // passing 1 arg to slice is not the same as passing 2 where the second is&quot;,&quot;  // null or undefined (in that case the second argument is treated as 0).&quot;,&quot;  // we could use slice on the arguments object and then use apply instead of&quot;,&quot;  // testing the length&quot;,&quot;  if (arguments.length &lt;= 2) {&quot;,&quot;    return Array.prototype.slice.call(arr, start);&quot;,&quot;  } else {&quot;,&quot;    return Array.prototype.slice.call(arr, start, opt_end);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes all duplicates from an array (retaining only the first&quot;,&quot; * occurrence of each array element).  This function modifies the&quot;,&quot; * array in place and doesn&#39;t change the order of the non-duplicate items.&quot;,&quot; *&quot;,&quot; * For objects, duplicates are identified as having the same unique ID as&quot;,&quot; * defined by {@link goog.getUid}.&quot;,&quot; *&quot;,&quot; * Alternatively you can specify a custom hash function that returns a unique&quot;,&quot; * value for each item in the array it should consider unique.&quot;,&quot; *&quot;,&quot; * Runtime: N,&quot;,&quot; * Worstcase space: 2N (no dupes)&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;T&gt;} arr The array from which to remove&quot;,&quot; *     duplicates.&quot;,&quot; * @param {Array=} opt_rv An optional array in which to return the results,&quot;,&quot; *     instead of performing the removal inplace.  If specified, the original&quot;,&quot; *     array will remain unchanged.&quot;,&quot; * @param {function(T):string=} opt_hashFn An optional function to use to&quot;,&quot; *     apply to every item in the array. This function should return a unique&quot;,&quot; *     value for each item in the array it should consider unique.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.removeDuplicates = function(arr, opt_rv, opt_hashFn) {&quot;,&quot;  var returnArray = opt_rv || arr;&quot;,&quot;  var defaultHashFn = function(item) {&quot;,&quot;    // Prefix each type with a single character representing the type to&quot;,&quot;    // prevent conflicting keys (e.g. true and &#39;true&#39;).&quot;,&quot;    return goog.isObject(item) ? &#39;o&#39; + goog.getUid(item) :&quot;,&quot;                                 (typeof item).charAt(0) + item;&quot;,&quot;  };&quot;,&quot;  var hashFn = opt_hashFn || defaultHashFn;&quot;,null,&quot;  var seen = {}, cursorInsert = 0, cursorRead = 0;&quot;,&quot;  while (cursorRead &lt; arr.length) {&quot;,&quot;    var current = arr[cursorRead++];&quot;,&quot;    var key = hashFn(current);&quot;,&quot;    if (!Object.prototype.hasOwnProperty.call(seen, key)) {&quot;,&quot;      seen[key] = true;&quot;,&quot;      returnArray[cursorInsert++] = current;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  returnArray.length = cursorInsert;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Searches the specified array for the specified target using the binary&quot;,&quot; * search algorithm.  If no opt_compareFn is specified, elements are compared&quot;,&quot; * using &lt;code&gt;goog.array.defaultCompare&lt;/code&gt;, which compares the elements&quot;,&quot; * using the built in &lt; and &gt; operators.  This will produce the expected&quot;,&quot; * behavior for homogeneous arrays of String(s) and Number(s). The array&quot;,&quot; * specified &lt;b&gt;must&lt;/b&gt; be sorted in ascending order (as defined by the&quot;,&quot; * comparison function).  If the array is not sorted, results are undefined.&quot;,&quot; * If the array contains multiple instances of the specified target value, any&quot;,&quot; * of these instances may be found.&quot;,&quot; *&quot;,&quot; * Runtime: O(log n)&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;VALUE&gt;} arr The array to be searched.&quot;,&quot; * @param {TARGET} target The sought value.&quot;,&quot; * @param {function(TARGET, VALUE): number=} opt_compareFn Optional comparison&quot;,&quot; *     function by which the array is ordered. Should take 2 arguments to&quot;,&quot; *     compare, and return a negative number, zero, or a positive number&quot;,&quot; *     depending on whether the first argument is less than, equal to, or&quot;,&quot; *     greater than the second.&quot;,&quot; * @return {number} Lowest index of the target value if found, otherwise&quot;,&quot; *     (-(insertion point) - 1). The insertion point is where the value should&quot;,&quot; *     be inserted into arr to preserve the sorted property.  Return value &gt;= 0&quot;,&quot; *     iff target is found.&quot;,&quot; * @template TARGET, VALUE&quot;,&quot; */&quot;,&quot;goog.array.binarySearch = function(arr, target, opt_compareFn) {&quot;,&quot;  return goog.array.binarySearch_(&quot;,&quot;      arr, opt_compareFn || goog.array.defaultCompare, false /* isEvaluator */,&quot;,&quot;      target);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Selects an index in the specified array using the binary search algorithm.&quot;,&quot; * The evaluator receives an element and determines whether the desired index&quot;,&quot; * is before, at, or after it.  The evaluator must be consistent (formally,&quot;,&quot; * goog.array.map(goog.array.map(arr, evaluator, opt_obj), goog.math.sign)&quot;,&quot; * must be monotonically non-increasing).&quot;,&quot; *&quot;,&quot; * Runtime: O(log n)&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;VALUE&gt;} arr The array to be searched.&quot;,&quot; * @param {function(this:THIS, VALUE, number, ?): number} evaluator&quot;,&quot; *     Evaluator function that receives 3 arguments (the element, the index and&quot;,&quot; *     the array). Should return a negative number, zero, or a positive number&quot;,&quot; *     depending on whether the desired index is before, at, or after the&quot;,&quot; *     element passed to it.&quot;,&quot; * @param {THIS=} opt_obj The object to be used as the value of &#39;this&#39;&quot;,&quot; *     within evaluator.&quot;,&quot; * @return {number} Index of the leftmost element matched by the evaluator, if&quot;,&quot; *     such exists; otherwise (-(insertion point) - 1). The insertion point is&quot;,&quot; *     the index of the first element for which the evaluator returns negative,&quot;,&quot; *     or arr.length if no such element exists. The return value is non-negative&quot;,&quot; *     iff a match is found.&quot;,&quot; * @template THIS, VALUE&quot;,&quot; */&quot;,&quot;goog.array.binarySelect = function(arr, evaluator, opt_obj) {&quot;,&quot;  return goog.array.binarySearch_(&quot;,&quot;      arr, evaluator, true /* isEvaluator */, undefined /* opt_target */,&quot;,&quot;      opt_obj);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Implementation of a binary search algorithm which knows how to use both&quot;,&quot; * comparison functions and evaluators. If an evaluator is provided, will call&quot;,&quot; * the evaluator with the given optional data object, conforming to the&quot;,&quot; * interface defined in binarySelect. Otherwise, if a comparison function is&quot;,&quot; * provided, will call the comparison function against the given data object.&quot;,&quot; *&quot;,&quot; * This implementation purposefully does not use goog.bind or goog.partial for&quot;,&quot; * performance reasons.&quot;,&quot; *&quot;,&quot; * Runtime: O(log n)&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;?&gt;} arr The array to be searched.&quot;,&quot; * @param {function(?, ?, ?): number | function(?, ?): number} compareFn&quot;,&quot; *     Either an evaluator or a comparison function, as defined by binarySearch&quot;,&quot; *     and binarySelect above.&quot;,&quot; * @param {boolean} isEvaluator Whether the function is an evaluator or a&quot;,&quot; *     comparison function.&quot;,&quot; * @param {?=} opt_target If the function is a comparison function, then&quot;,&quot; *     this is the target to binary search for.&quot;,&quot; * @param {Object=} opt_selfObj If the function is an evaluator, this is an&quot;,&quot; *     optional this object for the evaluator.&quot;,&quot; * @return {number} Lowest index of the target value if found, otherwise&quot;,&quot; *     (-(insertion point) - 1). The insertion point is where the value should&quot;,&quot; *     be inserted into arr to preserve the sorted property.  Return value &gt;= 0&quot;,&quot; *     iff target is found.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.array.binarySearch_ = function(&quot;,&quot;    arr, compareFn, isEvaluator, opt_target, opt_selfObj) {&quot;,&quot;  var left = 0;            // inclusive&quot;,&quot;  var right = arr.length;  // exclusive&quot;,&quot;  var found;&quot;,&quot;  while (left &lt; right) {&quot;,&quot;    var middle = (left + right) &gt;&gt; 1;&quot;,&quot;    var compareResult;&quot;,&quot;    if (isEvaluator) {&quot;,&quot;      compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);&quot;,&quot;    } else {&quot;,&quot;      // NOTE(dimvar): To avoid this cast, we&#39;d have to use function overloading&quot;,&quot;      // for the type of binarySearch_, which the type system can&#39;t express yet.&quot;,&quot;      compareResult = /** @type {function(?, ?): number} */ (compareFn)(&quot;,&quot;          opt_target, arr[middle]);&quot;,&quot;    }&quot;,&quot;    if (compareResult &gt; 0) {&quot;,&quot;      left = middle + 1;&quot;,&quot;    } else {&quot;,&quot;      right = middle;&quot;,&quot;      // We are looking for the lowest index so we can&#39;t return immediately.&quot;,&quot;      found = !compareResult;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  // left is the index if found, or the insertion point otherwise.&quot;,&quot;  // ~left is a shorthand for -left - 1.&quot;,&quot;  return found ? left : ~left;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sorts the specified array into ascending order.  If no opt_compareFn is&quot;,&quot; * specified, elements are compared using&quot;,&quot; * &lt;code&gt;goog.array.defaultCompare&lt;/code&gt;, which compares the elements using&quot;,&quot; * the built in &lt; and &gt; operators.  This will produce the expected behavior&quot;,&quot; * for homogeneous arrays of String(s) and Number(s), unlike the native sort,&quot;,&quot; * but will give unpredictable results for heterogeneous lists of strings and&quot;,&quot; * numbers with different numbers of digits.&quot;,&quot; *&quot;,&quot; * This sort is not guaranteed to be stable.&quot;,&quot; *&quot;,&quot; * Runtime: Same as &lt;code&gt;Array.prototype.sort&lt;/code&gt;&quot;,&quot; *&quot;,&quot; * @param {Array&lt;T&gt;} arr The array to be sorted.&quot;,&quot; * @param {?function(T,T):number=} opt_compareFn Optional comparison&quot;,&quot; *     function by which the&quot;,&quot; *     array is to be ordered. Should take 2 arguments to compare, and return a&quot;,&quot; *     negative number, zero, or a positive number depending on whether the&quot;,&quot; *     first argument is less than, equal to, or greater than the second.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.sort = function(arr, opt_compareFn) {&quot;,&quot;  // TODO(arv): Update type annotation since null is not accepted.&quot;,&quot;  arr.sort(opt_compareFn || goog.array.defaultCompare);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sorts the specified array into ascending order in a stable way.  If no&quot;,&quot; * opt_compareFn is specified, elements are compared using&quot;,&quot; * &lt;code&gt;goog.array.defaultCompare&lt;/code&gt;, which compares the elements using&quot;,&quot; * the built in &lt; and &gt; operators.  This will produce the expected behavior&quot;,&quot; * for homogeneous arrays of String(s) and Number(s).&quot;,&quot; *&quot;,&quot; * Runtime: Same as &lt;code&gt;Array.prototype.sort&lt;/code&gt;, plus an additional&quot;,&quot; * O(n) overhead of copying the array twice.&quot;,&quot; *&quot;,&quot; * @param {Array&lt;T&gt;} arr The array to be sorted.&quot;,&quot; * @param {?function(T, T): number=} opt_compareFn Optional comparison function&quot;,&quot; *     by which the array is to be ordered. Should take 2 arguments to compare,&quot;,&quot; *     and return a negative number, zero, or a positive number depending on&quot;,&quot; *     whether the first argument is less than, equal to, or greater than the&quot;,&quot; *     second.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.stableSort = function(arr, opt_compareFn) {&quot;,&quot;  var compArr = new Array(arr.length);&quot;,&quot;  for (var i = 0; i &lt; arr.length; i++) {&quot;,&quot;    compArr[i] = {index: i, value: arr[i]};&quot;,&quot;  }&quot;,&quot;  var valueCompareFn = opt_compareFn || goog.array.defaultCompare;&quot;,&quot;  function stableCompareFn(obj1, obj2) {&quot;,&quot;    return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;&quot;,&quot;  }&quot;,&quot;  goog.array.sort(compArr, stableCompareFn);&quot;,&quot;  for (var i = 0; i &lt; arr.length; i++) {&quot;,&quot;    arr[i] = compArr[i].value;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sort the specified array into ascending order based on item keys&quot;,&quot; * returned by the specified key function.&quot;,&quot; * If no opt_compareFn is specified, the keys are compared in ascending order&quot;,&quot; * using &lt;code&gt;goog.array.defaultCompare&lt;/code&gt;.&quot;,&quot; *&quot;,&quot; * Runtime: O(S(f(n)), where S is runtime of &lt;code&gt;goog.array.sort&lt;/code&gt;&quot;,&quot; * and f(n) is runtime of the key function.&quot;,&quot; *&quot;,&quot; * @param {Array&lt;T&gt;} arr The array to be sorted.&quot;,&quot; * @param {function(T): K} keyFn Function taking array element and returning&quot;,&quot; *     a key used for sorting this element.&quot;,&quot; * @param {?function(K, K): number=} opt_compareFn Optional comparison function&quot;,&quot; *     by which the keys are to be ordered. Should take 2 arguments to compare,&quot;,&quot; *     and return a negative number, zero, or a positive number depending on&quot;,&quot; *     whether the first argument is less than, equal to, or greater than the&quot;,&quot; *     second.&quot;,&quot; * @template T,K&quot;,&quot; */&quot;,&quot;goog.array.sortByKey = function(arr, keyFn, opt_compareFn) {&quot;,&quot;  var keyCompareFn = opt_compareFn || goog.array.defaultCompare;&quot;,&quot;  goog.array.sort(&quot;,&quot;      arr, function(a, b) { return keyCompareFn(keyFn(a), keyFn(b)); });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sorts an array of objects by the specified object key and compare&quot;,&quot; * function. If no compare function is provided, the key values are&quot;,&quot; * compared in ascending order using &lt;code&gt;goog.array.defaultCompare&lt;/code&gt;.&quot;,&quot; * This won&#39;t work for keys that get renamed by the compiler. So use&quot;,&quot; * {&#39;foo&#39;: 1, &#39;bar&#39;: 2} rather than {foo: 1, bar: 2}.&quot;,&quot; * @param {Array&lt;Object&gt;} arr An array of objects to sort.&quot;,&quot; * @param {string} key The object key to sort by.&quot;,&quot; * @param {Function=} opt_compareFn The function to use to compare key&quot;,&quot; *     values.&quot;,&quot; */&quot;,&quot;goog.array.sortObjectsByKey = function(arr, key, opt_compareFn) {&quot;,&quot;  goog.array.sortByKey(arr, function(obj) { return obj[key]; }, opt_compareFn);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Tells if the array is sorted.&quot;,&quot; * @param {!Array&lt;T&gt;} arr The array.&quot;,&quot; * @param {?function(T,T):number=} opt_compareFn Function to compare the&quot;,&quot; *     array elements.&quot;,&quot; *     Should take 2 arguments to compare, and return a negative number, zero,&quot;,&quot; *     or a positive number depending on whether the first argument is less&quot;,&quot; *     than, equal to, or greater than the second.&quot;,&quot; * @param {boolean=} opt_strict If true no equal elements are allowed.&quot;,&quot; * @return {boolean} Whether the array is sorted.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.isSorted = function(arr, opt_compareFn, opt_strict) {&quot;,&quot;  var compare = opt_compareFn || goog.array.defaultCompare;&quot;,&quot;  for (var i = 1; i &lt; arr.length; i++) {&quot;,&quot;    var compareResult = compare(arr[i - 1], arr[i]);&quot;,&quot;    if (compareResult &gt; 0 || compareResult == 0 &amp;&amp; opt_strict) {&quot;,&quot;      return false;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return true;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Compares two arrays for equality. Two arrays are considered equal if they&quot;,&quot; * have the same length and their corresponding elements are equal according to&quot;,&quot; * the comparison function.&quot;,&quot; *&quot;,&quot; * @param {IArrayLike&lt;?&gt;} arr1 The first array to compare.&quot;,&quot; * @param {IArrayLike&lt;?&gt;} arr2 The second array to compare.&quot;,&quot; * @param {Function=} opt_equalsFn Optional comparison function.&quot;,&quot; *     Should take 2 arguments to compare, and return true if the arguments&quot;,&quot; *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which&quot;,&quot; *     compares the elements using the built-in &#39;===&#39; operator.&quot;,&quot; * @return {boolean} Whether the two arrays are equal.&quot;,&quot; */&quot;,&quot;goog.array.equals = function(arr1, arr2, opt_equalsFn) {&quot;,&quot;  if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||&quot;,&quot;      arr1.length != arr2.length) {&quot;,&quot;    return false;&quot;,&quot;  }&quot;,&quot;  var l = arr1.length;&quot;,&quot;  var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;&quot;,&quot;  for (var i = 0; i &lt; l; i++) {&quot;,&quot;    if (!equalsFn(arr1[i], arr2[i])) {&quot;,&quot;      return false;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return true;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * 3-way array compare function.&quot;,&quot; * @param {!IArrayLike&lt;VALUE&gt;} arr1 The first array to&quot;,&quot; *     compare.&quot;,&quot; * @param {!IArrayLike&lt;VALUE&gt;} arr2 The second array to&quot;,&quot; *     compare.&quot;,&quot; * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison&quot;,&quot; *     function by which the array is to be ordered. Should take 2 arguments to&quot;,&quot; *     compare, and return a negative number, zero, or a positive number&quot;,&quot; *     depending on whether the first argument is less than, equal to, or&quot;,&quot; *     greater than the second.&quot;,&quot; * @return {number} Negative number, zero, or a positive number depending on&quot;,&quot; *     whether the first argument is less than, equal to, or greater than the&quot;,&quot; *     second.&quot;,&quot; * @template VALUE&quot;,&quot; */&quot;,&quot;goog.array.compare3 = function(arr1, arr2, opt_compareFn) {&quot;,&quot;  var compare = opt_compareFn || goog.array.defaultCompare;&quot;,&quot;  var l = Math.min(arr1.length, arr2.length);&quot;,&quot;  for (var i = 0; i &lt; l; i++) {&quot;,&quot;    var result = compare(arr1[i], arr2[i]);&quot;,&quot;    if (result != 0) {&quot;,&quot;      return result;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return goog.array.defaultCompare(arr1.length, arr2.length);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Compares its two arguments for order, using the built in &lt; and &gt;&quot;,&quot; * operators.&quot;,&quot; * @param {VALUE} a The first object to be compared.&quot;,&quot; * @param {VALUE} b The second object to be compared.&quot;,&quot; * @return {number} A negative number, zero, or a positive number as the first&quot;,&quot; *     argument is less than, equal to, or greater than the second,&quot;,&quot; *     respectively.&quot;,&quot; * @template VALUE&quot;,&quot; */&quot;,&quot;goog.array.defaultCompare = function(a, b) {&quot;,&quot;  return a &gt; b ? 1 : a &lt; b ? -1 : 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Compares its two arguments for inverse order, using the built in &lt; and &gt;&quot;,&quot; * operators.&quot;,&quot; * @param {VALUE} a The first object to be compared.&quot;,&quot; * @param {VALUE} b The second object to be compared.&quot;,&quot; * @return {number} A negative number, zero, or a positive number as the first&quot;,&quot; *     argument is greater than, equal to, or less than the second,&quot;,&quot; *     respectively.&quot;,&quot; * @template VALUE&quot;,&quot; */&quot;,&quot;goog.array.inverseDefaultCompare = function(a, b) {&quot;,&quot;  return -goog.array.defaultCompare(a, b);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Compares its two arguments for equality, using the built in === operator.&quot;,&quot; * @param {*} a The first object to compare.&quot;,&quot; * @param {*} b The second object to compare.&quot;,&quot; * @return {boolean} True if the two arguments are equal, false otherwise.&quot;,&quot; */&quot;,&quot;goog.array.defaultCompareEquality = function(a, b) {&quot;,&quot;  return a === b;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Inserts a value into a sorted array. The array is not modified if the&quot;,&quot; * value is already present.&quot;,&quot; * @param {IArrayLike&lt;VALUE&gt;} array The array to modify.&quot;,&quot; * @param {VALUE} value The object to insert.&quot;,&quot; * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison&quot;,&quot; *     function by which the array is ordered. Should take 2 arguments to&quot;,&quot; *     compare, and return a negative number, zero, or a positive number&quot;,&quot; *     depending on whether the first argument is less than, equal to, or&quot;,&quot; *     greater than the second.&quot;,&quot; * @return {boolean} True if an element was inserted.&quot;,&quot; * @template VALUE&quot;,&quot; */&quot;,&quot;goog.array.binaryInsert = function(array, value, opt_compareFn) {&quot;,&quot;  var index = goog.array.binarySearch(array, value, opt_compareFn);&quot;,&quot;  if (index &lt; 0) {&quot;,&quot;    goog.array.insertAt(array, value, -(index + 1));&quot;,&quot;    return true;&quot;,&quot;  }&quot;,&quot;  return false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes a value from a sorted array.&quot;,&quot; * @param {!IArrayLike&lt;VALUE&gt;} array The array to modify.&quot;,&quot; * @param {VALUE} value The object to remove.&quot;,&quot; * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison&quot;,&quot; *     function by which the array is ordered. Should take 2 arguments to&quot;,&quot; *     compare, and return a negative number, zero, or a positive number&quot;,&quot; *     depending on whether the first argument is less than, equal to, or&quot;,&quot; *     greater than the second.&quot;,&quot; * @return {boolean} True if an element was removed.&quot;,&quot; * @template VALUE&quot;,&quot; */&quot;,&quot;goog.array.binaryRemove = function(array, value, opt_compareFn) {&quot;,&quot;  var index = goog.array.binarySearch(array, value, opt_compareFn);&quot;,&quot;  return (index &gt;= 0) ? goog.array.removeAt(array, index) : false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Splits an array into disjoint buckets according to a splitting function.&quot;,&quot; * @param {Array&lt;T&gt;} array The array.&quot;,&quot; * @param {function(this:S, T, number, !Array&lt;T&gt;):?} sorter Function to call for&quot;,&quot; *     every element.  This takes 3 arguments (the element, the index and the&quot;,&quot; *     array) and must return a valid object key (a string, number, etc), or&quot;,&quot; *     undefined, if that object should not be placed in a bucket.&quot;,&quot; * @param {S=} opt_obj The object to be used as the value of &#39;this&#39; within&quot;,&quot; *     sorter.&quot;,&quot; * @return {!Object&lt;!Array&lt;T&gt;&gt;} An object, with keys being all of the unique&quot;,&quot; *     return values of sorter, and values being arrays containing the items for&quot;,&quot; *     which the splitter returned that key.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.bucket = function(array, sorter, opt_obj) {&quot;,&quot;  var buckets = {};&quot;,null,&quot;  for (var i = 0; i &lt; array.length; i++) {&quot;,&quot;    var value = array[i];&quot;,&quot;    var key = sorter.call(/** @type {?} */ (opt_obj), value, i, array);&quot;,&quot;    if (goog.isDef(key)) {&quot;,&quot;      // Push the value to the right bucket, creating it if necessary.&quot;,&quot;      var bucket = buckets[key] || (buckets[key] = []);&quot;,&quot;      bucket.push(value);&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  return buckets;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a new object built from the provided array and the key-generation&quot;,&quot; * function.&quot;,&quot; * @param {IArrayLike&lt;T&gt;} arr Array or array like object over&quot;,&quot; *     which to iterate whose elements will be the values in the new object.&quot;,&quot; * @param {?function(this:S, T, number, ?) : string} keyFunc The function to&quot;,&quot; *     call for every element. This function takes 3 arguments (the element, the&quot;,&quot; *     index and the array) and should return a string that will be used as the&quot;,&quot; *     key for the element in the new object. If the function returns the same&quot;,&quot; *     key for more than one element, the value for that key is&quot;,&quot; *     implementation-defined.&quot;,&quot; * @param {S=} opt_obj The object to be used as the value of &#39;this&#39;&quot;,&quot; *     within keyFunc.&quot;,&quot; * @return {!Object&lt;T&gt;} The new object.&quot;,&quot; * @template T,S&quot;,&quot; */&quot;,&quot;goog.array.toObject = function(arr, keyFunc, opt_obj) {&quot;,&quot;  var ret = {};&quot;,&quot;  goog.array.forEach(arr, function(element, index) {&quot;,&quot;    ret[keyFunc.call(/** @type {?} */ (opt_obj), element, index, arr)] =&quot;,&quot;        element;&quot;,&quot;  });&quot;,&quot;  return ret;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a range of numbers in an arithmetic progression.&quot;,&quot; *&quot;,&quot; * Range takes 1, 2, or 3 arguments:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; * range(5) is the same as range(0, 5, 1) and produces [0, 1, 2, 3, 4]&quot;,&quot; * range(2, 5) is the same as range(2, 5, 1) and produces [2, 3, 4]&quot;,&quot; * range(-2, -5, -1) produces [-2, -3, -4]&quot;,&quot; * range(-2, -5, 1) produces [], since stepping by 1 wouldn&#39;t ever reach -5.&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * @param {number} startOrEnd The starting value of the range if an end argument&quot;,&quot; *     is provided. Otherwise, the start value is 0, and this is the end value.&quot;,&quot; * @param {number=} opt_end The optional end value of the range.&quot;,&quot; * @param {number=} opt_step The step size between range values. Defaults to 1&quot;,&quot; *     if opt_step is undefined or 0.&quot;,&quot; * @return {!Array&lt;number&gt;} An array of numbers for the requested range. May be&quot;,&quot; *     an empty array if adding the step would not converge toward the end&quot;,&quot; *     value.&quot;,&quot; */&quot;,&quot;goog.array.range = function(startOrEnd, opt_end, opt_step) {&quot;,&quot;  var array = [];&quot;,&quot;  var start = 0;&quot;,&quot;  var end = startOrEnd;&quot;,&quot;  var step = opt_step || 1;&quot;,&quot;  if (opt_end !== undefined) {&quot;,&quot;    start = startOrEnd;&quot;,&quot;    end = opt_end;&quot;,&quot;  }&quot;,null,&quot;  if (step * (end - start) &lt; 0) {&quot;,&quot;    // Sign mismatch: start + step will never reach the end value.&quot;,&quot;    return [];&quot;,&quot;  }&quot;,null,&quot;  if (step &gt; 0) {&quot;,&quot;    for (var i = start; i &lt; end; i += step) {&quot;,&quot;      array.push(i);&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    for (var i = start; i &gt; end; i += step) {&quot;,&quot;      array.push(i);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return array;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns an array consisting of the given value repeated N times.&quot;,&quot; *&quot;,&quot; * @param {VALUE} value The value to repeat.&quot;,&quot; * @param {number} n The repeat count.&quot;,&quot; * @return {!Array&lt;VALUE&gt;} An array with the repeated value.&quot;,&quot; * @template VALUE&quot;,&quot; */&quot;,&quot;goog.array.repeat = function(value, n) {&quot;,&quot;  var array = [];&quot;,&quot;  for (var i = 0; i &lt; n; i++) {&quot;,&quot;    array[i] = value;&quot;,&quot;  }&quot;,&quot;  return array;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns an array consisting of every argument with all arrays&quot;,&quot; * expanded in-place recursively.&quot;,&quot; *&quot;,&quot; * @param {...*} var_args The values to flatten.&quot;,&quot; * @return {!Array&lt;?&gt;} An array containing the flattened values.&quot;,&quot; */&quot;,&quot;goog.array.flatten = function(var_args) {&quot;,&quot;  var CHUNK_SIZE = 8192;&quot;,null,&quot;  var result = [];&quot;,&quot;  for (var i = 0; i &lt; arguments.length; i++) {&quot;,&quot;    var element = arguments[i];&quot;,&quot;    if (goog.isArray(element)) {&quot;,&quot;      for (var c = 0; c &lt; element.length; c += CHUNK_SIZE) {&quot;,&quot;        var chunk = goog.array.slice(element, c, c + CHUNK_SIZE);&quot;,&quot;        var recurseResult = goog.array.flatten.apply(null, chunk);&quot;,&quot;        for (var r = 0; r &lt; recurseResult.length; r++) {&quot;,&quot;          result.push(recurseResult[r]);&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    } else {&quot;,&quot;      result.push(element);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Rotates an array in-place. After calling this method, the element at&quot;,&quot; * index i will be the element previously at index (i - n) %&quot;,&quot; * array.length, for all values of i between 0 and array.length - 1,&quot;,&quot; * inclusive.&quot;,&quot; *&quot;,&quot; * For example, suppose list comprises [t, a, n, k, s]. After invoking&quot;,&quot; * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n, k].&quot;,&quot; *&quot;,&quot; * @param {!Array&lt;T&gt;} array The array to rotate.&quot;,&quot; * @param {number} n The amount to rotate.&quot;,&quot; * @return {!Array&lt;T&gt;} The array.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.rotate = function(array, n) {&quot;,&quot;  goog.asserts.assert(array.length != null);&quot;,null,&quot;  if (array.length) {&quot;,&quot;    n %= array.length;&quot;,&quot;    if (n &gt; 0) {&quot;,&quot;      Array.prototype.unshift.apply(array, array.splice(-n, n));&quot;,&quot;    } else if (n &lt; 0) {&quot;,&quot;      Array.prototype.push.apply(array, array.splice(0, -n));&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return array;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Moves one item of an array to a new position keeping the order of the rest&quot;,&quot; * of the items. Example use case: keeping a list of JavaScript objects&quot;,&quot; * synchronized with the corresponding list of DOM elements after one of the&quot;,&quot; * elements has been dragged to a new position.&quot;,&quot; * @param {!IArrayLike&lt;?&gt;} arr The array to modify.&quot;,&quot; * @param {number} fromIndex Index of the item to move between 0 and&quot;,&quot; *     {@code arr.length - 1}.&quot;,&quot; * @param {number} toIndex Target index between 0 and {@code arr.length - 1}.&quot;,&quot; */&quot;,&quot;goog.array.moveItem = function(arr, fromIndex, toIndex) {&quot;,&quot;  goog.asserts.assert(fromIndex &gt;= 0 &amp;&amp; fromIndex &lt; arr.length);&quot;,&quot;  goog.asserts.assert(toIndex &gt;= 0 &amp;&amp; toIndex &lt; arr.length);&quot;,&quot;  // Remove 1 item at fromIndex.&quot;,&quot;  var removedItems = Array.prototype.splice.call(arr, fromIndex, 1);&quot;,&quot;  // Insert the removed item at toIndex.&quot;,&quot;  Array.prototype.splice.call(arr, toIndex, 0, removedItems[0]);&quot;,&quot;  // We don&#39;t use goog.array.insertAt and goog.array.removeAt, because they&#39;re&quot;,&quot;  // significantly slower than splice.&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a new array for which the element at position i is an array of the&quot;,&quot; * ith element of the provided arrays.  The returned array will only be as long&quot;,&quot; * as the shortest array provided; additional values are ignored.  For example,&quot;,&quot; * the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].&quot;,&quot; *&quot;,&quot; * This is similar to the zip() function in Python.  See {@link&quot;,&quot; * http://docs.python.org/library/functions.html#zip}&quot;,&quot; *&quot;,&quot; * @param {...!IArrayLike&lt;?&gt;} var_args Arrays to be combined.&quot;,&quot; * @return {!Array&lt;!Array&lt;?&gt;&gt;} A new array of arrays created from&quot;,&quot; *     provided arrays.&quot;,&quot; */&quot;,&quot;goog.array.zip = function(var_args) {&quot;,&quot;  if (!arguments.length) {&quot;,&quot;    return [];&quot;,&quot;  }&quot;,&quot;  var result = [];&quot;,&quot;  var minLen = arguments[0].length;&quot;,&quot;  for (var i = 1; i &lt; arguments.length; i++) {&quot;,&quot;    if (arguments[i].length &lt; minLen) {&quot;,&quot;      minLen = arguments[i].length;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  for (var i = 0; i &lt; minLen; i++) {&quot;,&quot;    var value = [];&quot;,&quot;    for (var j = 0; j &lt; arguments.length; j++) {&quot;,&quot;      value.push(arguments[j][i]);&quot;,&quot;    }&quot;,&quot;    result.push(value);&quot;,&quot;  }&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Shuffles the values in the specified array using the Fisher-Yates in-place&quot;,&quot; * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()&quot;,&quot; * and so resets the state of that random number generator. Similarly, may reset&quot;,&quot; * the state of the any other specified random number generator.&quot;,&quot; *&quot;,&quot; * Runtime: O(n)&quot;,&quot; *&quot;,&quot; * @param {!Array&lt;?&gt;} arr The array to be shuffled.&quot;,&quot; * @param {function():number=} opt_randFn Optional random function to use for&quot;,&quot; *     shuffling.&quot;,&quot; *     Takes no arguments, and returns a random number on the interval [0, 1).&quot;,&quot; *     Defaults to Math.random() using JavaScript&#39;s built-in Math library.&quot;,&quot; */&quot;,&quot;goog.array.shuffle = function(arr, opt_randFn) {&quot;,&quot;  var randFn = opt_randFn || Math.random;&quot;,null,&quot;  for (var i = arr.length - 1; i &gt; 0; i--) {&quot;,&quot;    // Choose a random array index in [0, i] (inclusive with i).&quot;,&quot;    var j = Math.floor(randFn() * (i + 1));&quot;,null,&quot;    var tmp = arr[i];&quot;,&quot;    arr[i] = arr[j];&quot;,&quot;    arr[j] = tmp;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns a new array of elements from arr, based on the indexes of elements&quot;,&quot; * provided by index_arr. For example, the result of index copying&quot;,&quot; * [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] with index_arr [1,0,0,2] is [&#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;c&#39;].&quot;,&quot; *&quot;,&quot; * @param {!Array&lt;T&gt;} arr The array to get a indexed copy from.&quot;,&quot; * @param {!Array&lt;number&gt;} index_arr An array of indexes to get from arr.&quot;,&quot; * @return {!Array&lt;T&gt;} A new array of elements from arr in index_arr order.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.array.copyByIndex = function(arr, index_arr) {&quot;,&quot;  var result = [];&quot;,&quot;  goog.array.forEach(index_arr, function(index) { result.push(arr[index]); });&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Maps each element of the input array into zero or more elements of the output&quot;,&quot; * array.&quot;,&quot; *&quot;,&quot; * @param {!IArrayLike&lt;VALUE&gt;|string} arr Array or array like object&quot;,&quot; *     over which to iterate.&quot;,&quot; * @param {function(this:THIS, VALUE, number, ?): !Array&lt;RESULT&gt;} f The function&quot;,&quot; *     to call for every element. This function takes 3 arguments (the element,&quot;,&quot; *     the index and the array) and should return an array. The result will be&quot;,&quot; *     used to extend a new array.&quot;,&quot; * @param {THIS=} opt_obj The object to be used as the value of &#39;this&#39; within f.&quot;,&quot; * @return {!Array&lt;RESULT&gt;} a new array with the concatenation of all arrays&quot;,&quot; *     returned from f.&quot;,&quot; * @template THIS, VALUE, RESULT&quot;,&quot; */&quot;,&quot;goog.array.concatMap = function(arr, f, opt_obj) {&quot;,&quot;  return goog.array.concat.apply([], goog.array.map(arr, f, opt_obj));&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>