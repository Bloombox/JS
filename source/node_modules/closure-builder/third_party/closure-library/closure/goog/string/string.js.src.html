<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>string.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;string.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/string/string.js&quot;,[&quot;// Copyright 2006 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Utilities for string manipulation.&quot;,&quot; * @author arv@google.com (Erik Arvidsson)&quot;,&quot; */&quot;,null,null,&quot;/**&quot;,&quot; * Namespace for string utilities&quot;,&quot; */&quot;,&quot;goog.provide(&#39;goog.string&#39;);&quot;,&quot;goog.provide(&#39;goog.string.Unicode&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Enables HTML escaping of lowercase letter \&quot;e\&quot; which helps&quot;,&quot; * with detection of double-escaping as this letter is frequently used.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.string.DETECT_DOUBLE_ESCAPING&#39;, false);&quot;,null,null,&quot;/**&quot;,&quot; * @define {boolean} Whether to force non-dom html unescaping.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.string.FORCE_NON_DOM_HTML_UNESCAPING&#39;, false);&quot;,null,null,&quot;/**&quot;,&quot; * Common Unicode string characters.&quot;,&quot; * @enum {string}&quot;,&quot; */&quot;,&quot;goog.string.Unicode = {&quot;,&quot;  NBSP: &#39;\\xa0&#39;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Fast prefix-checker.&quot;,&quot; * @param {string} str The string to check.&quot;,&quot; * @param {string} prefix A string to look for at the start of {@code str}.&quot;,&quot; * @return {boolean} True if {@code str} begins with {@code prefix}.&quot;,&quot; */&quot;,&quot;goog.string.startsWith = function(str, prefix) {&quot;,&quot;  return str.lastIndexOf(prefix, 0) == 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Fast suffix-checker.&quot;,&quot; * @param {string} str The string to check.&quot;,&quot; * @param {string} suffix A string to look for at the end of {@code str}.&quot;,&quot; * @return {boolean} True if {@code str} ends with {@code suffix}.&quot;,&quot; */&quot;,&quot;goog.string.endsWith = function(str, suffix) {&quot;,&quot;  var l = str.length - suffix.length;&quot;,&quot;  return l &gt;= 0 &amp;&amp; str.indexOf(suffix, l) == l;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Case-insensitive prefix-checker.&quot;,&quot; * @param {string} str The string to check.&quot;,&quot; * @param {string} prefix  A string to look for at the end of {@code str}.&quot;,&quot; * @return {boolean} True if {@code str} begins with {@code prefix} (ignoring&quot;,&quot; *     case).&quot;,&quot; */&quot;,&quot;goog.string.caseInsensitiveStartsWith = function(str, prefix) {&quot;,&quot;  return goog.string.caseInsensitiveCompare(&quot;,&quot;             prefix, str.substr(0, prefix.length)) == 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Case-insensitive suffix-checker.&quot;,&quot; * @param {string} str The string to check.&quot;,&quot; * @param {string} suffix A string to look for at the end of {@code str}.&quot;,&quot; * @return {boolean} True if {@code str} ends with {@code suffix} (ignoring&quot;,&quot; *     case).&quot;,&quot; */&quot;,&quot;goog.string.caseInsensitiveEndsWith = function(str, suffix) {&quot;,&quot;  return (&quot;,&quot;      goog.string.caseInsensitiveCompare(&quot;,&quot;          suffix, str.substr(str.length - suffix.length, suffix.length)) == 0);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Case-insensitive equality checker.&quot;,&quot; * @param {string} str1 First string to check.&quot;,&quot; * @param {string} str2 Second string to check.&quot;,&quot; * @return {boolean} True if {@code str1} and {@code str2} are the same string,&quot;,&quot; *     ignoring case.&quot;,&quot; */&quot;,&quot;goog.string.caseInsensitiveEquals = function(str1, str2) {&quot;,&quot;  return str1.toLowerCase() == str2.toLowerCase();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Does simple python-style string substitution.&quot;,&quot; * subs(\&quot;foo%s hot%s\&quot;, \&quot;bar\&quot;, \&quot;dog\&quot;) becomes \&quot;foobar hotdog\&quot;.&quot;,&quot; * @param {string} str The string containing the pattern.&quot;,&quot; * @param {...*} var_args The items to substitute into the pattern.&quot;,&quot; * @return {string} A copy of {@code str} in which each occurrence of&quot;,&quot; *     {@code %s} has been replaced an argument from {@code var_args}.&quot;,&quot; */&quot;,&quot;goog.string.subs = function(str, var_args) {&quot;,&quot;  var splitParts = str.split(&#39;%s&#39;);&quot;,&quot;  var returnString = &#39;&#39;;&quot;,null,&quot;  var subsArguments = Array.prototype.slice.call(arguments, 1);&quot;,&quot;  while (subsArguments.length &amp;&amp;&quot;,&quot;         // Replace up to the last split part. We are inserting in the&quot;,&quot;         // positions between split parts.&quot;,&quot;         splitParts.length &gt; 1) {&quot;,&quot;    returnString += splitParts.shift() + subsArguments.shift();&quot;,&quot;  }&quot;,null,&quot;  return returnString + splitParts.join(&#39;%s&#39;);  // Join unused &#39;%s&#39;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines&quot;,&quot; * and tabs) to a single space, and strips leading and trailing whitespace.&quot;,&quot; * @param {string} str Input string.&quot;,&quot; * @return {string} A copy of {@code str} with collapsed whitespace.&quot;,&quot; */&quot;,&quot;goog.string.collapseWhitespace = function(str) {&quot;,&quot;  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \\s character&quot;,&quot;  // class (as required by section 7.2 of the ECMAScript spec), we explicitly&quot;,&quot;  // include it in the regexp to enforce consistent cross-browser behavior.&quot;,&quot;  return str.replace(/[\\s\\xa0]+/g, &#39; &#39;).replace(/^\\s+|\\s+$/g, &#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Checks if a string is empty or contains only whitespaces.&quot;,&quot; * @param {string} str The string to check.&quot;,&quot; * @return {boolean} Whether {@code str} is empty or whitespace only.&quot;,&quot; */&quot;,&quot;goog.string.isEmptyOrWhitespace = function(str) {&quot;,&quot;  // testing length == 0 first is actually slower in all browsers (about the&quot;,&quot;  // same in Opera).&quot;,&quot;  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \\s character&quot;,&quot;  // class (as required by section 7.2 of the ECMAScript spec), we explicitly&quot;,&quot;  // include it in the regexp to enforce consistent cross-browser behavior.&quot;,&quot;  return /^[\\s\\xa0]*$/.test(str);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Checks if a string is empty.&quot;,&quot; * @param {string} str The string to check.&quot;,&quot; * @return {boolean} Whether {@code str} is empty.&quot;,&quot; */&quot;,&quot;goog.string.isEmptyString = function(str) {&quot;,&quot;  return str.length == 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Checks if a string is empty or contains only whitespaces.&quot;,&quot; *&quot;,&quot; * @param {string} str The string to check.&quot;,&quot; * @return {boolean} Whether {@code str} is empty or whitespace only.&quot;,&quot; * @deprecated Use goog.string.isEmptyOrWhitespace instead.&quot;,&quot; */&quot;,&quot;goog.string.isEmpty = goog.string.isEmptyOrWhitespace;&quot;,null,null,&quot;/**&quot;,&quot; * Checks if a string is null, undefined, empty or contains only whitespaces.&quot;,&quot; * @param {*} str The string to check.&quot;,&quot; * @return {boolean} Whether {@code str} is null, undefined, empty, or&quot;,&quot; *     whitespace only.&quot;,&quot; * @deprecated Use goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str))&quot;,&quot; *     instead.&quot;,&quot; */&quot;,&quot;goog.string.isEmptyOrWhitespaceSafe = function(str) {&quot;,&quot;  return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Checks if a string is null, undefined, empty or contains only whitespaces.&quot;,&quot; *&quot;,&quot; * @param {*} str The string to check.&quot;,&quot; * @return {boolean} Whether {@code str} is null, undefined, empty, or&quot;,&quot; *     whitespace only.&quot;,&quot; * @deprecated Use goog.string.isEmptyOrWhitespace instead.&quot;,&quot; */&quot;,&quot;goog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;&quot;,null,null,&quot;/**&quot;,&quot; * Checks if a string is all breaking whitespace.&quot;,&quot; * @param {string} str The string to check.&quot;,&quot; * @return {boolean} Whether the string is all breaking whitespace.&quot;,&quot; */&quot;,&quot;goog.string.isBreakingWhitespace = function(str) {&quot;,&quot;  return !/[^\\t\\n\\r ]/.test(str);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Checks if a string contains all letters.&quot;,&quot; * @param {string} str string to check.&quot;,&quot; * @return {boolean} True if {@code str} consists entirely of letters.&quot;,&quot; */&quot;,&quot;goog.string.isAlpha = function(str) {&quot;,&quot;  return !/[^a-zA-Z]/.test(str);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Checks if a string contains only numbers.&quot;,&quot; * @param {*} str string to check. If not a string, it will be&quot;,&quot; *     casted to one.&quot;,&quot; * @return {boolean} True if {@code str} is numeric.&quot;,&quot; */&quot;,&quot;goog.string.isNumeric = function(str) {&quot;,&quot;  return !/[^0-9]/.test(str);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Checks if a string contains only numbers or letters.&quot;,&quot; * @param {string} str string to check.&quot;,&quot; * @return {boolean} True if {@code str} is alphanumeric.&quot;,&quot; */&quot;,&quot;goog.string.isAlphaNumeric = function(str) {&quot;,&quot;  return !/[^a-zA-Z0-9]/.test(str);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Checks if a character is a space character.&quot;,&quot; * @param {string} ch Character to check.&quot;,&quot; * @return {boolean} True if {@code ch} is a space.&quot;,&quot; */&quot;,&quot;goog.string.isSpace = function(ch) {&quot;,&quot;  return ch == &#39; &#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Checks if a character is a valid unicode character.&quot;,&quot; * @param {string} ch Character to check.&quot;,&quot; * @return {boolean} True if {@code ch} is a valid unicode character.&quot;,&quot; */&quot;,&quot;goog.string.isUnicodeChar = function(ch) {&quot;,&quot;  return ch.length == 1 &amp;&amp; ch &gt;= &#39; &#39; &amp;&amp; ch &lt;= &#39;~&#39; ||&quot;,&quot;      ch &gt;= &#39;\\u0080&#39; &amp;&amp; ch &lt;= &#39;\\uFFFD&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Takes a string and replaces newlines with a space. Multiple lines are&quot;,&quot; * replaced with a single space.&quot;,&quot; * @param {string} str The string from which to strip newlines.&quot;,&quot; * @return {string} A copy of {@code str} stripped of newlines.&quot;,&quot; */&quot;,&quot;goog.string.stripNewlines = function(str) {&quot;,&quot;  return str.replace(/(\\r\\n|\\r|\\n)+/g, &#39; &#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Replaces Windows and Mac new lines with unix style: \\r or \\r\\n with \\n.&quot;,&quot; * @param {string} str The string to in which to canonicalize newlines.&quot;,&quot; * @return {string} {@code str} A copy of {@code} with canonicalized newlines.&quot;,&quot; */&quot;,&quot;goog.string.canonicalizeNewlines = function(str) {&quot;,&quot;  return str.replace(/(\\r\\n|\\r|\\n)/g, &#39;\\n&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Normalizes whitespace in a string, replacing all whitespace chars with&quot;,&quot; * a space.&quot;,&quot; * @param {string} str The string in which to normalize whitespace.&quot;,&quot; * @return {string} A copy of {@code str} with all whitespace normalized.&quot;,&quot; */&quot;,&quot;goog.string.normalizeWhitespace = function(str) {&quot;,&quot;  return str.replace(/\\xa0|\\s/g, &#39; &#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Normalizes spaces in a string, replacing all consecutive spaces and tabs&quot;,&quot; * with a single space. Replaces non-breaking space with a space.&quot;,&quot; * @param {string} str The string in which to normalize spaces.&quot;,&quot; * @return {string} A copy of {@code str} with all consecutive spaces and tabs&quot;,&quot; *    replaced with a single space.&quot;,&quot; */&quot;,&quot;goog.string.normalizeSpaces = function(str) {&quot;,&quot;  return str.replace(/\\xa0|[ \\t]+/g, &#39; &#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes the breaking spaces from the left and right of the string and&quot;,&quot; * collapses the sequences of breaking spaces in the middle into single spaces.&quot;,&quot; * The original and the result strings render the same way in HTML.&quot;,&quot; * @param {string} str A string in which to collapse spaces.&quot;,&quot; * @return {string} Copy of the string with normalized breaking spaces.&quot;,&quot; */&quot;,&quot;goog.string.collapseBreakingSpaces = function(str) {&quot;,&quot;  return str.replace(/[\\t\\r\\n ]+/g, &#39; &#39;)&quot;,&quot;      .replace(/^[\\t\\r\\n ]+|[\\t\\r\\n ]+$/g, &#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Trims white spaces to the left and right of a string.&quot;,&quot; * @param {string} str The string to trim.&quot;,&quot; * @return {string} A trimmed copy of {@code str}.&quot;,&quot; */&quot;,&quot;goog.string.trim =&quot;,&quot;    (goog.TRUSTED_SITE &amp;&amp; String.prototype.trim) ? function(str) {&quot;,&quot;      return str.trim();&quot;,&quot;    } : function(str) {&quot;,&quot;      // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \\s&quot;,&quot;      // character class (as required by section 7.2 of the ECMAScript spec),&quot;,&quot;      // we explicitly include it in the regexp to enforce consistent&quot;,&quot;      // cross-browser behavior.&quot;,&quot;      return str.replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, &#39;&#39;);&quot;,&quot;    };&quot;,null,null,&quot;/**&quot;,&quot; * Trims whitespaces at the left end of a string.&quot;,&quot; * @param {string} str The string to left trim.&quot;,&quot; * @return {string} A trimmed copy of {@code str}.&quot;,&quot; */&quot;,&quot;goog.string.trimLeft = function(str) {&quot;,&quot;  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \\s character&quot;,&quot;  // class (as required by section 7.2 of the ECMAScript spec), we explicitly&quot;,&quot;  // include it in the regexp to enforce consistent cross-browser behavior.&quot;,&quot;  return str.replace(/^[\\s\\xa0]+/, &#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Trims whitespaces at the right end of a string.&quot;,&quot; * @param {string} str The string to right trim.&quot;,&quot; * @return {string} A trimmed copy of {@code str}.&quot;,&quot; */&quot;,&quot;goog.string.trimRight = function(str) {&quot;,&quot;  // Since IE doesn&#39;t include non-breaking-space (0xa0) in their \\s character&quot;,&quot;  // class (as required by section 7.2 of the ECMAScript spec), we explicitly&quot;,&quot;  // include it in the regexp to enforce consistent cross-browser behavior.&quot;,&quot;  return str.replace(/[\\s\\xa0]+$/, &#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * A string comparator that ignores case.&quot;,&quot; * -1 = str1 less than str2&quot;,&quot; *  0 = str1 equals str2&quot;,&quot; *  1 = str1 greater than str2&quot;,&quot; *&quot;,&quot; * @param {string} str1 The string to compare.&quot;,&quot; * @param {string} str2 The string to compare {@code str1} to.&quot;,&quot; * @return {number} The comparator result, as described above.&quot;,&quot; */&quot;,&quot;goog.string.caseInsensitiveCompare = function(str1, str2) {&quot;,&quot;  var test1 = String(str1).toLowerCase();&quot;,&quot;  var test2 = String(str2).toLowerCase();&quot;,null,&quot;  if (test1 &lt; test2) {&quot;,&quot;    return -1;&quot;,&quot;  } else if (test1 == test2) {&quot;,&quot;    return 0;&quot;,&quot;  } else {&quot;,&quot;    return 1;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Compares two strings interpreting their numeric substrings as numbers.&quot;,&quot; *&quot;,&quot; * @param {string} str1 First string.&quot;,&quot; * @param {string} str2 Second string.&quot;,&quot; * @param {!RegExp} tokenizerRegExp Splits a string into substrings of&quot;,&quot; *     non-negative integers, non-numeric characters and optionally fractional&quot;,&quot; *     numbers starting with a decimal point.&quot;,&quot; * @return {number} Negative if str1 &lt; str2, 0 is str1 == str2, positive if&quot;,&quot; *     str1 &gt; str2.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.string.numberAwareCompare_ = function(str1, str2, tokenizerRegExp) {&quot;,&quot;  if (str1 == str2) {&quot;,&quot;    return 0;&quot;,&quot;  }&quot;,&quot;  if (!str1) {&quot;,&quot;    return -1;&quot;,&quot;  }&quot;,&quot;  if (!str2) {&quot;,&quot;    return 1;&quot;,&quot;  }&quot;,null,&quot;  // Using match to split the entire string ahead of time turns out to be faster&quot;,&quot;  // for most inputs than using RegExp.exec or iterating over each character.&quot;,&quot;  var tokens1 = str1.toLowerCase().match(tokenizerRegExp);&quot;,&quot;  var tokens2 = str2.toLowerCase().match(tokenizerRegExp);&quot;,null,&quot;  var count = Math.min(tokens1.length, tokens2.length);&quot;,null,&quot;  for (var i = 0; i &lt; count; i++) {&quot;,&quot;    var a = tokens1[i];&quot;,&quot;    var b = tokens2[i];&quot;,null,&quot;    // Compare pairs of tokens, returning if one token sorts before the other.&quot;,&quot;    if (a != b) {&quot;,&quot;      // Only if both tokens are integers is a special comparison required.&quot;,&quot;      // Decimal numbers are sorted as strings (e.g., &#39;.09&#39; &lt; &#39;.1&#39;).&quot;,&quot;      var num1 = parseInt(a, 10);&quot;,&quot;      if (!isNaN(num1)) {&quot;,&quot;        var num2 = parseInt(b, 10);&quot;,&quot;        if (!isNaN(num2) &amp;&amp; num1 - num2) {&quot;,&quot;          return num1 - num2;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;      return a &lt; b ? -1 : 1;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // If one string is a substring of the other, the shorter string sorts first.&quot;,&quot;  if (tokens1.length != tokens2.length) {&quot;,&quot;    return tokens1.length - tokens2.length;&quot;,&quot;  }&quot;,null,&quot;  // The two strings must be equivalent except for case (perfect equality is&quot;,&quot;  // tested at the head of the function.) Revert to default ASCII string&quot;,&quot;  // comparison to stabilize the sort.&quot;,&quot;  return str1 &lt; str2 ? -1 : 1;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * String comparison function that handles non-negative integer numbers in a&quot;,&quot; * way humans might expect. Using this function, the string &#39;File 2.jpg&#39; sorts&quot;,&quot; * before &#39;File 10.jpg&#39;, and &#39;Version 1.9&#39; before &#39;Version 1.10&#39;. The comparison&quot;,&quot; * is mostly case-insensitive, though strings that are identical except for case&quot;,&quot; * are sorted with the upper-case strings before lower-case.&quot;,&quot; *&quot;,&quot; * This comparison function is up to 50x slower than either the default or the&quot;,&quot; * case-insensitive compare. It should not be used in time-critical code, but&quot;,&quot; * should be fast enough to sort several hundred short strings (like filenames)&quot;,&quot; * with a reasonable delay.&quot;,&quot; *&quot;,&quot; * @param {string} str1 The string to compare in a numerically sensitive way.&quot;,&quot; * @param {string} str2 The string to compare {@code str1} to.&quot;,&quot; * @return {number} less than 0 if str1 &lt; str2, 0 if str1 == str2, greater than&quot;,&quot; *     0 if str1 &gt; str2.&quot;,&quot; */&quot;,&quot;goog.string.intAwareCompare = function(str1, str2) {&quot;,&quot;  return goog.string.numberAwareCompare_(str1, str2, /\\d+|\\D+/g);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * String comparison function that handles non-negative integer and fractional&quot;,&quot; * numbers in a way humans might expect. Using this function, the string&quot;,&quot; * &#39;File 2.jpg&#39; sorts before &#39;File 10.jpg&#39;, and &#39;3.14&#39; before &#39;3.2&#39;. Equivalent&quot;,&quot; * to {@link goog.string.intAwareCompare} apart from the way how it interprets&quot;,&quot; * dots.&quot;,&quot; *&quot;,&quot; * @param {string} str1 The string to compare in a numerically sensitive way.&quot;,&quot; * @param {string} str2 The string to compare {@code str1} to.&quot;,&quot; * @return {number} less than 0 if str1 &lt; str2, 0 if str1 == str2, greater than&quot;,&quot; *     0 if str1 &gt; str2.&quot;,&quot; */&quot;,&quot;goog.string.floatAwareCompare = function(str1, str2) {&quot;,&quot;  return goog.string.numberAwareCompare_(str1, str2, /\\d+|\\.\\d+|\\D+/g);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Alias for {@link goog.string.floatAwareCompare}.&quot;,&quot; *&quot;,&quot; * @param {string} str1&quot;,&quot; * @param {string} str2&quot;,&quot; * @return {number}&quot;,&quot; */&quot;,&quot;goog.string.numerateCompare = goog.string.floatAwareCompare;&quot;,null,null,&quot;/**&quot;,&quot; * URL-encodes a string&quot;,&quot; * @param {*} str The string to url-encode.&quot;,&quot; * @return {string} An encoded copy of {@code str} that is safe for urls.&quot;,&quot; *     Note that &#39;#&#39;, &#39;:&#39;, and other characters used to delimit portions&quot;,&quot; *     of URLs *will* be encoded.&quot;,&quot; */&quot;,&quot;goog.string.urlEncode = function(str) {&quot;,&quot;  return encodeURIComponent(String(str));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * URL-decodes the string. We need to specially handle &#39;+&#39;s because&quot;,&quot; * the javascript library doesn&#39;t convert them to spaces.&quot;,&quot; * @param {string} str The string to url decode.&quot;,&quot; * @return {string} The decoded {@code str}.&quot;,&quot; */&quot;,&quot;goog.string.urlDecode = function(str) {&quot;,&quot;  return decodeURIComponent(str.replace(/\\+/g, &#39; &#39;));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts \\n to &lt;br&gt;s or &lt;br /&gt;s.&quot;,&quot; * @param {string} str The string in which to convert newlines.&quot;,&quot; * @param {boolean=} opt_xml Whether to use XML compatible tags.&quot;,&quot; * @return {string} A copy of {@code str} with converted newlines.&quot;,&quot; */&quot;,&quot;goog.string.newLineToBr = function(str, opt_xml) {&quot;,&quot;  return str.replace(/(\\r\\n|\\r|\\n)/g, opt_xml ? &#39;&lt;br /&gt;&#39; : &#39;&lt;br&gt;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Escapes double quote &#39;\&quot;&#39; and single quote &#39;\\&#39;&#39; characters in addition to&quot;,&quot; * &#39;&amp;&#39;, &#39;&lt;&#39;, and &#39;&gt;&#39; so that a string can be included in an HTML tag attribute&quot;,&quot; * value within double or single quotes.&quot;,&quot; *&quot;,&quot; * It should be noted that &gt; doesn&#39;t need to be escaped for the HTML or XML to&quot;,&quot; * be valid, but it has been decided to escape it for consistency with other&quot;,&quot; * implementations.&quot;,&quot; *&quot;,&quot; * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the&quot;,&quot; * lowercase letter \&quot;e\&quot;.&quot;,&quot; *&quot;,&quot; * NOTE(user):&quot;,&quot; * HtmlEscape is often called during the generation of large blocks of HTML.&quot;,&quot; * Using statics for the regular expressions and strings is an optimization&quot;,&quot; * that can more than half the amount of time IE spends in this function for&quot;,&quot; * large apps, since strings and regexes both contribute to GC allocations.&quot;,&quot; *&quot;,&quot; * Testing for the presence of a character before escaping increases the number&quot;,&quot; * of function calls, but actually provides a speed increase for the average&quot;,&quot; * case -- since the average case often doesn&#39;t require the escaping of all 4&quot;,&quot; * characters and indexOf() is much cheaper than replace().&quot;,&quot; * The worst case does suffer slightly from the additional calls, therefore the&quot;,&quot; * opt_isLikelyToContainHtmlChars option has been included for situations&quot;,&quot; * where all 4 HTML entities are very likely to be present and need escaping.&quot;,&quot; *&quot;,&quot; * Some benchmarks (times tended to fluctuate +-0.05ms):&quot;,&quot; *                                     FireFox                     IE6&quot;,&quot; * (no chars / average (mix of cases) / all 4 chars)&quot;,&quot; * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80&quot;,&quot; * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84&quot;,&quot; * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85&quot;,&quot; *&quot;,&quot; * An additional advantage of checking if replace actually needs to be called&quot;,&quot; * is a reduction in the number of object allocations, so as the size of the&quot;,&quot; * application grows the difference between the various methods would increase.&quot;,&quot; *&quot;,&quot; * @param {string} str string to be escaped.&quot;,&quot; * @param {boolean=} opt_isLikelyToContainHtmlChars Don&#39;t perform a check to see&quot;,&quot; *     if the character needs replacing - use this option if you expect each of&quot;,&quot; *     the characters to appear often. Leave false if you expect few html&quot;,&quot; *     characters to occur in your strings, such as if you are escaping HTML.&quot;,&quot; * @return {string} An escaped copy of {@code str}.&quot;,&quot; */&quot;,&quot;goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {&quot;,null,&quot;  if (opt_isLikelyToContainHtmlChars) {&quot;,&quot;    str = str.replace(goog.string.AMP_RE_, &#39;&amp;amp;&#39;)&quot;,&quot;              .replace(goog.string.LT_RE_, &#39;&amp;lt;&#39;)&quot;,&quot;              .replace(goog.string.GT_RE_, &#39;&amp;gt;&#39;)&quot;,&quot;              .replace(goog.string.QUOT_RE_, &#39;&amp;quot;&#39;)&quot;,&quot;              .replace(goog.string.SINGLE_QUOTE_RE_, &#39;&amp;#39;&#39;)&quot;,&quot;              .replace(goog.string.NULL_RE_, &#39;&amp;#0;&#39;);&quot;,&quot;    if (goog.string.DETECT_DOUBLE_ESCAPING) {&quot;,&quot;      str = str.replace(goog.string.E_RE_, &#39;&amp;#101;&#39;);&quot;,&quot;    }&quot;,&quot;    return str;&quot;,null,&quot;  } else {&quot;,&quot;    // quick test helps in the case when there are no chars to replace, in&quot;,&quot;    // worst case this makes barely a difference to the time taken&quot;,&quot;    if (!goog.string.ALL_RE_.test(str)) return str;&quot;,null,&quot;    // str.indexOf is faster than regex.test in this case&quot;,&quot;    if (str.indexOf(&#39;&amp;&#39;) != -1) {&quot;,&quot;      str = str.replace(goog.string.AMP_RE_, &#39;&amp;amp;&#39;);&quot;,&quot;    }&quot;,&quot;    if (str.indexOf(&#39;&lt;&#39;) != -1) {&quot;,&quot;      str = str.replace(goog.string.LT_RE_, &#39;&amp;lt;&#39;);&quot;,&quot;    }&quot;,&quot;    if (str.indexOf(&#39;&gt;&#39;) != -1) {&quot;,&quot;      str = str.replace(goog.string.GT_RE_, &#39;&amp;gt;&#39;);&quot;,&quot;    }&quot;,&quot;    if (str.indexOf(&#39;\&quot;&#39;) != -1) {&quot;,&quot;      str = str.replace(goog.string.QUOT_RE_, &#39;&amp;quot;&#39;);&quot;,&quot;    }&quot;,&quot;    if (str.indexOf(&#39;\\&#39;&#39;) != -1) {&quot;,&quot;      str = str.replace(goog.string.SINGLE_QUOTE_RE_, &#39;&amp;#39;&#39;);&quot;,&quot;    }&quot;,&quot;    if (str.indexOf(&#39;\\x00&#39;) != -1) {&quot;,&quot;      str = str.replace(goog.string.NULL_RE_, &#39;&amp;#0;&#39;);&quot;,&quot;    }&quot;,&quot;    if (goog.string.DETECT_DOUBLE_ESCAPING &amp;&amp; str.indexOf(&#39;e&#39;) != -1) {&quot;,&quot;      str = str.replace(goog.string.E_RE_, &#39;&amp;#101;&#39;);&quot;,&quot;    }&quot;,&quot;    return str;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Regular expression that matches an ampersand, for use in escaping.&quot;,&quot; * @const {!RegExp}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.string.AMP_RE_ = /&amp;/g;&quot;,null,null,&quot;/**&quot;,&quot; * Regular expression that matches a less than sign, for use in escaping.&quot;,&quot; * @const {!RegExp}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.string.LT_RE_ = /&lt;/g;&quot;,null,null,&quot;/**&quot;,&quot; * Regular expression that matches a greater than sign, for use in escaping.&quot;,&quot; * @const {!RegExp}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.string.GT_RE_ = /&gt;/g;&quot;,null,null,&quot;/**&quot;,&quot; * Regular expression that matches a double quote, for use in escaping.&quot;,&quot; * @const {!RegExp}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.string.QUOT_RE_ = /\&quot;/g;&quot;,null,null,&quot;/**&quot;,&quot; * Regular expression that matches a single quote, for use in escaping.&quot;,&quot; * @const {!RegExp}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.string.SINGLE_QUOTE_RE_ = /&#39;/g;&quot;,null,null,&quot;/**&quot;,&quot; * Regular expression that matches null character, for use in escaping.&quot;,&quot; * @const {!RegExp}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.string.NULL_RE_ = /\\x00/g;&quot;,null,null,&quot;/**&quot;,&quot; * Regular expression that matches a lowercase letter \&quot;e\&quot;, for use in escaping.&quot;,&quot; * @const {!RegExp}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.string.E_RE_ = /e/g;&quot;,null,null,&quot;/**&quot;,&quot; * Regular expression that matches any character that needs to be escaped.&quot;,&quot; * @const {!RegExp}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.string.ALL_RE_ =&quot;,&quot;    (goog.string.DETECT_DOUBLE_ESCAPING ? /[\\x00&amp;&lt;&gt;\&quot;&#39;e]/ : /[\\x00&amp;&lt;&gt;\&quot;&#39;]/);&quot;,null,null,&quot;/**&quot;,&quot; * Unescapes an HTML string.&quot;,&quot; *&quot;,&quot; * @param {string} str The string to unescape.&quot;,&quot; * @return {string} An unescaped copy of {@code str}.&quot;,&quot; */&quot;,&quot;goog.string.unescapeEntities = function(str) {&quot;,&quot;  if (goog.string.contains(str, &#39;&amp;&#39;)) {&quot;,&quot;    // We are careful not to use a DOM if we do not have one or we explicitly&quot;,&quot;    // requested non-DOM html unescaping.&quot;,&quot;    if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING &amp;&amp;&quot;,&quot;        &#39;document&#39; in goog.global) {&quot;,&quot;      return goog.string.unescapeEntitiesUsingDom_(str);&quot;,&quot;    } else {&quot;,&quot;      // Fall back on pure XML entities&quot;,&quot;      return goog.string.unescapePureXmlEntities_(str);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return str;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Unescapes a HTML string using the provided document.&quot;,&quot; *&quot;,&quot; * @param {string} str The string to unescape.&quot;,&quot; * @param {!Document} document A document to use in escaping the string.&quot;,&quot; * @return {string} An unescaped copy of {@code str}.&quot;,&quot; */&quot;,&quot;goog.string.unescapeEntitiesWithDocument = function(str, document) {&quot;,&quot;  if (goog.string.contains(str, &#39;&amp;&#39;)) {&quot;,&quot;    return goog.string.unescapeEntitiesUsingDom_(str, document);&quot;,&quot;  }&quot;,&quot;  return str;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric&quot;,&quot; * entities. This function is XSS-safe and whitespace-preserving.&quot;,&quot; * @private&quot;,&quot; * @param {string} str The string to unescape.&quot;,&quot; * @param {Document=} opt_document An optional document to use for creating&quot;,&quot; *     elements. If this is not specified then the default window.document&quot;,&quot; *     will be used.&quot;,&quot; * @return {string} The unescaped {@code str} string.&quot;,&quot; */&quot;,&quot;goog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {&quot;,&quot;  /** @type {!Object&lt;string, string&gt;} */&quot;,&quot;  var seen = {&#39;&amp;amp;&#39;: &#39;&amp;&#39;, &#39;&amp;lt;&#39;: &#39;&lt;&#39;, &#39;&amp;gt;&#39;: &#39;&gt;&#39;, &#39;&amp;quot;&#39;: &#39;\&quot;&#39;};&quot;,&quot;  var div;&quot;,&quot;  if (opt_document) {&quot;,&quot;    div = opt_document.createElement(&#39;div&#39;);&quot;,&quot;  } else {&quot;,&quot;    div = goog.global.document.createElement(&#39;div&#39;);&quot;,&quot;  }&quot;,&quot;  // Match as many valid entity characters as possible. If the actual entity&quot;,&quot;  // happens to be shorter, it will still work as innerHTML will return the&quot;,&quot;  // trailing characters unchanged. Since the entity characters do not include&quot;,&quot;  // open angle bracket, there is no chance of XSS from the innerHTML use.&quot;,&quot;  // Since no whitespace is passed to innerHTML, whitespace is preserved.&quot;,&quot;  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {&quot;,&quot;    // Check for cached entity.&quot;,&quot;    var value = seen[s];&quot;,&quot;    if (value) {&quot;,&quot;      return value;&quot;,&quot;    }&quot;,&quot;    // Check for numeric entity.&quot;,&quot;    if (entity.charAt(0) == &#39;#&#39;) {&quot;,&quot;      // Prefix with 0 so that hex entities (e.g. &amp;#x10) parse as hex numbers.&quot;,&quot;      var n = Number(&#39;0&#39; + entity.substr(1));&quot;,&quot;      if (!isNaN(n)) {&quot;,&quot;        value = String.fromCharCode(n);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    // Fall back to innerHTML otherwise.&quot;,&quot;    if (!value) {&quot;,&quot;      // Append a non-entity character to avoid a bug in Webkit that parses&quot;,&quot;      // an invalid entity at the end of innerHTML text as the empty string.&quot;,&quot;      div.innerHTML = s + &#39; &#39;;&quot;,&quot;      // Then remove the trailing character from the result.&quot;,&quot;      value = div.firstChild.nodeValue.slice(0, -1);&quot;,&quot;    }&quot;,&quot;    // Cache and return.&quot;,&quot;    return seen[s] = value;&quot;,&quot;  });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Unescapes XML entities.&quot;,&quot; * @private&quot;,&quot; * @param {string} str The string to unescape.&quot;,&quot; * @return {string} An unescaped copy of {@code str}.&quot;,&quot; */&quot;,&quot;goog.string.unescapePureXmlEntities_ = function(str) {&quot;,&quot;  return str.replace(/&amp;([^;]+);/g, function(s, entity) {&quot;,&quot;    switch (entity) {&quot;,&quot;      case &#39;amp&#39;:&quot;,&quot;        return &#39;&amp;&#39;;&quot;,&quot;      case &#39;lt&#39;:&quot;,&quot;        return &#39;&lt;&#39;;&quot;,&quot;      case &#39;gt&#39;:&quot;,&quot;        return &#39;&gt;&#39;;&quot;,&quot;      case &#39;quot&#39;:&quot;,&quot;        return &#39;\&quot;&#39;;&quot;,&quot;      default:&quot;,&quot;        if (entity.charAt(0) == &#39;#&#39;) {&quot;,&quot;          // Prefix with 0 so that hex entities (e.g. &amp;#x10) parse as hex.&quot;,&quot;          var n = Number(&#39;0&#39; + entity.substr(1));&quot;,&quot;          if (!isNaN(n)) {&quot;,&quot;            return String.fromCharCode(n);&quot;,&quot;          }&quot;,&quot;        }&quot;,&quot;        // For invalid entities we just return the entity&quot;,&quot;        return s;&quot;,&quot;    }&quot;,&quot;  });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Regular expression that matches an HTML entity.&quot;,&quot; * See also HTML5: Tokenization / Tokenizing character references.&quot;,&quot; * @private&quot;,&quot; * @type {!RegExp}&quot;,&quot; */&quot;,&quot;goog.string.HTML_ENTITY_PATTERN_ = /&amp;([^;\\s&lt;&amp;]+);?/g;&quot;,null,null,&quot;/**&quot;,&quot; * Do escaping of whitespace to preserve spatial formatting. We use character&quot;,&quot; * entity #160 to make it safer for xml.&quot;,&quot; * @param {string} str The string in which to escape whitespace.&quot;,&quot; * @param {boolean=} opt_xml Whether to use XML compatible tags.&quot;,&quot; * @return {string} An escaped copy of {@code str}.&quot;,&quot; */&quot;,&quot;goog.string.whitespaceEscape = function(str, opt_xml) {&quot;,&quot;  // This doesn&#39;t use goog.string.preserveSpaces for backwards compatibility.&quot;,&quot;  return goog.string.newLineToBr(str.replace(/  /g, &#39; &amp;#160;&#39;), opt_xml);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Preserve spaces that would be otherwise collapsed in HTML by replacing them&quot;,&quot; * with non-breaking space Unicode characters.&quot;,&quot; * @param {string} str The string in which to preserve whitespace.&quot;,&quot; * @return {string} A copy of {@code str} with preserved whitespace.&quot;,&quot; */&quot;,&quot;goog.string.preserveSpaces = function(str) {&quot;,&quot;  return str.replace(/(^|[\\n ]) /g, &#39;$1&#39; + goog.string.Unicode.NBSP);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Strip quote characters around a string.  The second argument is a string of&quot;,&quot; * characters to treat as quotes.  This can be a single character or a string of&quot;,&quot; * multiple character and in that case each of those are treated as possible&quot;,&quot; * quote characters. For example:&quot;,&quot; *&quot;,&quot; * &lt;pre&gt;&quot;,&quot; * goog.string.stripQuotes(&#39;\&quot;abc\&quot;&#39;, &#39;\&quot;`&#39;) --&gt; &#39;abc&#39;&quot;,&quot; * goog.string.stripQuotes(&#39;`abc`&#39;, &#39;\&quot;`&#39;) --&gt; &#39;abc&#39;&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * @param {string} str The string to strip.&quot;,&quot; * @param {string} quoteChars The quote characters to strip.&quot;,&quot; * @return {string} A copy of {@code str} without the quotes.&quot;,&quot; */&quot;,&quot;goog.string.stripQuotes = function(str, quoteChars) {&quot;,&quot;  var length = quoteChars.length;&quot;,&quot;  for (var i = 0; i &lt; length; i++) {&quot;,&quot;    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);&quot;,&quot;    if (str.charAt(0) == quoteChar &amp;&amp; str.charAt(str.length - 1) == quoteChar) {&quot;,&quot;      return str.substring(1, str.length - 1);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return str;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Truncates a string to a certain length and adds &#39;...&#39; if necessary.  The&quot;,&quot; * length also accounts for the ellipsis, so a maximum length of 10 and a string&quot;,&quot; * &#39;Hello World!&#39; produces &#39;Hello W...&#39;.&quot;,&quot; * @param {string} str The string to truncate.&quot;,&quot; * @param {number} chars Max number of characters.&quot;,&quot; * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped&quot;,&quot; *     characters from being cut off in the middle.&quot;,&quot; * @return {string} The truncated {@code str} string.&quot;,&quot; */&quot;,&quot;goog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {&quot;,&quot;  if (opt_protectEscapedCharacters) {&quot;,&quot;    str = goog.string.unescapeEntities(str);&quot;,&quot;  }&quot;,null,&quot;  if (str.length &gt; chars) {&quot;,&quot;    str = str.substring(0, chars - 3) + &#39;...&#39;;&quot;,&quot;  }&quot;,null,&quot;  if (opt_protectEscapedCharacters) {&quot;,&quot;    str = goog.string.htmlEscape(str);&quot;,&quot;  }&quot;,null,&quot;  return str;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Truncate a string in the middle, adding \&quot;...\&quot; if necessary,&quot;,&quot; * and favoring the beginning of the string.&quot;,&quot; * @param {string} str The string to truncate the middle of.&quot;,&quot; * @param {number} chars Max number of characters.&quot;,&quot; * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped&quot;,&quot; *     characters from being cutoff in the middle.&quot;,&quot; * @param {number=} opt_trailingChars Optional number of trailing characters to&quot;,&quot; *     leave at the end of the string, instead of truncating as close to the&quot;,&quot; *     middle as possible.&quot;,&quot; * @return {string} A truncated copy of {@code str}.&quot;,&quot; */&quot;,&quot;goog.string.truncateMiddle = function(&quot;,&quot;    str, chars, opt_protectEscapedCharacters, opt_trailingChars) {&quot;,&quot;  if (opt_protectEscapedCharacters) {&quot;,&quot;    str = goog.string.unescapeEntities(str);&quot;,&quot;  }&quot;,null,&quot;  if (opt_trailingChars &amp;&amp; str.length &gt; chars) {&quot;,&quot;    if (opt_trailingChars &gt; chars) {&quot;,&quot;      opt_trailingChars = chars;&quot;,&quot;    }&quot;,&quot;    var endPoint = str.length - opt_trailingChars;&quot;,&quot;    var startPoint = chars - opt_trailingChars;&quot;,&quot;    str = str.substring(0, startPoint) + &#39;...&#39; + str.substring(endPoint);&quot;,&quot;  } else if (str.length &gt; chars) {&quot;,&quot;    // Favor the beginning of the string:&quot;,&quot;    var half = Math.floor(chars / 2);&quot;,&quot;    var endPos = str.length - half;&quot;,&quot;    half += chars % 2;&quot;,&quot;    str = str.substring(0, half) + &#39;...&#39; + str.substring(endPos);&quot;,&quot;  }&quot;,null,&quot;  if (opt_protectEscapedCharacters) {&quot;,&quot;    str = goog.string.htmlEscape(str);&quot;,&quot;  }&quot;,null,&quot;  return str;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Special chars that need to be escaped for goog.string.quote.&quot;,&quot; * @private {!Object&lt;string, string&gt;}&quot;,&quot; */&quot;,&quot;goog.string.specialEscapeChars_ = {&quot;,&quot;  &#39;\\0&#39;: &#39;\\\\0&#39;,&quot;,&quot;  &#39;\\b&#39;: &#39;\\\\b&#39;,&quot;,&quot;  &#39;\\f&#39;: &#39;\\\\f&#39;,&quot;,&quot;  &#39;\\n&#39;: &#39;\\\\n&#39;,&quot;,&quot;  &#39;\\r&#39;: &#39;\\\\r&#39;,&quot;,&quot;  &#39;\\t&#39;: &#39;\\\\t&#39;,&quot;,&quot;  &#39;\\x0B&#39;: &#39;\\\\x0B&#39;,  // &#39;\\v&#39; is not supported in JScript&quot;,&quot;  &#39;\&quot;&#39;: &#39;\\\\\&quot;&#39;,&quot;,&quot;  &#39;\\\\&#39;: &#39;\\\\\\\\&#39;,&quot;,&quot;  // To support the use case of embedding quoted strings inside of script&quot;,&quot;  // tags, we have to make sure HTML comments and opening/closing script tags do&quot;,&quot;  // not appear in the resulting string. The specific strings that must be&quot;,&quot;  // escaped are documented at:&quot;,&quot;  // http://www.w3.org/TR/html51/semantics.html#restrictions-for-contents-of-script-elements&quot;,&quot;  &#39;&lt;&#39;: &#39;\\x3c&#39;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Character mappings used internally for goog.string.escapeChar.&quot;,&quot; * @private {!Object&lt;string, string&gt;}&quot;,&quot; */&quot;,&quot;goog.string.jsEscapeCache_ = {&quot;,&quot;  &#39;\\&#39;&#39;: &#39;\\\\\\&#39;&#39;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Encloses a string in double quotes and escapes characters so that the&quot;,&quot; * string is a valid JS string. The resulting string is safe to embed in&quot;,&quot; * `&lt;script&gt;` tags as \&quot;&lt;\&quot; is escaped.&quot;,&quot; * @param {string} s The string to quote.&quot;,&quot; * @return {string} A copy of {@code s} surrounded by double quotes.&quot;,&quot; */&quot;,&quot;goog.string.quote = function(s) {&quot;,&quot;  s = String(s);&quot;,&quot;  var sb = [&#39;\&quot;&#39;];&quot;,&quot;  for (var i = 0; i &lt; s.length; i++) {&quot;,&quot;    var ch = s.charAt(i);&quot;,&quot;    var cc = ch.charCodeAt(0);&quot;,&quot;    sb[i + 1] = goog.string.specialEscapeChars_[ch] ||&quot;,&quot;        ((cc &gt; 31 &amp;&amp; cc &lt; 127) ? ch : goog.string.escapeChar(ch));&quot;,&quot;  }&quot;,&quot;  sb.push(&#39;\&quot;&#39;);&quot;,&quot;  return sb.join(&#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Takes a string and returns the escaped string for that input string.&quot;,&quot; * @param {string} str The string to escape.&quot;,&quot; * @return {string} An escaped string representing {@code str}.&quot;,&quot; */&quot;,&quot;goog.string.escapeString = function(str) {&quot;,&quot;  var sb = [];&quot;,&quot;  for (var i = 0; i &lt; str.length; i++) {&quot;,&quot;    sb[i] = goog.string.escapeChar(str.charAt(i));&quot;,&quot;  }&quot;,&quot;  return sb.join(&#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Takes a character and returns the escaped string for that character. For&quot;,&quot; * example escapeChar(String.fromCharCode(15)) -&gt; \&quot;\\\\x0E\&quot;.&quot;,&quot; * @param {string} c The character to escape.&quot;,&quot; * @return {string} An escaped string representing {@code c}.&quot;,&quot; */&quot;,&quot;goog.string.escapeChar = function(c) {&quot;,&quot;  if (c in goog.string.jsEscapeCache_) {&quot;,&quot;    return goog.string.jsEscapeCache_[c];&quot;,&quot;  }&quot;,null,&quot;  if (c in goog.string.specialEscapeChars_) {&quot;,&quot;    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];&quot;,&quot;  }&quot;,null,&quot;  var rv = c;&quot;,&quot;  var cc = c.charCodeAt(0);&quot;,&quot;  if (cc &gt; 31 &amp;&amp; cc &lt; 127) {&quot;,&quot;    rv = c;&quot;,&quot;  } else {&quot;,&quot;    // tab is 9 but handled above&quot;,&quot;    if (cc &lt; 256) {&quot;,&quot;      rv = &#39;\\\\x&#39;;&quot;,&quot;      if (cc &lt; 16 || cc &gt; 256) {&quot;,&quot;        rv += &#39;0&#39;;&quot;,&quot;      }&quot;,&quot;    } else {&quot;,&quot;      rv = &#39;\\\\u&#39;;&quot;,&quot;      if (cc &lt; 4096) {  // \\u1000&quot;,&quot;        rv += &#39;0&#39;;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    rv += cc.toString(16).toUpperCase();&quot;,&quot;  }&quot;,null,&quot;  return goog.string.jsEscapeCache_[c] = rv;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Determines whether a string contains a substring.&quot;,&quot; * @param {string} str The string to search.&quot;,&quot; * @param {string} subString The substring to search for.&quot;,&quot; * @return {boolean} Whether {@code str} contains {@code subString}.&quot;,&quot; */&quot;,&quot;goog.string.contains = function(str, subString) {&quot;,&quot;  return str.indexOf(subString) != -1;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Determines whether a string contains a substring, ignoring case.&quot;,&quot; * @param {string} str The string to search.&quot;,&quot; * @param {string} subString The substring to search for.&quot;,&quot; * @return {boolean} Whether {@code str} contains {@code subString}.&quot;,&quot; */&quot;,&quot;goog.string.caseInsensitiveContains = function(str, subString) {&quot;,&quot;  return goog.string.contains(str.toLowerCase(), subString.toLowerCase());&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the non-overlapping occurrences of ss in s.&quot;,&quot; * If either s or ss evalutes to false, then returns zero.&quot;,&quot; * @param {string} s The string to look in.&quot;,&quot; * @param {string} ss The string to look for.&quot;,&quot; * @return {number} Number of occurrences of ss in s.&quot;,&quot; */&quot;,&quot;goog.string.countOf = function(s, ss) {&quot;,&quot;  return s &amp;&amp; ss ? s.split(ss).length - 1 : 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes a substring of a specified length at a specific&quot;,&quot; * index in a string.&quot;,&quot; * @param {string} s The base string from which to remove.&quot;,&quot; * @param {number} index The index at which to remove the substring.&quot;,&quot; * @param {number} stringLength The length of the substring to remove.&quot;,&quot; * @return {string} A copy of {@code s} with the substring removed or the full&quot;,&quot; *     string if nothing is removed or the input is invalid.&quot;,&quot; */&quot;,&quot;goog.string.removeAt = function(s, index, stringLength) {&quot;,&quot;  var resultStr = s;&quot;,&quot;  // If the index is greater or equal to 0 then remove substring&quot;,&quot;  if (index &gt;= 0 &amp;&amp; index &lt; s.length &amp;&amp; stringLength &gt; 0) {&quot;,&quot;    resultStr = s.substr(0, index) +&quot;,&quot;        s.substr(index + stringLength, s.length - index - stringLength);&quot;,&quot;  }&quot;,&quot;  return resultStr;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes the first occurrence of a substring from a string.&quot;,&quot; * @param {string} str The base string from which to remove.&quot;,&quot; * @param {string} substr The string to remove.&quot;,&quot; * @return {string} A copy of {@code str} with {@code substr} removed or the&quot;,&quot; *     full string if nothing is removed.&quot;,&quot; */&quot;,&quot;goog.string.remove = function(str, substr) {&quot;,&quot;  return str.replace(substr, &#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; *  Removes all occurrences of a substring from a string.&quot;,&quot; *  @param {string} s The base string from which to remove.&quot;,&quot; *  @param {string} ss The string to remove.&quot;,&quot; *  @return {string} A copy of {@code s} with {@code ss} removed or the full&quot;,&quot; *      string if nothing is removed.&quot;,&quot; */&quot;,&quot;goog.string.removeAll = function(s, ss) {&quot;,&quot;  var re = new RegExp(goog.string.regExpEscape(ss), &#39;g&#39;);&quot;,&quot;  return s.replace(re, &#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; *  Replaces all occurrences of a substring of a string with a new substring.&quot;,&quot; *  @param {string} s The base string from which to remove.&quot;,&quot; *  @param {string} ss The string to replace.&quot;,&quot; *  @param {string} replacement The replacement string.&quot;,&quot; *  @return {string} A copy of {@code s} with {@code ss} replaced by&quot;,&quot; *      {@code replacement} or the original string if nothing is replaced.&quot;,&quot; */&quot;,&quot;goog.string.replaceAll = function(s, ss, replacement) {&quot;,&quot;  var re = new RegExp(goog.string.regExpEscape(ss), &#39;g&#39;);&quot;,&quot;  return s.replace(re, replacement.replace(/\\$/g, &#39;$$$$&#39;));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Escapes characters in the string that are not safe to use in a RegExp.&quot;,&quot; * @param {*} s The string to escape. If not a string, it will be casted&quot;,&quot; *     to one.&quot;,&quot; * @return {string} A RegExp safe, escaped copy of {@code s}.&quot;,&quot; */&quot;,&quot;goog.string.regExpEscape = function(s) {&quot;,&quot;  return String(s)&quot;,&quot;      .replace(/([-()\\[\\]{}+?*.$\\^|,:#&lt;!\\\\])/g, &#39;\\\\$1&#39;)&quot;,&quot;      .replace(/\\x08/g, &#39;\\\\x08&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Repeats a string n times.&quot;,&quot; * @param {string} string The string to repeat.&quot;,&quot; * @param {number} length The number of times to repeat.&quot;,&quot; * @return {string} A string containing {@code length} repetitions of&quot;,&quot; *     {@code string}.&quot;,&quot; */&quot;,&quot;goog.string.repeat = (String.prototype.repeat) ? function(string, length) {&quot;,&quot;  // The native method is over 100 times faster than the alternative.&quot;,&quot;  return string.repeat(length);&quot;,&quot;} : function(string, length) {&quot;,&quot;  return new Array(length + 1).join(string);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Pads number to given length and optionally rounds it to a given precision.&quot;,&quot; * For example:&quot;,&quot; * &lt;pre&gt;padNumber(1.25, 2, 3) -&gt; &#39;01.250&#39;&quot;,&quot; * padNumber(1.25, 2) -&gt; &#39;01.25&#39;&quot;,&quot; * padNumber(1.25, 2, 1) -&gt; &#39;01.3&#39;&quot;,&quot; * padNumber(1.25, 0) -&gt; &#39;1.25&#39;&lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * @param {number} num The number to pad.&quot;,&quot; * @param {number} length The desired length.&quot;,&quot; * @param {number=} opt_precision The desired precision.&quot;,&quot; * @return {string} {@code num} as a string with the given options.&quot;,&quot; */&quot;,&quot;goog.string.padNumber = function(num, length, opt_precision) {&quot;,&quot;  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);&quot;,&quot;  var index = s.indexOf(&#39;.&#39;);&quot;,&quot;  if (index == -1) {&quot;,&quot;    index = s.length;&quot;,&quot;  }&quot;,&quot;  return goog.string.repeat(&#39;0&#39;, Math.max(0, length - index)) + s;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns a string representation of the given object, with&quot;,&quot; * null and undefined being returned as the empty string.&quot;,&quot; *&quot;,&quot; * @param {*} obj The object to convert.&quot;,&quot; * @return {string} A string representation of the {@code obj}.&quot;,&quot; */&quot;,&quot;goog.string.makeSafe = function(obj) {&quot;,&quot;  return obj == null ? &#39;&#39; : String(obj);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Concatenates string expressions. This is useful&quot;,&quot; * since some browsers are very inefficient when it comes to using plus to&quot;,&quot; * concat strings. Be careful when using null and undefined here since&quot;,&quot; * these will not be included in the result. If you need to represent these&quot;,&quot; * be sure to cast the argument to a String first.&quot;,&quot; * For example:&quot;,&quot; * &lt;pre&gt;buildString(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;) -&gt; &#39;abcd&#39;&quot;,&quot; * buildString(null, undefined) -&gt; &#39;&#39;&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; * @param {...*} var_args A list of strings to concatenate. If not a string,&quot;,&quot; *     it will be casted to one.&quot;,&quot; * @return {string} The concatenation of {@code var_args}.&quot;,&quot; */&quot;,&quot;goog.string.buildString = function(var_args) {&quot;,&quot;  return Array.prototype.join.call(arguments, &#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns a string with at least 64-bits of randomness.&quot;,&quot; *&quot;,&quot; * Doesn&#39;t trust Javascript&#39;s random function entirely. Uses a combination of&quot;,&quot; * random and current timestamp, and then encodes the string in base-36 to&quot;,&quot; * make it shorter.&quot;,&quot; *&quot;,&quot; * @return {string} A random string, e.g. sn1s7vb4gcic.&quot;,&quot; */&quot;,&quot;goog.string.getRandomString = function() {&quot;,&quot;  var x = 2147483648;&quot;,&quot;  return Math.floor(Math.random() * x).toString(36) +&quot;,&quot;      Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Compares two version numbers.&quot;,&quot; *&quot;,&quot; * @param {string|number} version1 Version of first item.&quot;,&quot; * @param {string|number} version2 Version of second item.&quot;,&quot; *&quot;,&quot; * @return {number}  1 if {@code version1} is higher.&quot;,&quot; *                   0 if arguments are equal.&quot;,&quot; *                  -1 if {@code version2} is higher.&quot;,&quot; */&quot;,&quot;goog.string.compareVersions = function(version1, version2) {&quot;,&quot;  var order = 0;&quot;,&quot;  // Trim leading and trailing whitespace and split the versions into&quot;,&quot;  // subversions.&quot;,&quot;  var v1Subs = goog.string.trim(String(version1)).split(&#39;.&#39;);&quot;,&quot;  var v2Subs = goog.string.trim(String(version2)).split(&#39;.&#39;);&quot;,&quot;  var subCount = Math.max(v1Subs.length, v2Subs.length);&quot;,null,&quot;  // Iterate over the subversions, as long as they appear to be equivalent.&quot;,&quot;  for (var subIdx = 0; order == 0 &amp;&amp; subIdx &lt; subCount; subIdx++) {&quot;,&quot;    var v1Sub = v1Subs[subIdx] || &#39;&#39;;&quot;,&quot;    var v2Sub = v2Subs[subIdx] || &#39;&#39;;&quot;,null,&quot;    do {&quot;,&quot;      // Split the subversions into pairs of numbers and qualifiers (like &#39;b&#39;).&quot;,&quot;      // Two different RegExp objects are use to make it clear the code&quot;,&quot;      // is side-effect free&quot;,&quot;      var v1Comp = /(\\d*)(\\D*)(.*)/.exec(v1Sub) || [&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;];&quot;,&quot;      var v2Comp = /(\\d*)(\\D*)(.*)/.exec(v2Sub) || [&#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;];&quot;,&quot;      // Break if there are no more matches.&quot;,&quot;      if (v1Comp[0].length == 0 &amp;&amp; v2Comp[0].length == 0) {&quot;,&quot;        break;&quot;,&quot;      }&quot;,null,&quot;      // Parse the numeric part of the subversion. A missing number is&quot;,&quot;      // equivalent to 0.&quot;,&quot;      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);&quot;,&quot;      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);&quot;,null,&quot;      // Compare the subversion components. The number has the highest&quot;,&quot;      // precedence. Next, if the numbers are equal, a subversion without any&quot;,&quot;      // qualifier is always higher than a subversion with any qualifier. Next,&quot;,&quot;      // the qualifiers are compared as strings.&quot;,&quot;      order = goog.string.compareElements_(v1CompNum, v2CompNum) ||&quot;,&quot;          goog.string.compareElements_(&quot;,&quot;              v1Comp[2].length == 0, v2Comp[2].length == 0) ||&quot;,&quot;          goog.string.compareElements_(v1Comp[2], v2Comp[2]);&quot;,&quot;      // Stop as soon as an inequality is discovered.&quot;,null,&quot;      v1Sub = v1Comp[3];&quot;,&quot;      v2Sub = v2Comp[3];&quot;,&quot;    } while (order == 0);&quot;,&quot;  }&quot;,null,&quot;  return order;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Compares elements of a version number.&quot;,&quot; *&quot;,&quot; * @param {string|number|boolean} left An element from a version number.&quot;,&quot; * @param {string|number|boolean} right An element from a version number.&quot;,&quot; *&quot;,&quot; * @return {number}  1 if {@code left} is higher.&quot;,&quot; *                   0 if arguments are equal.&quot;,&quot; *                  -1 if {@code right} is higher.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.string.compareElements_ = function(left, right) {&quot;,&quot;  if (left &lt; right) {&quot;,&quot;    return -1;&quot;,&quot;  } else if (left &gt; right) {&quot;,&quot;    return 1;&quot;,&quot;  }&quot;,&quot;  return 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * String hash function similar to java.lang.String.hashCode().&quot;,&quot; * The hash code for a string is computed as&quot;,&quot; * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],&quot;,&quot; * where s[i] is the ith character of the string and n is the length of&quot;,&quot; * the string. We mod the result to make it between 0 (inclusive) and 2^32&quot;,&quot; * (exclusive).&quot;,&quot; * @param {string} str A string.&quot;,&quot; * @return {number} Hash value for {@code str}, between 0 (inclusive) and 2^32&quot;,&quot; *  (exclusive). The empty string returns 0.&quot;,&quot; */&quot;,&quot;goog.string.hashCode = function(str) {&quot;,&quot;  var result = 0;&quot;,&quot;  for (var i = 0; i &lt; str.length; ++i) {&quot;,&quot;    // Normalize to 4 byte range, 0 ... 2^32.&quot;,&quot;    result = (31 * result + str.charCodeAt(i)) &gt;&gt;&gt; 0;&quot;,&quot;  }&quot;,&quot;  return result;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * The most recent unique ID. |0 is equivalent to Math.floor in this case.&quot;,&quot; * @type {number}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;&quot;,null,null,&quot;/**&quot;,&quot; * Generates and returns a string which is unique in the current document.&quot;,&quot; * This is useful, for example, to create unique IDs for DOM elements.&quot;,&quot; * @return {string} A unique id.&quot;,&quot; */&quot;,&quot;goog.string.createUniqueString = function() {&quot;,&quot;  return &#39;goog_&#39; + goog.string.uniqueStringCounter_++;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts the supplied string to a number, which may be Infinity or NaN.&quot;,&quot; * This function strips whitespace: (toNumber(&#39; 123&#39;) === 123)&quot;,&quot; * This function accepts scientific notation: (toNumber(&#39;1e1&#39;) === 10)&quot;,&quot; *&quot;,&quot; * This is better than Javascript&#39;s built-in conversions because, sadly:&quot;,&quot; *     (Number(&#39; &#39;) === 0) and (parseFloat(&#39;123a&#39;) === 123)&quot;,&quot; *&quot;,&quot; * @param {string} str The string to convert.&quot;,&quot; * @return {number} The number the supplied string represents, or NaN.&quot;,&quot; */&quot;,&quot;goog.string.toNumber = function(str) {&quot;,&quot;  var num = Number(str);&quot;,&quot;  if (num == 0 &amp;&amp; goog.string.isEmptyOrWhitespace(str)) {&quot;,&quot;    return NaN;&quot;,&quot;  }&quot;,&quot;  return num;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns whether the given string is lower camel case (e.g. \&quot;isFooBar\&quot;).&quot;,&quot; *&quot;,&quot; * Note that this assumes the string is entirely letters.&quot;,&quot; * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms&quot;,&quot; *&quot;,&quot; * @param {string} str String to test.&quot;,&quot; * @return {boolean} Whether the string is lower camel case.&quot;,&quot; */&quot;,&quot;goog.string.isLowerCamelCase = function(str) {&quot;,&quot;  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns whether the given string is upper camel case (e.g. \&quot;FooBarBaz\&quot;).&quot;,&quot; *&quot;,&quot; * Note that this assumes the string is entirely letters.&quot;,&quot; * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms&quot;,&quot; *&quot;,&quot; * @param {string} str String to test.&quot;,&quot; * @return {boolean} Whether the string is upper camel case.&quot;,&quot; */&quot;,&quot;goog.string.isUpperCamelCase = function(str) {&quot;,&quot;  return /^([A-Z][a-z]*)+$/.test(str);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a string from selector-case to camelCase (e.g. from&quot;,&quot; * \&quot;multi-part-string\&quot; to \&quot;multiPartString\&quot;), useful for converting&quot;,&quot; * CSS selectors and HTML dataset keys to their equivalent JS properties.&quot;,&quot; * @param {string} str The string in selector-case form.&quot;,&quot; * @return {string} The string in camelCase form.&quot;,&quot; */&quot;,&quot;goog.string.toCamelCase = function(str) {&quot;,&quot;  return String(str).replace(&quot;,&quot;      /\\-([a-z])/g, function(all, match) { return match.toUpperCase(); });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a string from camelCase to selector-case (e.g. from&quot;,&quot; * \&quot;multiPartString\&quot; to \&quot;multi-part-string\&quot;), useful for converting JS&quot;,&quot; * style and dataset properties to equivalent CSS selectors and HTML keys.&quot;,&quot; * @param {string} str The string in camelCase form.&quot;,&quot; * @return {string} The string in selector-case form.&quot;,&quot; */&quot;,&quot;goog.string.toSelectorCase = function(str) {&quot;,&quot;  return String(str).replace(/([A-Z])/g, &#39;-$1&#39;).toLowerCase();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a string into TitleCase. First character of the string is always&quot;,&quot; * capitalized in addition to the first letter of every subsequent word.&quot;,&quot; * Words are delimited by one or more whitespaces by default. Custom delimiters&quot;,&quot; * can optionally be specified to replace the default, which doesn&#39;t preserve&quot;,&quot; * whitespace delimiters and instead must be explicitly included if needed.&quot;,&quot; *&quot;,&quot; * Default delimiter =&gt; \&quot; \&quot;:&quot;,&quot; *    goog.string.toTitleCase(&#39;oneTwoThree&#39;)    =&gt; &#39;OneTwoThree&#39;&quot;,&quot; *    goog.string.toTitleCase(&#39;one two three&#39;)  =&gt; &#39;One Two Three&#39;&quot;,&quot; *    goog.string.toTitleCase(&#39;  one   two   &#39;) =&gt; &#39;  One   Two   &#39;&quot;,&quot; *    goog.string.toTitleCase(&#39;one_two_three&#39;)  =&gt; &#39;One_two_three&#39;&quot;,&quot; *    goog.string.toTitleCase(&#39;one-two-three&#39;)  =&gt; &#39;One-two-three&#39;&quot;,&quot; *&quot;,&quot; * Custom delimiter =&gt; \&quot;_-.\&quot;:&quot;,&quot; *    goog.string.toTitleCase(&#39;oneTwoThree&#39;, &#39;_-.&#39;)       =&gt; &#39;OneTwoThree&#39;&quot;,&quot; *    goog.string.toTitleCase(&#39;one two three&#39;, &#39;_-.&#39;)     =&gt; &#39;One two three&#39;&quot;,&quot; *    goog.string.toTitleCase(&#39;  one   two   &#39;, &#39;_-.&#39;)    =&gt; &#39;  one   two   &#39;&quot;,&quot; *    goog.string.toTitleCase(&#39;one_two_three&#39;, &#39;_-.&#39;)     =&gt; &#39;One_Two_Three&#39;&quot;,&quot; *    goog.string.toTitleCase(&#39;one-two-three&#39;, &#39;_-.&#39;)     =&gt; &#39;One-Two-Three&#39;&quot;,&quot; *    goog.string.toTitleCase(&#39;one...two...three&#39;, &#39;_-.&#39;) =&gt; &#39;One...Two...Three&#39;&quot;,&quot; *    goog.string.toTitleCase(&#39;one. two. three&#39;, &#39;_-.&#39;)   =&gt; &#39;One. two. three&#39;&quot;,&quot; *    goog.string.toTitleCase(&#39;one-two.three&#39;, &#39;_-.&#39;)     =&gt; &#39;One-Two.Three&#39;&quot;,&quot; *&quot;,&quot; * @param {string} str String value in camelCase form.&quot;,&quot; * @param {string=} opt_delimiters Custom delimiter character set used to&quot;,&quot; *      distinguish words in the string value. Each character represents a&quot;,&quot; *      single delimiter. When provided, default whitespace delimiter is&quot;,&quot; *      overridden and must be explicitly included if needed.&quot;,&quot; * @return {string} String value in TitleCase form.&quot;,&quot; */&quot;,&quot;goog.string.toTitleCase = function(str, opt_delimiters) {&quot;,&quot;  var delimiters = goog.isString(opt_delimiters) ?&quot;,&quot;      goog.string.regExpEscape(opt_delimiters) :&quot;,&quot;      &#39;\\\\s&#39;;&quot;,null,&quot;  // For IE8, we need to prevent using an empty character set. Otherwise,&quot;,&quot;  // incorrect matching will occur.&quot;,&quot;  delimiters = delimiters ? &#39;|[&#39; + delimiters + &#39;]+&#39; : &#39;&#39;;&quot;,null,&quot;  var regexp = new RegExp(&#39;(^&#39; + delimiters + &#39;)([a-z])&#39;, &#39;g&#39;);&quot;,&quot;  return str.replace(&quot;,&quot;      regexp, function(all, p1, p2) { return p1 + p2.toUpperCase(); });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Capitalizes a string, i.e. converts the first letter to uppercase&quot;,&quot; * and all other letters to lowercase, e.g.:&quot;,&quot; *&quot;,&quot; * goog.string.capitalize(&#39;one&#39;)     =&gt; &#39;One&#39;&quot;,&quot; * goog.string.capitalize(&#39;ONE&#39;)     =&gt; &#39;One&#39;&quot;,&quot; * goog.string.capitalize(&#39;one two&#39;) =&gt; &#39;One two&#39;&quot;,&quot; *&quot;,&quot; * Note that this function does not trim initial whitespace.&quot;,&quot; *&quot;,&quot; * @param {string} str String value to capitalize.&quot;,&quot; * @return {string} String value with first letter in uppercase.&quot;,&quot; */&quot;,&quot;goog.string.capitalize = function(str) {&quot;,&quot;  return String(str.charAt(0)).toUpperCase() +&quot;,&quot;      String(str.substr(1)).toLowerCase();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Parse a string in decimal or hexidecimal (&#39;0xFFFF&#39;) form.&quot;,&quot; *&quot;,&quot; * To parse a particular radix, please use parseInt(string, radix) directly. See&quot;,&quot; * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt&quot;,&quot; *&quot;,&quot; * This is a wrapper for the built-in parseInt function that will only parse&quot;,&quot; * numbers as base 10 or base 16.  Some JS implementations assume strings&quot;,&quot; * starting with \&quot;0\&quot; are intended to be octal. ES3 allowed but discouraged&quot;,&quot; * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.&quot;,&quot; *&quot;,&quot; * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj&quot;,&quot; *&quot;,&quot; * @param {string|number|null|undefined} value The value to be parsed.&quot;,&quot; * @return {number} The number, parsed. If the string failed to parse, this&quot;,&quot; *     will be NaN.&quot;,&quot; */&quot;,&quot;goog.string.parseInt = function(value) {&quot;,&quot;  // Force finite numbers to strings.&quot;,&quot;  if (isFinite(value)) {&quot;,&quot;    value = String(value);&quot;,&quot;  }&quot;,null,&quot;  if (goog.isString(value)) {&quot;,&quot;    // If the string starts with &#39;0x&#39; or &#39;-0x&#39;, parse as hex.&quot;,&quot;    return /^\\s*-?0x/i.test(value) ? parseInt(value, 16) : parseInt(value, 10);&quot;,&quot;  }&quot;,null,&quot;  return NaN;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Splits a string on a separator a limited number of times.&quot;,&quot; *&quot;,&quot; * This implementation is more similar to Python or Java, where the limit&quot;,&quot; * parameter specifies the maximum number of splits rather than truncating&quot;,&quot; * the number of results.&quot;,&quot; *&quot;,&quot; * See http://docs.python.org/2/library/stdtypes.html#str.split&quot;,&quot; * See JavaDoc: http://goo.gl/F2AsY&quot;,&quot; * See Mozilla reference: http://goo.gl/dZdZs&quot;,&quot; *&quot;,&quot; * @param {string} str String to split.&quot;,&quot; * @param {string} separator The separator.&quot;,&quot; * @param {number} limit The limit to the number of splits. The resulting array&quot;,&quot; *     will have a maximum length of limit+1.  Negative numbers are the same&quot;,&quot; *     as zero.&quot;,&quot; * @return {!Array&lt;string&gt;} The string, split.&quot;,&quot; */&quot;,&quot;goog.string.splitLimit = function(str, separator, limit) {&quot;,&quot;  var parts = str.split(separator);&quot;,&quot;  var returnVal = [];&quot;,null,&quot;  // Only continue doing this while we haven&#39;t hit the limit and we have&quot;,&quot;  // parts left.&quot;,&quot;  while (limit &gt; 0 &amp;&amp; parts.length) {&quot;,&quot;    returnVal.push(parts.shift());&quot;,&quot;    limit--;&quot;,&quot;  }&quot;,null,&quot;  // If there are remaining parts, append them to the end.&quot;,&quot;  if (parts.length) {&quot;,&quot;    returnVal.push(parts.join(separator));&quot;,&quot;  }&quot;,null,&quot;  return returnVal;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Finds the characters to the right of the last instance of any separator&quot;,&quot; *&quot;,&quot; * This function is similar to goog.string.path.baseName, except it can take a&quot;,&quot; * list of characters to split the string on. It will return the rightmost&quot;,&quot; * grouping of characters to the right of any separator as a left-to-right&quot;,&quot; * oriented string.&quot;,&quot; *&quot;,&quot; * @see goog.string.path.baseName&quot;,&quot; * @param {string} str The string&quot;,&quot; * @param {string|!Array&lt;string&gt;} separators A list of separator characters&quot;,&quot; * @return {string} The last part of the string with respect to the separators&quot;,&quot; */&quot;,&quot;goog.string.lastComponent = function(str, separators) {&quot;,&quot;  if (!separators) {&quot;,&quot;    return str;&quot;,&quot;  } else if (typeof separators == &#39;string&#39;) {&quot;,&quot;    separators = [separators];&quot;,&quot;  }&quot;,null,&quot;  var lastSeparatorIndex = -1;&quot;,&quot;  for (var i = 0; i &lt; separators.length; i++) {&quot;,&quot;    if (separators[i] == &#39;&#39;) {&quot;,&quot;      continue;&quot;,&quot;    }&quot;,&quot;    var currentSeparatorIndex = str.lastIndexOf(separators[i]);&quot;,&quot;    if (currentSeparatorIndex &gt; lastSeparatorIndex) {&quot;,&quot;      lastSeparatorIndex = currentSeparatorIndex;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  if (lastSeparatorIndex == -1) {&quot;,&quot;    return str;&quot;,&quot;  }&quot;,&quot;  return str.slice(lastSeparatorIndex + 1);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Computes the Levenshtein edit distance between two strings.&quot;,&quot; * @param {string} a&quot;,&quot; * @param {string} b&quot;,&quot; * @return {number} The edit distance between the two strings.&quot;,&quot; */&quot;,&quot;goog.string.editDistance = function(a, b) {&quot;,&quot;  var v0 = [];&quot;,&quot;  var v1 = [];&quot;,null,&quot;  if (a == b) {&quot;,&quot;    return 0;&quot;,&quot;  }&quot;,null,&quot;  if (!a.length || !b.length) {&quot;,&quot;    return Math.max(a.length, b.length);&quot;,&quot;  }&quot;,null,&quot;  for (var i = 0; i &lt; b.length + 1; i++) {&quot;,&quot;    v0[i] = i;&quot;,&quot;  }&quot;,null,&quot;  for (var i = 0; i &lt; a.length; i++) {&quot;,&quot;    v1[0] = i + 1;&quot;,null,&quot;    for (var j = 0; j &lt; b.length; j++) {&quot;,&quot;      var cost = Number(a[i] != b[j]);&quot;,&quot;      // Cost for the substring is the minimum of adding one character, removing&quot;,&quot;      // one character, or a swap.&quot;,&quot;      v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost);&quot;,&quot;    }&quot;,null,&quot;    for (var j = 0; j &lt; v0.length; j++) {&quot;,&quot;      v0[j] = v1[j];&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  return v1[b.length];&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>