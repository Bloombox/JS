<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>xhrmanager.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;xhrmanager.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/net/xhrmanager.js&quot;,[&quot;// Copyright 2006 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Manages a pool of XhrIo&#39;s. This handles all the details of&quot;,&quot; * dealing with the XhrPool and provides a simple interface for sending requests&quot;,&quot; * and managing events.&quot;,&quot; *&quot;,&quot; * This class supports queueing &amp; prioritization of requests (XhrIoPool&quot;,&quot; * handles this) and retrying of requests.&quot;,&quot; *&quot;,&quot; * The events fired by the XhrManager are an aggregation of the events of&quot;,&quot; * each of its XhrIo objects (with some filtering, i.e., ERROR only called&quot;,&quot; * when there are no more retries left). For this reason, all send requests have&quot;,&quot; * to have an id, so that the user of this object can know which event is for&quot;,&quot; * which request.&quot;,&quot; *&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.net.XhrManager&#39;);&quot;,&quot;goog.provide(&#39;goog.net.XhrManager.Event&#39;);&quot;,&quot;goog.provide(&#39;goog.net.XhrManager.Request&#39;);&quot;,null,&quot;goog.require(&#39;goog.events&#39;);&quot;,&quot;goog.require(&#39;goog.events.Event&#39;);&quot;,&quot;goog.require(&#39;goog.events.EventHandler&#39;);&quot;,&quot;goog.require(&#39;goog.events.EventTarget&#39;);&quot;,&quot;goog.require(&#39;goog.net.ErrorCode&#39;);&quot;,&quot;goog.require(&#39;goog.net.EventType&#39;);&quot;,&quot;goog.require(&#39;goog.net.XhrIo&#39;);&quot;,&quot;goog.require(&#39;goog.net.XhrIoPool&#39;);&quot;,&quot;goog.require(&#39;goog.structs.Map&#39;);&quot;,null,&quot;// TODO(user): Add some time in between retries.&quot;,null,null,null,&quot;/**&quot;,&quot; * A manager of an XhrIoPool.&quot;,&quot; * @param {number=} opt_maxRetries Max. number of retries (Default: 1).&quot;,&quot; * @param {goog.structs.Map=} opt_headers Map of default headers to add to every&quot;,&quot; *     request.&quot;,&quot; * @param {number=} opt_minCount Min. number of objects (Default: 0).&quot;,&quot; * @param {number=} opt_maxCount Max. number of objects (Default: 10).&quot;,&quot; * @param {number=} opt_timeoutInterval Timeout (in ms) before aborting an&quot;,&quot; *     attempt (Default: 0ms).&quot;,&quot; * @param {boolean=} opt_withCredentials Add credentials to every request&quot;,&quot; *     (Default: false).&quot;,&quot; * @constructor&quot;,&quot; * @extends {goog.events.EventTarget}&quot;,&quot; */&quot;,&quot;goog.net.XhrManager = function(&quot;,&quot;    opt_maxRetries, opt_headers, opt_minCount, opt_maxCount,&quot;,&quot;    opt_timeoutInterval, opt_withCredentials) {&quot;,&quot;  goog.net.XhrManager.base(this, &#39;constructor&#39;);&quot;,null,&quot;  /**&quot;,&quot;   * Maximum number of retries for a given request&quot;,&quot;   * @type {number}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.maxRetries_ = goog.isDef(opt_maxRetries) ? opt_maxRetries : 1;&quot;,null,&quot;  /**&quot;,&quot;   * Timeout interval for an attempt of a given request.&quot;,&quot;   * @type {number}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.timeoutInterval_ =&quot;,&quot;      goog.isDef(opt_timeoutInterval) ? Math.max(0, opt_timeoutInterval) : 0;&quot;,null,&quot;  /**&quot;,&quot;   * Add credentials to every request.&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.withCredentials_ = !!opt_withCredentials;&quot;,null,&quot;  /**&quot;,&quot;   * The pool of XhrIo&#39;s to use.&quot;,&quot;   * @type {goog.net.XhrIoPool}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.xhrPool_ = new goog.net.XhrIoPool(&quot;,&quot;      opt_headers, opt_minCount, opt_maxCount, opt_withCredentials);&quot;,null,&quot;  /**&quot;,&quot;   * Map of ID&#39;s to requests.&quot;,&quot;   * @type {goog.structs.Map&lt;string, !goog.net.XhrManager.Request&gt;}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.requests_ = new goog.structs.Map();&quot;,null,&quot;  /**&quot;,&quot;   * The event handler.&quot;,&quot;   * @type {goog.events.EventHandler&lt;!goog.net.XhrManager&gt;}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.eventHandler_ = new goog.events.EventHandler(this);&quot;,&quot;};&quot;,&quot;goog.inherits(goog.net.XhrManager, goog.events.EventTarget);&quot;,null,null,&quot;/**&quot;,&quot; * Error to throw when a send is attempted with an ID that the manager already&quot;,&quot; * has registered for another request.&quot;,&quot; * @type {string}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.ERROR_ID_IN_USE_ = &#39;[goog.net.XhrManager] ID in use&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * The goog.net.EventType&#39;s to listen/unlisten for on the XhrIo object.&quot;,&quot; * @type {Array&lt;goog.net.EventType&gt;}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.XHR_EVENT_TYPES_ = [&quot;,&quot;  goog.net.EventType.READY, goog.net.EventType.COMPLETE,&quot;,&quot;  goog.net.EventType.SUCCESS, goog.net.EventType.ERROR,&quot;,&quot;  goog.net.EventType.ABORT, goog.net.EventType.TIMEOUT&quot;,&quot;];&quot;,null,null,&quot;/**&quot;,&quot; * Sets the number of milliseconds after which an incomplete request will be&quot;,&quot; * aborted. Zero means no timeout is set.&quot;,&quot; * @param {number} ms Timeout interval in milliseconds; 0 means none.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.setTimeoutInterval = function(ms) {&quot;,&quot;  this.timeoutInterval_ = Math.max(0, ms);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the number of requests either in flight, or waiting to be sent.&quot;,&quot; * The count will include the current request if used within a COMPLETE event&quot;,&quot; * handler or callback.&quot;,&quot; * @return {number} The number of requests in flight or pending send.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.getOutstandingCount = function() {&quot;,&quot;  return this.requests_.getCount();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns an array of request ids that are either in flight, or waiting to&quot;,&quot; * be sent. The id of the current request will be included if used within a&quot;,&quot; * COMPLETE event handler or callback.&quot;,&quot; * @return {!Array&lt;string&gt;} Request ids in flight or pending send.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.getOutstandingRequestIds = function() {&quot;,&quot;  return this.requests_.getKeys();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Registers the given request to be sent. Throws an error if a request&quot;,&quot; * already exists with the given ID.&quot;,&quot; * NOTE: It is not sent immediately. It is buffered and will be sent when an&quot;,&quot; * XhrIo object becomes available, taking into account the request&#39;s&quot;,&quot; * priority. Note also that requests of equal priority are sent in an&quot;,&quot; * implementation specific order - to get FIFO queue semantics use a&quot;,&quot; * monotonically increasing priority for successive requests.&quot;,&quot; * @param {string} id The id of the request.&quot;,&quot; * @param {string} url Uri to make the request to.&quot;,&quot; * @param {string=} opt_method Send method, default: GET.&quot;,&quot; * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}&quot;,&quot; *     opt_content Post data.&quot;,&quot; * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the&quot;,&quot; *     request.&quot;,&quot; * @param {number=} opt_priority The priority of the request. A smaller value&quot;,&quot; *     means a higher priority.&quot;,&quot; * @param {Function=} opt_callback Callback function for when request is&quot;,&quot; *     complete. The only param is the event object from the COMPLETE event.&quot;,&quot; * @param {number=} opt_maxRetries The maximum number of times the request&quot;,&quot; *     should be retried.&quot;,&quot; * @param {goog.net.XhrIo.ResponseType=} opt_responseType The response type of&quot;,&quot; *     this request; defaults to goog.net.XhrIo.ResponseType.DEFAULT.&quot;,&quot; * @param {boolean=} opt_withCredentials Add credentials to this request,&quot;,&quot; *     default: false.&quot;,&quot; * @return {!goog.net.XhrManager.Request} The queued request object.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.send = function(&quot;,&quot;    id, url, opt_method, opt_content, opt_headers, opt_priority, opt_callback,&quot;,&quot;    opt_maxRetries, opt_responseType, opt_withCredentials) {&quot;,&quot;  var requests = this.requests_;&quot;,&quot;  // Check if there is already a request with the given id.&quot;,&quot;  if (requests.get(id)) {&quot;,&quot;    throw new Error(goog.net.XhrManager.ERROR_ID_IN_USE_);&quot;,&quot;  }&quot;,null,&quot;  // Make the Request object.&quot;,&quot;  var request = new goog.net.XhrManager.Request(&quot;,&quot;      url, goog.bind(this.handleEvent_, this, id), opt_method, opt_content,&quot;,&quot;      opt_headers, opt_callback,&quot;,&quot;      goog.isDef(opt_maxRetries) ? opt_maxRetries : this.maxRetries_,&quot;,&quot;      opt_responseType,&quot;,&quot;      goog.isDef(opt_withCredentials) ? opt_withCredentials :&quot;,&quot;                                        this.withCredentials_);&quot;,&quot;  this.requests_.set(id, request);&quot;,null,&quot;  // Setup the callback for the pool.&quot;,&quot;  var callback = goog.bind(this.handleAvailableXhr_, this, id);&quot;,&quot;  this.xhrPool_.getObject(callback, opt_priority);&quot;,null,&quot;  return request;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Aborts the request associated with id.&quot;,&quot; * @param {string} id The id of the request to abort.&quot;,&quot; * @param {boolean=} opt_force If true, remove the id now so it can be reused.&quot;,&quot; *     No events are fired and the callback is not called when forced.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.abort = function(id, opt_force) {&quot;,&quot;  var request = this.requests_.get(id);&quot;,&quot;  if (request) {&quot;,&quot;    var xhrIo = request.xhrIo;&quot;,&quot;    request.setAborted(true);&quot;,&quot;    if (opt_force) {&quot;,&quot;      if (xhrIo) {&quot;,&quot;        // We remove listeners to make sure nothing gets called if a new request&quot;,&quot;        // with the same id is made.&quot;,&quot;        this.removeXhrListener_(xhrIo, request.getXhrEventCallback());&quot;,&quot;        goog.events.listenOnce(xhrIo, goog.net.EventType.READY, function() {&quot;,&quot;          this.xhrPool_.releaseObject(xhrIo);&quot;,&quot;        }, false, this);&quot;,&quot;      }&quot;,&quot;      this.requests_.remove(id);&quot;,&quot;    }&quot;,&quot;    if (xhrIo) {&quot;,&quot;      xhrIo.abort();&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Handles when an XhrIo object becomes available. Sets up the events, fires&quot;,&quot; * the READY event, and starts the process to send the request.&quot;,&quot; * @param {string} id The id of the request the XhrIo is for.&quot;,&quot; * @param {goog.net.XhrIo} xhrIo The available XhrIo object.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.handleAvailableXhr_ = function(id, xhrIo) {&quot;,&quot;  var request = this.requests_.get(id);&quot;,&quot;  // Make sure the request doesn&#39;t already have an XhrIo attached. This can&quot;,&quot;  // happen if a forced abort occurs before an XhrIo is available, and a new&quot;,&quot;  // request with the same id is made.&quot;,&quot;  if (request &amp;&amp; !request.xhrIo) {&quot;,&quot;    this.addXhrListener_(xhrIo, request.getXhrEventCallback());&quot;,null,&quot;    // Set properties for the XhrIo.&quot;,&quot;    xhrIo.setTimeoutInterval(this.timeoutInterval_);&quot;,&quot;    xhrIo.setResponseType(request.getResponseType());&quot;,&quot;    xhrIo.setWithCredentials(request.getWithCredentials());&quot;,null,&quot;    // Add a reference to the XhrIo object to the request.&quot;,&quot;    request.xhrIo = xhrIo;&quot;,null,&quot;    // Notify the listeners.&quot;,&quot;    this.dispatchEvent(&quot;,&quot;        new goog.net.XhrManager.Event(&quot;,&quot;            goog.net.EventType.READY, this, id, xhrIo));&quot;,null,&quot;    // Send the request.&quot;,&quot;    this.retry_(id, xhrIo);&quot;,null,&quot;    // If the request was aborted before it got an XhrIo object, abort it now.&quot;,&quot;    if (request.getAborted()) {&quot;,&quot;      xhrIo.abort();&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    // If the request has an XhrIo object already, or no request exists, just&quot;,&quot;    // return the XhrIo back to the pool.&quot;,&quot;    this.xhrPool_.releaseObject(xhrIo);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Handles all events fired by the XhrIo object for a given request.&quot;,&quot; * @param {string} id The id of the request.&quot;,&quot; * @param {goog.events.Event} e The event.&quot;,&quot; * @return {Object} The return value from the handler, if any.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.handleEvent_ = function(id, e) {&quot;,&quot;  var xhrIo = /** @type {goog.net.XhrIo} */ (e.target);&quot;,&quot;  switch (e.type) {&quot;,&quot;    case goog.net.EventType.READY:&quot;,&quot;      this.retry_(id, xhrIo);&quot;,&quot;      break;&quot;,null,&quot;    case goog.net.EventType.COMPLETE:&quot;,&quot;      return this.handleComplete_(id, xhrIo, e);&quot;,null,&quot;    case goog.net.EventType.SUCCESS:&quot;,&quot;      this.handleSuccess_(id, xhrIo);&quot;,&quot;      break;&quot;,null,&quot;    // A timeout is handled like an error.&quot;,&quot;    case goog.net.EventType.TIMEOUT:&quot;,&quot;    case goog.net.EventType.ERROR:&quot;,&quot;      this.handleError_(id, xhrIo);&quot;,&quot;      break;&quot;,null,&quot;    case goog.net.EventType.ABORT:&quot;,&quot;      this.handleAbort_(id, xhrIo);&quot;,&quot;      break;&quot;,&quot;  }&quot;,&quot;  return null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Attempts to retry the given request. If the request has already attempted&quot;,&quot; * the maximum number of retries, then it removes the request and releases&quot;,&quot; * the XhrIo object back into the pool.&quot;,&quot; * @param {string} id The id of the request.&quot;,&quot; * @param {goog.net.XhrIo} xhrIo The XhrIo object.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.retry_ = function(id, xhrIo) {&quot;,&quot;  var request = this.requests_.get(id);&quot;,null,&quot;  // If the request has not completed and it is below its max. retries.&quot;,&quot;  if (request &amp;&amp; !request.getCompleted() &amp;&amp; !request.hasReachedMaxRetries()) {&quot;,&quot;    request.increaseAttemptCount();&quot;,&quot;    xhrIo.send(&quot;,&quot;        request.getUrl(), request.getMethod(), request.getContent(),&quot;,&quot;        request.getHeaders());&quot;,&quot;  } else {&quot;,&quot;    if (request) {&quot;,&quot;      // Remove the events on the XhrIo objects.&quot;,&quot;      this.removeXhrListener_(xhrIo, request.getXhrEventCallback());&quot;,null,&quot;      // Remove the request.&quot;,&quot;      this.requests_.remove(id);&quot;,&quot;    }&quot;,&quot;    // Release the XhrIo object back into the pool.&quot;,&quot;    this.xhrPool_.releaseObject(xhrIo);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Handles the complete of a request. Dispatches the COMPLETE event and sets the&quot;,&quot; * the request as completed if the request has succeeded, or is done retrying.&quot;,&quot; * @param {string} id The id of the request.&quot;,&quot; * @param {goog.net.XhrIo} xhrIo The XhrIo object.&quot;,&quot; * @param {goog.events.Event} e The original event.&quot;,&quot; * @return {Object} The return value from the callback, if any.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.handleComplete_ = function(id, xhrIo, e) {&quot;,&quot;  // Only if the request is done processing should a COMPLETE event be fired.&quot;,&quot;  var request = this.requests_.get(id);&quot;,&quot;  if (xhrIo.getLastErrorCode() == goog.net.ErrorCode.ABORT ||&quot;,&quot;      xhrIo.isSuccess() || request.hasReachedMaxRetries()) {&quot;,&quot;    this.dispatchEvent(&quot;,&quot;        new goog.net.XhrManager.Event(&quot;,&quot;            goog.net.EventType.COMPLETE, this, id, xhrIo));&quot;,null,&quot;    // If the request exists, we mark it as completed and call the callback&quot;,&quot;    if (request) {&quot;,&quot;      request.setCompleted(true);&quot;,&quot;      // Call the complete callback as if it was set as a COMPLETE event on the&quot;,&quot;      // XhrIo directly.&quot;,&quot;      if (request.getCompleteCallback()) {&quot;,&quot;        return request.getCompleteCallback().call(xhrIo, e);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Handles the abort of an underlying XhrIo object.&quot;,&quot; * @param {string} id The id of the request.&quot;,&quot; * @param {goog.net.XhrIo} xhrIo The XhrIo object.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.handleAbort_ = function(id, xhrIo) {&quot;,&quot;  // Fire event.&quot;,&quot;  // NOTE: The complete event should always be fired before the abort event, so&quot;,&quot;  // the bulk of the work is done in handleComplete.&quot;,&quot;  this.dispatchEvent(&quot;,&quot;      new goog.net.XhrManager.Event(goog.net.EventType.ABORT, this, id, xhrIo));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Handles the success of a request. Dispatches the SUCCESS event and sets the&quot;,&quot; * the request as completed.&quot;,&quot; * @param {string} id The id of the request.&quot;,&quot; * @param {goog.net.XhrIo} xhrIo The XhrIo object.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.handleSuccess_ = function(id, xhrIo) {&quot;,&quot;  // Fire event.&quot;,&quot;  // NOTE: We don&#39;t release the XhrIo object from the pool here.&quot;,&quot;  // It is released in the retry method, when we know it is back in the&quot;,&quot;  // ready state.&quot;,&quot;  this.dispatchEvent(&quot;,&quot;      new goog.net.XhrManager.Event(&quot;,&quot;          goog.net.EventType.SUCCESS, this, id, xhrIo));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Handles the error of a request. If the request has not reach its maximum&quot;,&quot; * number of retries, then it lets the request retry naturally (will let the&quot;,&quot; * request hit the READY state). Else, it dispatches the ERROR event.&quot;,&quot; * @param {string} id The id of the request.&quot;,&quot; * @param {goog.net.XhrIo} xhrIo The XhrIo object.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.handleError_ = function(id, xhrIo) {&quot;,&quot;  var request = this.requests_.get(id);&quot;,null,&quot;  // If the maximum number of retries has been reached.&quot;,&quot;  if (request.hasReachedMaxRetries()) {&quot;,&quot;    // Fire event.&quot;,&quot;    // NOTE: We don&#39;t release the XhrIo object from the pool here.&quot;,&quot;    // It is released in the retry method, when we know it is back in the&quot;,&quot;    // ready state.&quot;,&quot;    this.dispatchEvent(&quot;,&quot;        new goog.net.XhrManager.Event(&quot;,&quot;            goog.net.EventType.ERROR, this, id, xhrIo));&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Remove listeners for XHR events on an XhrIo object.&quot;,&quot; * @param {goog.net.XhrIo} xhrIo The object to stop listenening to events on.&quot;,&quot; * @param {Function} func The callback to remove from event handling.&quot;,&quot; * @param {string|Array&lt;string&gt;=} opt_types Event types to remove listeners&quot;,&quot; *     for. Defaults to XHR_EVENT_TYPES_.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.removeXhrListener_ = function(&quot;,&quot;    xhrIo, func, opt_types) {&quot;,&quot;  var types = opt_types || goog.net.XhrManager.XHR_EVENT_TYPES_;&quot;,&quot;  this.eventHandler_.unlisten(xhrIo, types, func);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds a listener for XHR events on an XhrIo object.&quot;,&quot; * @param {goog.net.XhrIo} xhrIo The object listen to events on.&quot;,&quot; * @param {Function} func The callback when the event occurs.&quot;,&quot; * @param {string|Array&lt;string&gt;=} opt_types Event types to attach listeners to.&quot;,&quot; *     Defaults to XHR_EVENT_TYPES_.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.prototype.addXhrListener_ = function(&quot;,&quot;    xhrIo, func, opt_types) {&quot;,&quot;  var types = opt_types || goog.net.XhrManager.XHR_EVENT_TYPES_;&quot;,&quot;  this.eventHandler_.listen(xhrIo, types, func);&quot;,&quot;};&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.net.XhrManager.prototype.disposeInternal = function() {&quot;,&quot;  goog.net.XhrManager.superClass_.disposeInternal.call(this);&quot;,null,&quot;  this.xhrPool_.dispose();&quot;,&quot;  this.xhrPool_ = null;&quot;,null,&quot;  this.eventHandler_.dispose();&quot;,&quot;  this.eventHandler_ = null;&quot;,null,&quot;  this.requests_.clear();&quot;,&quot;  this.requests_ = null;&quot;,&quot;};&quot;,null,null,null,&quot;/**&quot;,&quot; * An event dispatched by XhrManager.&quot;,&quot; *&quot;,&quot; * @param {goog.net.EventType} type Event Type.&quot;,&quot; * @param {goog.net.XhrManager} target Reference to the object that is the&quot;,&quot; *     target of this event.&quot;,&quot; * @param {string} id The id of the request this event is for.&quot;,&quot; * @param {goog.net.XhrIo} xhrIo The XhrIo object of the request.&quot;,&quot; * @constructor&quot;,&quot; * @extends {goog.events.Event}&quot;,&quot; * @final&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Event = function(type, target, id, xhrIo) {&quot;,&quot;  goog.events.Event.call(this, type, target);&quot;,null,&quot;  /**&quot;,&quot;   * The id of the request this event is for.&quot;,&quot;   * @type {string}&quot;,&quot;   */&quot;,&quot;  this.id = id;&quot;,null,&quot;  /**&quot;,&quot;   * The XhrIo object of the request.&quot;,&quot;   * @type {goog.net.XhrIo}&quot;,&quot;   */&quot;,&quot;  this.xhrIo = xhrIo;&quot;,&quot;};&quot;,&quot;goog.inherits(goog.net.XhrManager.Event, goog.events.Event);&quot;,null,null,null,&quot;/**&quot;,&quot; * An encapsulation of everything needed to make a Xhr request.&quot;,&quot; * NOTE: This is used internal to the XhrManager.&quot;,&quot; *&quot;,&quot; * @param {string} url Uri to make the request too.&quot;,&quot; * @param {Function} xhrEventCallback Callback attached to the events of the&quot;,&quot; *     XhrIo object of the request.&quot;,&quot; * @param {string=} opt_method Send method, default: GET.&quot;,&quot; * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}&quot;,&quot; *     opt_content Post data.&quot;,&quot; * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the&quot;,&quot; *     request.&quot;,&quot; * @param {Function=} opt_callback Callback function for when request is&quot;,&quot; *     complete. NOTE: Only 1 callback supported across all events.&quot;,&quot; * @param {number=} opt_maxRetries The maximum number of times the request&quot;,&quot; *     should be retried (Default: 1).&quot;,&quot; * @param {goog.net.XhrIo.ResponseType=} opt_responseType The response type of&quot;,&quot; *     this request; defaults to goog.net.XhrIo.ResponseType.DEFAULT.&quot;,&quot; * @param {boolean=} opt_withCredentials Add credentials to this request,&quot;,&quot; *     default: false.&quot;,&quot; *&quot;,&quot; * @constructor&quot;,&quot; * @final&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request = function(&quot;,&quot;    url, xhrEventCallback, opt_method, opt_content, opt_headers, opt_callback,&quot;,&quot;    opt_maxRetries, opt_responseType, opt_withCredentials) {&quot;,&quot;  /**&quot;,&quot;   * Uri to make the request too.&quot;,&quot;   * @type {string}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.url_ = url;&quot;,null,&quot;  /**&quot;,&quot;   * Send method.&quot;,&quot;   * @type {string}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.method_ = opt_method || &#39;GET&#39;;&quot;,null,&quot;  /**&quot;,&quot;   * Post data.&quot;,&quot;   * @type {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string|undefined}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.content_ = opt_content;&quot;,null,&quot;  /**&quot;,&quot;   *  Map of headers&quot;,&quot;   * @type {Object|goog.structs.Map|null}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.headers_ = opt_headers || null;&quot;,null,&quot;  /**&quot;,&quot;   * The maximum number of times the request should be retried.&quot;,&quot;   * @type {number}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.maxRetries_ = goog.isDef(opt_maxRetries) ? opt_maxRetries : 1;&quot;,null,&quot;  /**&quot;,&quot;   * The number of attempts  so far.&quot;,&quot;   * @type {number}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.attemptCount_ = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Whether the request has been completed.&quot;,&quot;   * @type {boolean}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.completed_ = false;&quot;,null,&quot;  /**&quot;,&quot;   * Whether the request has been aborted.&quot;,&quot;   * @type {boolean}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.aborted_ = false;&quot;,null,&quot;  /**&quot;,&quot;   * Callback attached to the events of the XhrIo object.&quot;,&quot;   * @type {Function}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.xhrEventCallback_ = xhrEventCallback;&quot;,null,&quot;  /**&quot;,&quot;   * Callback function called when request is complete.&quot;,&quot;   * @type {Function|undefined}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.completeCallback_ = opt_callback;&quot;,null,&quot;  /**&quot;,&quot;   * A response type to set on this.xhrIo when it&#39;s populated.&quot;,&quot;   * @type {!goog.net.XhrIo.ResponseType}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.responseType_ = opt_responseType || goog.net.XhrIo.ResponseType.DEFAULT;&quot;,null,&quot;  /**&quot;,&quot;   * Send credentials with this request, or not.&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.withCredentials_ = !!opt_withCredentials;&quot;,null,&quot;  /**&quot;,&quot;   * The XhrIo instance handling this request. Set in handleAvailableXhr.&quot;,&quot;   * @type {goog.net.XhrIo}&quot;,&quot;   */&quot;,&quot;  this.xhrIo = null;&quot;,null,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the uri.&quot;,&quot; * @return {string} The uri to make the request to.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.getUrl = function() {&quot;,&quot;  return this.url_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the send method.&quot;,&quot; * @return {string} The send method.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.getMethod = function() {&quot;,&quot;  return this.method_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the post data.&quot;,&quot; * @return {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string|undefined}&quot;,&quot; *     The post data.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.getContent = function() {&quot;,&quot;  return this.content_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the map of headers.&quot;,&quot; * @return {Object|goog.structs.Map} The map of headers.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.getHeaders = function() {&quot;,&quot;  return this.headers_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the withCredentials flag.&quot;,&quot; * @return {boolean} Add credentials, or not.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.getWithCredentials = function() {&quot;,&quot;  return this.withCredentials_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the maximum number of times the request should be retried.&quot;,&quot; * @return {number} The maximum number of times the request should be retried.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.getMaxRetries = function() {&quot;,&quot;  return this.maxRetries_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the number of attempts so far.&quot;,&quot; * @return {number} The number of attempts so far.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.getAttemptCount = function() {&quot;,&quot;  return this.attemptCount_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Increases the number of attempts so far.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.increaseAttemptCount = function() {&quot;,&quot;  this.attemptCount_++;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns whether the request has reached the maximum number of retries.&quot;,&quot; * @return {boolean} Whether the request has reached the maximum number of&quot;,&quot; *     retries.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.hasReachedMaxRetries = function() {&quot;,&quot;  return this.attemptCount_ &gt; this.maxRetries_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the completed status.&quot;,&quot; * @param {boolean} complete The completed status.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.setCompleted = function(complete) {&quot;,&quot;  this.completed_ = complete;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the completed status.&quot;,&quot; * @return {boolean} The completed status.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.getCompleted = function() {&quot;,&quot;  return this.completed_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the aborted status.&quot;,&quot; * @param {boolean} aborted True if the request was aborted, otherwise False.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.setAborted = function(aborted) {&quot;,&quot;  this.aborted_ = aborted;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the aborted status.&quot;,&quot; * @return {boolean} True if request was aborted, otherwise False.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.getAborted = function() {&quot;,&quot;  return this.aborted_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the callback attached to the events of the XhrIo object.&quot;,&quot; * @return {Function} The callback attached to the events of the&quot;,&quot; *     XhrIo object.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.getXhrEventCallback = function() {&quot;,&quot;  return this.xhrEventCallback_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the callback for when the request is complete.&quot;,&quot; * @return {Function|undefined} The callback for when the request is complete.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.getCompleteCallback = function() {&quot;,&quot;  return this.completeCallback_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the response type that will be set on this request&#39;s XhrIo when it&#39;s&quot;,&quot; * available.&quot;,&quot; * @return {!goog.net.XhrIo.ResponseType} The response type to be set&quot;,&quot; *     when an XhrIo becomes available to this request.&quot;,&quot; */&quot;,&quot;goog.net.XhrManager.Request.prototype.getResponseType = function() {&quot;,&quot;  return this.responseType_;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>