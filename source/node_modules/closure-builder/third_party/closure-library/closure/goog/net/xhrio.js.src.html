<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>xhrio.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;xhrio.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/net/xhrio.js&quot;,[&quot;// Copyright 2006 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Wrapper class for handling XmlHttpRequests.&quot;,&quot; *&quot;,&quot; * One off requests can be sent through goog.net.XhrIo.send() or an&quot;,&quot; * instance can be created to send multiple requests.  Each request uses its&quot;,&quot; * own XmlHttpRequest object and handles clearing of the event callback to&quot;,&quot; * ensure no leaks.&quot;,&quot; *&quot;,&quot; * XhrIo is event based, it dispatches events on success, failure, finishing,&quot;,&quot; * ready-state change, or progress (download and upload).&quot;,&quot; *&quot;,&quot; * The ready-state or timeout event fires first, followed by&quot;,&quot; * a generic completed event. Then the abort, error, or success event&quot;,&quot; * is fired as appropriate. Progress events are fired as they are&quot;,&quot; * received. Lastly, the ready event will fire to indicate that the&quot;,&quot; * object may be used to make another request.&quot;,&quot; *&quot;,&quot; * The error event may also be called before completed and&quot;,&quot; * ready-state-change if the XmlHttpRequest.open() or .send() methods throw.&quot;,&quot; *&quot;,&quot; * This class does not support multiple requests, queuing, or prioritization.&quot;,&quot; *&quot;,&quot; * When progress events are supported by the browser, and progress is&quot;,&quot; * enabled via .setProgressEventsEnabled(true), the&quot;,&quot; * goog.net.EventType.PROGRESS event will be the re-dispatched browser&quot;,&quot; * progress event. Additionally, a DOWNLOAD_PROGRESS or UPLOAD_PROGRESS event&quot;,&quot; * will be fired for download and upload progress respectively.&quot;,&quot; *&quot;,&quot; */&quot;,null,null,&quot;goog.provide(&#39;goog.net.XhrIo&#39;);&quot;,&quot;goog.provide(&#39;goog.net.XhrIo.ResponseType&#39;);&quot;,null,&quot;goog.require(&#39;goog.Timer&#39;);&quot;,&quot;goog.require(&#39;goog.array&#39;);&quot;,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;goog.debug.entryPointRegistry&#39;);&quot;,&quot;goog.require(&#39;goog.events.EventTarget&#39;);&quot;,&quot;goog.require(&#39;goog.json.hybrid&#39;);&quot;,&quot;goog.require(&#39;goog.log&#39;);&quot;,&quot;goog.require(&#39;goog.net.ErrorCode&#39;);&quot;,&quot;goog.require(&#39;goog.net.EventType&#39;);&quot;,&quot;goog.require(&#39;goog.net.HttpStatus&#39;);&quot;,&quot;goog.require(&#39;goog.net.XmlHttp&#39;);&quot;,&quot;goog.require(&#39;goog.string&#39;);&quot;,&quot;goog.require(&#39;goog.structs&#39;);&quot;,&quot;goog.require(&#39;goog.structs.Map&#39;);&quot;,&quot;goog.require(&#39;goog.uri.utils&#39;);&quot;,&quot;goog.require(&#39;goog.userAgent&#39;);&quot;,null,&quot;goog.forwardDeclare(&#39;goog.Uri&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * Basic class for handling XMLHttpRequests.&quot;,&quot; * @param {goog.net.XmlHttpFactory=} opt_xmlHttpFactory Factory to use when&quot;,&quot; *     creating XMLHttpRequest objects.&quot;,&quot; * @constructor&quot;,&quot; * @extends {goog.events.EventTarget}&quot;,&quot; */&quot;,&quot;goog.net.XhrIo = function(opt_xmlHttpFactory) {&quot;,&quot;  goog.net.XhrIo.base(this, &#39;constructor&#39;);&quot;,null,&quot;  /**&quot;,&quot;   * Map of default headers to add to every request, use:&quot;,&quot;   * XhrIo.headers.set(name, value)&quot;,&quot;   * @type {!goog.structs.Map}&quot;,&quot;   */&quot;,&quot;  this.headers = new goog.structs.Map();&quot;,null,&quot;  /**&quot;,&quot;   * Optional XmlHttpFactory&quot;,&quot;   * @private {goog.net.XmlHttpFactory}&quot;,&quot;   */&quot;,&quot;  this.xmlHttpFactory_ = opt_xmlHttpFactory || null;&quot;,null,&quot;  /**&quot;,&quot;   * Whether XMLHttpRequest is active.  A request is active from the time send()&quot;,&quot;   * is called until onReadyStateChange() is complete, or error() or abort()&quot;,&quot;   * is called.&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.active_ = false;&quot;,null,&quot;  /**&quot;,&quot;   * The XMLHttpRequest object that is being used for the transfer.&quot;,&quot;   * @private {?goog.net.XhrLike.OrNative}&quot;,&quot;   */&quot;,&quot;  this.xhr_ = null;&quot;,null,&quot;  /**&quot;,&quot;   * The options to use with the current XMLHttpRequest object.&quot;,&quot;   * @private {Object}&quot;,&quot;   */&quot;,&quot;  this.xhrOptions_ = null;&quot;,null,&quot;  /**&quot;,&quot;   * Last URL that was requested.&quot;,&quot;   * @private {string|goog.Uri}&quot;,&quot;   */&quot;,&quot;  this.lastUri_ = &#39;&#39;;&quot;,null,&quot;  /**&quot;,&quot;   * Method for the last request.&quot;,&quot;   * @private {string}&quot;,&quot;   */&quot;,&quot;  this.lastMethod_ = &#39;&#39;;&quot;,null,&quot;  /**&quot;,&quot;   * Last error code.&quot;,&quot;   * @private {!goog.net.ErrorCode}&quot;,&quot;   */&quot;,&quot;  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;&quot;,null,&quot;  /**&quot;,&quot;   * Last error message.&quot;,&quot;   * @private {Error|string}&quot;,&quot;   */&quot;,&quot;  this.lastError_ = &#39;&#39;;&quot;,null,&quot;  /**&quot;,&quot;   * Used to ensure that we don&#39;t dispatch an multiple ERROR events. This can&quot;,&quot;   * happen in IE when it does a synchronous load and one error is handled in&quot;,&quot;   * the ready statte change and one is handled due to send() throwing an&quot;,&quot;   * exception.&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.errorDispatched_ = false;&quot;,null,&quot;  /**&quot;,&quot;   * Used to make sure we don&#39;t fire the complete event from inside a send call.&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.inSend_ = false;&quot;,null,&quot;  /**&quot;,&quot;   * Used in determining if a call to {@link #onReadyStateChange_} is from&quot;,&quot;   * within a call to this.xhr_.open.&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.inOpen_ = false;&quot;,null,&quot;  /**&quot;,&quot;   * Used in determining if a call to {@link #onReadyStateChange_} is from&quot;,&quot;   * within a call to this.xhr_.abort.&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.inAbort_ = false;&quot;,null,&quot;  /**&quot;,&quot;   * Number of milliseconds after which an incomplete request will be aborted&quot;,&quot;   * and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no timeout&quot;,&quot;   * is set.&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.timeoutInterval_ = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Timer to track request timeout.&quot;,&quot;   * @private {?number}&quot;,&quot;   */&quot;,&quot;  this.timeoutId_ = null;&quot;,null,&quot;  /**&quot;,&quot;   * The requested type for the response. The empty string means use the default&quot;,&quot;   * XHR behavior.&quot;,&quot;   * @private {goog.net.XhrIo.ResponseType}&quot;,&quot;   */&quot;,&quot;  this.responseType_ = goog.net.XhrIo.ResponseType.DEFAULT;&quot;,null,&quot;  /**&quot;,&quot;   * Whether a \&quot;credentialed\&quot; request is to be sent (one that is aware of&quot;,&quot;   * cookies and authentication). This is applicable only for cross-domain&quot;,&quot;   * requests and more recent browsers that support this part of the HTTP Access&quot;,&quot;   * Control standard.&quot;,&quot;   *&quot;,&quot;   * @see http://www.w3.org/TR/XMLHttpRequest/#the-withcredentials-attribute&quot;,&quot;   *&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.withCredentials_ = false;&quot;,null,&quot;  /**&quot;,&quot;   * Whether progress events are enabled for this request. This is&quot;,&quot;   * disabled by default because setting a progress event handler&quot;,&quot;   * causes pre-flight OPTIONS requests to be sent for CORS requests,&quot;,&quot;   * even in cases where a pre-flight request would not otherwise be&quot;,&quot;   * sent.&quot;,&quot;   *&quot;,&quot;   * @see http://xhr.spec.whatwg.org/#security-considerations&quot;,&quot;   *&quot;,&quot;   * Note that this can cause problems for Firefox 22 and below, as an&quot;,&quot;   * older \&quot;LSProgressEvent\&quot; will be dispatched by the browser. That&quot;,&quot;   * progress event is no longer supported, and can lead to failures,&quot;,&quot;   * including throwing exceptions.&quot;,&quot;   *&quot;,&quot;   * @see http://bugzilla.mozilla.org/show_bug.cgi?id=845631&quot;,&quot;   * @see b/23469793&quot;,&quot;   *&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.progressEventsEnabled_ = false;&quot;,null,&quot;  /**&quot;,&quot;   * True if we can use XMLHttpRequest&#39;s timeout directly.&quot;,&quot;   * @private {boolean}&quot;,&quot;   */&quot;,&quot;  this.useXhr2Timeout_ = false;&quot;,&quot;};&quot;,&quot;goog.inherits(goog.net.XhrIo, goog.events.EventTarget);&quot;,null,null,&quot;/**&quot;,&quot; * Response types that may be requested for XMLHttpRequests.&quot;,&quot; * @enum {string}&quot;,&quot; * @see http://www.w3.org/TR/XMLHttpRequest/#the-responsetype-attribute&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.ResponseType = {&quot;,&quot;  DEFAULT: &#39;&#39;,&quot;,&quot;  TEXT: &#39;text&#39;,&quot;,&quot;  DOCUMENT: &#39;document&#39;,&quot;,&quot;  // Not supported as of Chrome 10.0.612.1 dev&quot;,&quot;  BLOB: &#39;blob&#39;,&quot;,&quot;  ARRAY_BUFFER: &#39;arraybuffer&#39;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * A reference to the XhrIo logger&quot;,&quot; * @private {?goog.log.Logger}&quot;,&quot; * @const&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.logger_ = goog.log.getLogger(&#39;goog.net.XhrIo&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * The Content-Type HTTP header name&quot;,&quot; * @type {string}&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.CONTENT_TYPE_HEADER = &#39;Content-Type&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * The Content-Transfer-Encoding HTTP header name&quot;,&quot; * @type {string}&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.CONTENT_TRANSFER_ENCODING = &#39;Content-Transfer-Encoding&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * The pattern matching the &#39;http&#39; and &#39;https&#39; URI schemes&quot;,&quot; * @type {!RegExp}&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.HTTP_SCHEME_PATTERN = /^https?$/i;&quot;,null,null,&quot;/**&quot;,&quot; * The methods that typically come along with form data.  We set different&quot;,&quot; * headers depending on whether the HTTP action is one of these.&quot;,&quot; * @type {!Array&lt;string&gt;}&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.METHODS_WITH_FORM_DATA = [&#39;POST&#39;, &#39;PUT&#39;];&quot;,null,null,&quot;/**&quot;,&quot; * The Content-Type HTTP header value for a url-encoded form&quot;,&quot; * @type {string}&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.FORM_CONTENT_TYPE =&quot;,&quot;    &#39;application/x-www-form-urlencoded;charset=utf-8&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * The XMLHttpRequest Level two timeout delay ms property name.&quot;,&quot; *&quot;,&quot; * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute&quot;,&quot; *&quot;,&quot; * @private {string}&quot;,&quot; * @const&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.XHR2_TIMEOUT_ = &#39;timeout&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * The XMLHttpRequest Level two ontimeout handler property name.&quot;,&quot; *&quot;,&quot; * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute&quot;,&quot; *&quot;,&quot; * @private {string}&quot;,&quot; * @const&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.XHR2_ON_TIMEOUT_ = &#39;ontimeout&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * All non-disposed instances of goog.net.XhrIo created&quot;,&quot; * by {@link goog.net.XhrIo.send} are in this Array.&quot;,&quot; * @see goog.net.XhrIo.cleanup&quot;,&quot; * @private {!Array&lt;!goog.net.XhrIo&gt;}&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.sendInstances_ = [];&quot;,null,null,&quot;/**&quot;,&quot; * Static send that creates a short lived instance of XhrIo to send the&quot;,&quot; * request.&quot;,&quot; * @see goog.net.XhrIo.cleanup&quot;,&quot; * @param {string|goog.Uri} url Uri to make request to.&quot;,&quot; * @param {?function(this:goog.net.XhrIo, ?)=} opt_callback Callback function&quot;,&quot; *     for when request is complete.&quot;,&quot; * @param {string=} opt_method Send method, default: GET.&quot;,&quot; * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}&quot;,&quot; *     opt_content Body data.&quot;,&quot; * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the&quot;,&quot; *     request.&quot;,&quot; * @param {number=} opt_timeoutInterval Number of milliseconds after which an&quot;,&quot; *     incomplete request will be aborted; 0 means no timeout is set.&quot;,&quot; * @param {boolean=} opt_withCredentials Whether to send credentials with the&quot;,&quot; *     request. Default to false. See {@link goog.net.XhrIo#setWithCredentials}.&quot;,&quot; * @return {!goog.net.XhrIo} The sent XhrIo.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.send = function(&quot;,&quot;    url, opt_callback, opt_method, opt_content, opt_headers,&quot;,&quot;    opt_timeoutInterval, opt_withCredentials) {&quot;,&quot;  var x = new goog.net.XhrIo();&quot;,&quot;  goog.net.XhrIo.sendInstances_.push(x);&quot;,&quot;  if (opt_callback) {&quot;,&quot;    x.listen(goog.net.EventType.COMPLETE, opt_callback);&quot;,&quot;  }&quot;,&quot;  x.listenOnce(goog.net.EventType.READY, x.cleanupSend_);&quot;,&quot;  if (opt_timeoutInterval) {&quot;,&quot;    x.setTimeoutInterval(opt_timeoutInterval);&quot;,&quot;  }&quot;,&quot;  if (opt_withCredentials) {&quot;,&quot;    x.setWithCredentials(opt_withCredentials);&quot;,&quot;  }&quot;,&quot;  x.send(url, opt_method, opt_content, opt_headers);&quot;,&quot;  return x;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Disposes all non-disposed instances of goog.net.XhrIo created by&quot;,&quot; * {@link goog.net.XhrIo.send}.&quot;,&quot; * {@link goog.net.XhrIo.send} cleans up the goog.net.XhrIo instance&quot;,&quot; * it creates when the request completes or fails.  However, if&quot;,&quot; * the request never completes, then the goog.net.XhrIo is not disposed.&quot;,&quot; * This can occur if the window is unloaded before the request completes.&quot;,&quot; * We could have {@link goog.net.XhrIo.send} return the goog.net.XhrIo&quot;,&quot; * it creates and make the client of {@link goog.net.XhrIo.send} be&quot;,&quot; * responsible for disposing it in this case.  However, this makes things&quot;,&quot; * significantly more complicated for the client, and the whole point&quot;,&quot; * of {@link goog.net.XhrIo.send} is that it&#39;s simple and easy to use.&quot;,&quot; * Clients of {@link goog.net.XhrIo.send} should call&quot;,&quot; * {@link goog.net.XhrIo.cleanup} when doing final&quot;,&quot; * cleanup on window unload.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.cleanup = function() {&quot;,&quot;  var instances = goog.net.XhrIo.sendInstances_;&quot;,&quot;  while (instances.length) {&quot;,&quot;    instances.pop().dispose();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Installs exception protection for all entry point introduced by&quot;,&quot; * goog.net.XhrIo instances which are not protected by&quot;,&quot; * {@link goog.debug.ErrorHandler#protectWindowSetTimeout},&quot;,&quot; * {@link goog.debug.ErrorHandler#protectWindowSetInterval}, or&quot;,&quot; * {@link goog.events.protectBrowserEventEntryPoint}.&quot;,&quot; *&quot;,&quot; * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to&quot;,&quot; *     protect the entry point(s).&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.protectEntryPoints = function(errorHandler) {&quot;,&quot;  goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =&quot;,&quot;      errorHandler.protectEntryPoint(&quot;,&quot;          goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Disposes of the specified goog.net.XhrIo created by&quot;,&quot; * {@link goog.net.XhrIo.send} and removes it from&quot;,&quot; * {@link goog.net.XhrIo.pendingStaticSendInstances_}.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.cleanupSend_ = function() {&quot;,&quot;  this.dispose();&quot;,&quot;  goog.array.remove(goog.net.XhrIo.sendInstances_, this);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the number of milliseconds after which an incomplete request will be&quot;,&quot; * aborted, or 0 if no timeout is set.&quot;,&quot; * @return {number} Timeout interval in milliseconds.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getTimeoutInterval = function() {&quot;,&quot;  return this.timeoutInterval_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the number of milliseconds after which an incomplete request will be&quot;,&quot; * aborted and a {@link goog.net.EventType.TIMEOUT} event raised; 0 means no&quot;,&quot; * timeout is set.&quot;,&quot; * @param {number} ms Timeout interval in milliseconds; 0 means none.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.setTimeoutInterval = function(ms) {&quot;,&quot;  this.timeoutInterval_ = Math.max(0, ms);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the desired type for the response. At time of writing, this is only&quot;,&quot; * supported in very recent versions of WebKit (10.0.612.1 dev and later).&quot;,&quot; *&quot;,&quot; * If this is used, the response may only be accessed via {@link #getResponse}.&quot;,&quot; *&quot;,&quot; * @param {goog.net.XhrIo.ResponseType} type The desired type for the response.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.setResponseType = function(type) {&quot;,&quot;  this.responseType_ = type;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the desired type for the response.&quot;,&quot; * @return {goog.net.XhrIo.ResponseType} The desired type for the response.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getResponseType = function() {&quot;,&quot;  return this.responseType_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets whether a \&quot;credentialed\&quot; request that is aware of cookie and&quot;,&quot; * authentication information should be made. This option is only supported by&quot;,&quot; * browsers that support HTTP Access Control. As of this writing, this option&quot;,&quot; * is not supported in IE.&quot;,&quot; *&quot;,&quot; * @param {boolean} withCredentials Whether this should be a \&quot;credentialed\&quot;&quot;,&quot; *     request.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.setWithCredentials = function(withCredentials) {&quot;,&quot;  this.withCredentials_ = withCredentials;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets whether a \&quot;credentialed\&quot; request is to be sent.&quot;,&quot; * @return {boolean} The desired type for the response.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getWithCredentials = function() {&quot;,&quot;  return this.withCredentials_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets whether progress events are enabled for this request. Note&quot;,&quot; * that progress events require pre-flight OPTIONS request handling&quot;,&quot; * for CORS requests, and may cause trouble with older browsers. See&quot;,&quot; * progressEventsEnabled_ for details.&quot;,&quot; * @param {boolean} enabled Whether progress events should be enabled.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.setProgressEventsEnabled = function(enabled) {&quot;,&quot;  this.progressEventsEnabled_ = enabled;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets whether progress events are enabled.&quot;,&quot; * @return {boolean} Whether progress events are enabled for this request.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getProgressEventsEnabled = function() {&quot;,&quot;  return this.progressEventsEnabled_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Instance send that actually uses XMLHttpRequest to make a server call.&quot;,&quot; * @param {string|goog.Uri} url Uri to make request to.&quot;,&quot; * @param {string=} opt_method Send method, default: GET.&quot;,&quot; * @param {ArrayBuffer|ArrayBufferView|Blob|Document|FormData|string=}&quot;,&quot; *     opt_content Body data.&quot;,&quot; * @param {Object|goog.structs.Map=} opt_headers Map of headers to add to the&quot;,&quot; *     request.&quot;,&quot; * @suppress {deprecated} Use deprecated goog.structs.forEach to allow different&quot;,&quot; * types of parameters for opt_headers.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.send = function(&quot;,&quot;    url, opt_method, opt_content, opt_headers) {&quot;,&quot;  if (this.xhr_) {&quot;,&quot;    throw new Error(&quot;,&quot;        &#39;[goog.net.XhrIo] Object is active with another request=&#39; +&quot;,&quot;        this.lastUri_ + &#39;; newUri=&#39; + url);&quot;,&quot;  }&quot;,null,&quot;  var method = opt_method ? opt_method.toUpperCase() : &#39;GET&#39;;&quot;,null,&quot;  this.lastUri_ = url;&quot;,&quot;  this.lastError_ = &#39;&#39;;&quot;,&quot;  this.lastErrorCode_ = goog.net.ErrorCode.NO_ERROR;&quot;,&quot;  this.lastMethod_ = method;&quot;,&quot;  this.errorDispatched_ = false;&quot;,&quot;  this.active_ = true;&quot;,null,&quot;  // Use the factory to create the XHR object and options&quot;,&quot;  this.xhr_ = this.createXhr();&quot;,&quot;  this.xhrOptions_ = this.xmlHttpFactory_ ? this.xmlHttpFactory_.getOptions() :&quot;,&quot;                                            goog.net.XmlHttp.getOptions();&quot;,null,&quot;  // Set up the onreadystatechange callback&quot;,&quot;  this.xhr_.onreadystatechange = goog.bind(this.onReadyStateChange_, this);&quot;,null,&quot;  // Set up upload/download progress events, if progress events are supported.&quot;,&quot;  if (this.getProgressEventsEnabled() &amp;&amp; &#39;onprogress&#39; in this.xhr_) {&quot;,&quot;    this.xhr_.onprogress =&quot;,&quot;        goog.bind(function(e) { this.onProgressHandler_(e, true); }, this);&quot;,&quot;    if (this.xhr_.upload) {&quot;,&quot;      this.xhr_.upload.onprogress = goog.bind(this.onProgressHandler_, this);&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  /**&quot;,&quot;   * Try to open the XMLHttpRequest (always async), if an error occurs here it&quot;,&quot;   * is generally permission denied&quot;,&quot;   */&quot;,&quot;  try {&quot;,&quot;    goog.log.fine(this.logger_, this.formatMsg_(&#39;Opening Xhr&#39;));&quot;,&quot;    this.inOpen_ = true;&quot;,&quot;    this.xhr_.open(method, String(url), true);  // Always async!&quot;,&quot;    this.inOpen_ = false;&quot;,&quot;  } catch (err) {&quot;,&quot;    goog.log.fine(&quot;,&quot;        this.logger_, this.formatMsg_(&#39;Error opening Xhr: &#39; + err.message));&quot;,&quot;    this.error_(goog.net.ErrorCode.EXCEPTION, err);&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  // We can&#39;t use null since this won&#39;t allow requests with form data to have a&quot;,&quot;  // content length specified which will cause some proxies to return a 411&quot;,&quot;  // error.&quot;,&quot;  var content = opt_content || &#39;&#39;;&quot;,null,&quot;  var headers = this.headers.clone();&quot;,null,&quot;  // Add headers specific to this request&quot;,&quot;  if (opt_headers) {&quot;,&quot;    goog.structs.forEach(&quot;,&quot;        opt_headers, function(value, key) { headers.set(key, value); });&quot;,&quot;  }&quot;,null,&quot;  // Find whether a content type header is set, ignoring case.&quot;,&quot;  // HTTP header names are case-insensitive.  See:&quot;,&quot;  // http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2&quot;,&quot;  var contentTypeKey =&quot;,&quot;      goog.array.find(headers.getKeys(), goog.net.XhrIo.isContentTypeHeader_);&quot;,null,&quot;  var contentIsFormData =&quot;,&quot;      (goog.global[&#39;FormData&#39;] &amp;&amp; (content instanceof goog.global[&#39;FormData&#39;]));&quot;,&quot;  if (goog.array.contains(goog.net.XhrIo.METHODS_WITH_FORM_DATA, method) &amp;&amp;&quot;,&quot;      !contentTypeKey &amp;&amp; !contentIsFormData) {&quot;,&quot;    // For requests typically with form data, default to the url-encoded form&quot;,&quot;    // content type unless this is a FormData request.  For FormData,&quot;,&quot;    // the browser will automatically add a multipart/form-data content type&quot;,&quot;    // with an appropriate multipart boundary.&quot;,&quot;    headers.set(&quot;,&quot;        goog.net.XhrIo.CONTENT_TYPE_HEADER, goog.net.XhrIo.FORM_CONTENT_TYPE);&quot;,&quot;  }&quot;,null,&quot;  // Add the headers to the Xhr object&quot;,&quot;  headers.forEach(function(value, key) {&quot;,&quot;    this.xhr_.setRequestHeader(key, value);&quot;,&quot;  }, this);&quot;,null,&quot;  if (this.responseType_) {&quot;,&quot;    this.xhr_.responseType = this.responseType_;&quot;,&quot;  }&quot;,&quot;  // Set xhr_.withCredentials only when the value is different, or else in&quot;,&quot;  // synchronous XMLHtppRequest.open Firefox will throw an exception.&quot;,&quot;  // https://bugzilla.mozilla.org/show_bug.cgi?id=736340&quot;,&quot;  if (&#39;withCredentials&#39; in this.xhr_ &amp;&amp;&quot;,&quot;      this.xhr_.withCredentials !== this.withCredentials_) {&quot;,&quot;    this.xhr_.withCredentials = this.withCredentials_;&quot;,&quot;  }&quot;,null,&quot;  /**&quot;,&quot;   * Try to send the request, or other wise report an error (404 not found).&quot;,&quot;   */&quot;,&quot;  try {&quot;,&quot;    this.cleanUpTimeoutTimer_();  // Paranoid, should never be running.&quot;,&quot;    if (this.timeoutInterval_ &gt; 0) {&quot;,&quot;      this.useXhr2Timeout_ = goog.net.XhrIo.shouldUseXhr2Timeout_(this.xhr_);&quot;,&quot;      goog.log.fine(&quot;,&quot;          this.logger_, this.formatMsg_(&quot;,&quot;                            &#39;Will abort after &#39; + this.timeoutInterval_ +&quot;,&quot;                            &#39;ms if incomplete, xhr2 &#39; + this.useXhr2Timeout_));&quot;,&quot;      if (this.useXhr2Timeout_) {&quot;,&quot;        this.xhr_[goog.net.XhrIo.XHR2_TIMEOUT_] = this.timeoutInterval_;&quot;,&quot;        this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] =&quot;,&quot;            goog.bind(this.timeout_, this);&quot;,&quot;      } else {&quot;,&quot;        this.timeoutId_ =&quot;,&quot;            goog.Timer.callOnce(this.timeout_, this.timeoutInterval_, this);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    goog.log.fine(this.logger_, this.formatMsg_(&#39;Sending request&#39;));&quot;,&quot;    this.inSend_ = true;&quot;,&quot;    this.xhr_.send(content);&quot;,&quot;    this.inSend_ = false;&quot;,null,&quot;  } catch (err) {&quot;,&quot;    goog.log.fine(this.logger_, this.formatMsg_(&#39;Send error: &#39; + err.message));&quot;,&quot;    this.error_(goog.net.ErrorCode.EXCEPTION, err);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Determines if the argument is an XMLHttpRequest that supports the level 2&quot;,&quot; * timeout value and event.&quot;,&quot; *&quot;,&quot; * Currently, FF 21.0 OS X has the fields but won&#39;t actually call the timeout&quot;,&quot; * handler.  Perhaps the confusion in the bug referenced below hasn&#39;t&quot;,&quot; * entirely been resolved.&quot;,&quot; *&quot;,&quot; * @see http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute&quot;,&quot; * @see https://bugzilla.mozilla.org/show_bug.cgi?id=525816&quot;,&quot; *&quot;,&quot; * @param {!goog.net.XhrLike.OrNative} xhr The request.&quot;,&quot; * @return {boolean} True if the request supports level 2 timeout.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.shouldUseXhr2Timeout_ = function(xhr) {&quot;,&quot;  return goog.userAgent.IE &amp;&amp; goog.userAgent.isVersionOrHigher(9) &amp;&amp;&quot;,&quot;      goog.isNumber(xhr[goog.net.XhrIo.XHR2_TIMEOUT_]) &amp;&amp;&quot;,&quot;      goog.isDef(xhr[goog.net.XhrIo.XHR2_ON_TIMEOUT_]);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} header An HTTP header key.&quot;,&quot; * @return {boolean} Whether the key is a content type header (ignoring&quot;,&quot; *     case.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.isContentTypeHeader_ = function(header) {&quot;,&quot;  return goog.string.caseInsensitiveEquals(&quot;,&quot;      goog.net.XhrIo.CONTENT_TYPE_HEADER, header);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a new XHR object.&quot;,&quot; * @return {!goog.net.XhrLike.OrNative} The newly created XHR object.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.createXhr = function() {&quot;,&quot;  return this.xmlHttpFactory_ ? this.xmlHttpFactory_.createInstance() :&quot;,&quot;                                goog.net.XmlHttp();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * The request didn&#39;t complete after {@link goog.net.XhrIo#timeoutInterval_}&quot;,&quot; * milliseconds; raises a {@link goog.net.EventType.TIMEOUT} event and aborts&quot;,&quot; * the request.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.timeout_ = function() {&quot;,&quot;  if (typeof goog == &#39;undefined&#39;) {&quot;,&quot;    // If goog is undefined then the callback has occurred as the application&quot;,&quot;    // is unloading and will error.  Thus we let it silently fail.&quot;,&quot;  } else if (this.xhr_) {&quot;,&quot;    this.lastError_ =&quot;,&quot;        &#39;Timed out after &#39; + this.timeoutInterval_ + &#39;ms, aborting&#39;;&quot;,&quot;    this.lastErrorCode_ = goog.net.ErrorCode.TIMEOUT;&quot;,&quot;    goog.log.fine(this.logger_, this.formatMsg_(this.lastError_));&quot;,&quot;    this.dispatchEvent(goog.net.EventType.TIMEOUT);&quot;,&quot;    this.abort(goog.net.ErrorCode.TIMEOUT);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Something errorred, so inactivate, fire error callback and clean up&quot;,&quot; * @param {goog.net.ErrorCode} errorCode The error code.&quot;,&quot; * @param {Error} err The error object.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.error_ = function(errorCode, err) {&quot;,&quot;  this.active_ = false;&quot;,&quot;  if (this.xhr_) {&quot;,&quot;    this.inAbort_ = true;&quot;,&quot;    this.xhr_.abort();  // Ensures XHR isn&#39;t hung (FF)&quot;,&quot;    this.inAbort_ = false;&quot;,&quot;  }&quot;,&quot;  this.lastError_ = err;&quot;,&quot;  this.lastErrorCode_ = errorCode;&quot;,&quot;  this.dispatchErrors_();&quot;,&quot;  this.cleanUpXhr_();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Dispatches COMPLETE and ERROR in case of an error. This ensures that we do&quot;,&quot; * not dispatch multiple error events.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.dispatchErrors_ = function() {&quot;,&quot;  if (!this.errorDispatched_) {&quot;,&quot;    this.errorDispatched_ = true;&quot;,&quot;    this.dispatchEvent(goog.net.EventType.COMPLETE);&quot;,&quot;    this.dispatchEvent(goog.net.EventType.ERROR);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Abort the current XMLHttpRequest&quot;,&quot; * @param {goog.net.ErrorCode=} opt_failureCode Optional error code to use -&quot;,&quot; *     defaults to ABORT.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.abort = function(opt_failureCode) {&quot;,&quot;  if (this.xhr_ &amp;&amp; this.active_) {&quot;,&quot;    goog.log.fine(this.logger_, this.formatMsg_(&#39;Aborting&#39;));&quot;,&quot;    this.active_ = false;&quot;,&quot;    this.inAbort_ = true;&quot;,&quot;    this.xhr_.abort();&quot;,&quot;    this.inAbort_ = false;&quot;,&quot;    this.lastErrorCode_ = opt_failureCode || goog.net.ErrorCode.ABORT;&quot;,&quot;    this.dispatchEvent(goog.net.EventType.COMPLETE);&quot;,&quot;    this.dispatchEvent(goog.net.EventType.ABORT);&quot;,&quot;    this.cleanUpXhr_();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Nullifies all callbacks to reduce risks of leaks.&quot;,&quot; * @override&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.disposeInternal = function() {&quot;,&quot;  if (this.xhr_) {&quot;,&quot;    // We explicitly do not call xhr_.abort() unless active_ is still true.&quot;,&quot;    // This is to avoid unnecessarily aborting a successful request when&quot;,&quot;    // dispose() is called in a callback triggered by a complete response, but&quot;,&quot;    // in which browser cleanup has not yet finished.&quot;,&quot;    // (See http://b/issue?id=1684217.)&quot;,&quot;    if (this.active_) {&quot;,&quot;      this.active_ = false;&quot;,&quot;      this.inAbort_ = true;&quot;,&quot;      this.xhr_.abort();&quot;,&quot;      this.inAbort_ = false;&quot;,&quot;    }&quot;,&quot;    this.cleanUpXhr_(true);&quot;,&quot;  }&quot;,null,&quot;  goog.net.XhrIo.base(this, &#39;disposeInternal&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Internal handler for the XHR object&#39;s readystatechange event.  This method&quot;,&quot; * checks the status and the readystate and fires the correct callbacks.&quot;,&quot; * If the request has ended, the handlers are cleaned up and the XHR object is&quot;,&quot; * nullified.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.onReadyStateChange_ = function() {&quot;,&quot;  if (this.isDisposed()) {&quot;,&quot;    // This method is the target of an untracked goog.Timer.callOnce().&quot;,&quot;    return;&quot;,&quot;  }&quot;,&quot;  if (!this.inOpen_ &amp;&amp; !this.inSend_ &amp;&amp; !this.inAbort_) {&quot;,&quot;    // Were not being called from within a call to this.xhr_.send&quot;,&quot;    // this.xhr_.abort, or this.xhr_.open, so this is an entry point&quot;,&quot;    this.onReadyStateChangeEntryPoint_();&quot;,&quot;  } else {&quot;,&quot;    this.onReadyStateChangeHelper_();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Used to protect the onreadystatechange handler entry point.  Necessary&quot;,&quot; * as {#onReadyStateChange_} maybe called from within send or abort, this&quot;,&quot; * method is only called when {#onReadyStateChange_} is called as an&quot;,&quot; * entry point.&quot;,&quot; * {@see #protectEntryPoints}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ = function() {&quot;,&quot;  this.onReadyStateChangeHelper_();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Helper for {@link #onReadyStateChange_}.  This is used so that&quot;,&quot; * entry point calls to {@link #onReadyStateChange_} can be routed through&quot;,&quot; * {@link #onReadyStateChangeEntryPoint_}.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.onReadyStateChangeHelper_ = function() {&quot;,&quot;  if (!this.active_) {&quot;,&quot;    // can get called inside abort call&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  if (typeof goog == &#39;undefined&#39;) {&quot;,&quot;    // NOTE(user): If goog is undefined then the callback has occurred as the&quot;,&quot;    // application is unloading and will error.  Thus we let it silently fail.&quot;,null,&quot;  } else if (&quot;,&quot;      this.xhrOptions_[goog.net.XmlHttp.OptionType.LOCAL_REQUEST_ERROR] &amp;&amp;&quot;,&quot;      this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE &amp;&amp;&quot;,&quot;      this.getStatus() == 2) {&quot;,&quot;    // NOTE(user): In IE if send() errors on a *local* request the readystate&quot;,&quot;    // is still changed to COMPLETE.  We need to ignore it and allow the&quot;,&quot;    // try/catch around send() to pick up the error.&quot;,&quot;    goog.log.fine(&quot;,&quot;        this.logger_,&quot;,&quot;        this.formatMsg_(&#39;Local request error detected and ignored&#39;));&quot;,null,&quot;  } else {&quot;,&quot;    // In IE when the response has been cached we sometimes get the callback&quot;,&quot;    // from inside the send call and this usually breaks code that assumes that&quot;,&quot;    // XhrIo is asynchronous.  If that is the case we delay the callback&quot;,&quot;    // using a timer.&quot;,&quot;    if (this.inSend_ &amp;&amp;&quot;,&quot;        this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE) {&quot;,&quot;      goog.Timer.callOnce(this.onReadyStateChange_, 0, this);&quot;,&quot;      return;&quot;,&quot;    }&quot;,null,&quot;    this.dispatchEvent(goog.net.EventType.READY_STATE_CHANGE);&quot;,null,&quot;    // readyState indicates the transfer has finished&quot;,&quot;    if (this.isComplete()) {&quot;,&quot;      goog.log.fine(this.logger_, this.formatMsg_(&#39;Request complete&#39;));&quot;,null,&quot;      this.active_ = false;&quot;,null,&quot;      try {&quot;,&quot;        // Call the specific callbacks for success or failure. Only call the&quot;,&quot;        // success if the status is 200 (HTTP_OK) or 304 (HTTP_CACHED)&quot;,&quot;        if (this.isSuccess()) {&quot;,&quot;          this.dispatchEvent(goog.net.EventType.COMPLETE);&quot;,&quot;          this.dispatchEvent(goog.net.EventType.SUCCESS);&quot;,&quot;        } else {&quot;,&quot;          this.lastErrorCode_ = goog.net.ErrorCode.HTTP_ERROR;&quot;,&quot;          this.lastError_ =&quot;,&quot;              this.getStatusText() + &#39; [&#39; + this.getStatus() + &#39;]&#39;;&quot;,&quot;          this.dispatchErrors_();&quot;,&quot;        }&quot;,&quot;      } finally {&quot;,&quot;        this.cleanUpXhr_();&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Internal handler for the XHR object&#39;s onprogress event. Fires both a generic&quot;,&quot; * PROGRESS event and either a DOWNLOAD_PROGRESS or UPLOAD_PROGRESS event to&quot;,&quot; * allow specific binding for each XHR progress event.&quot;,&quot; * @param {!ProgressEvent} e XHR progress event.&quot;,&quot; * @param {boolean=} opt_isDownload Whether the current progress event is from a&quot;,&quot; *     download. Used to determine whether DOWNLOAD_PROGRESS or UPLOAD_PROGRESS&quot;,&quot; *     event should be dispatched.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.onProgressHandler_ = function(e, opt_isDownload) {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      e.type === goog.net.EventType.PROGRESS,&quot;,&quot;      &#39;goog.net.EventType.PROGRESS is of the same type as raw XHR progress.&#39;);&quot;,&quot;  this.dispatchEvent(&quot;,&quot;      goog.net.XhrIo.buildProgressEvent_(e, goog.net.EventType.PROGRESS));&quot;,&quot;  this.dispatchEvent(&quot;,&quot;      goog.net.XhrIo.buildProgressEvent_(&quot;,&quot;          e, opt_isDownload ? goog.net.EventType.DOWNLOAD_PROGRESS :&quot;,&quot;                              goog.net.EventType.UPLOAD_PROGRESS));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Creates a representation of the native ProgressEvent. IE doesn&#39;t support&quot;,&quot; * constructing ProgressEvent via \&quot;new\&quot;, and the alternatives (e.g.,&quot;,&quot; * ProgressEvent.initProgressEvent) are non-standard or deprecated.&quot;,&quot; * @param {!ProgressEvent} e XHR progress event.&quot;,&quot; * @param {!goog.net.EventType} eventType The type of the event.&quot;,&quot; * @return {!ProgressEvent} The progress event.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.buildProgressEvent_ = function(e, eventType) {&quot;,&quot;  return /** @type {!ProgressEvent} */ ({&quot;,&quot;    type: eventType,&quot;,&quot;    lengthComputable: e.lengthComputable,&quot;,&quot;    loaded: e.loaded,&quot;,&quot;    total: e.total&quot;,&quot;  });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Remove the listener to protect against leaks, and nullify the XMLHttpRequest&quot;,&quot; * object.&quot;,&quot; * @param {boolean=} opt_fromDispose If this is from the dispose (don&#39;t want to&quot;,&quot; *     fire any events).&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.cleanUpXhr_ = function(opt_fromDispose) {&quot;,&quot;  if (this.xhr_) {&quot;,&quot;    // Cancel any pending timeout event handler.&quot;,&quot;    this.cleanUpTimeoutTimer_();&quot;,null,&quot;    // Save reference so we can mark it as closed after the READY event.  The&quot;,&quot;    // READY event may trigger another request, thus we must nullify this.xhr_&quot;,&quot;    var xhr = this.xhr_;&quot;,&quot;    var clearedOnReadyStateChange =&quot;,&quot;        this.xhrOptions_[goog.net.XmlHttp.OptionType.USE_NULL_FUNCTION] ?&quot;,&quot;        goog.nullFunction :&quot;,&quot;        null;&quot;,&quot;    this.xhr_ = null;&quot;,&quot;    this.xhrOptions_ = null;&quot;,null,&quot;    if (!opt_fromDispose) {&quot;,&quot;      this.dispatchEvent(goog.net.EventType.READY);&quot;,&quot;    }&quot;,null,&quot;    try {&quot;,&quot;      // NOTE(user): Not nullifying in FireFox can still leak if the callbacks&quot;,&quot;      // are defined in the same scope as the instance of XhrIo. But, IE doesn&#39;t&quot;,&quot;      // allow you to set the onreadystatechange to NULL so nullFunction is&quot;,&quot;      // used.&quot;,&quot;      xhr.onreadystatechange = clearedOnReadyStateChange;&quot;,&quot;    } catch (e) {&quot;,&quot;      // This seems to occur with a Gears HTTP request. Delayed the setting of&quot;,&quot;      // this onreadystatechange until after READY is sent out and catching the&quot;,&quot;      // error to see if we can track down the problem.&quot;,&quot;      goog.log.error(&quot;,&quot;          this.logger_,&quot;,&quot;          &#39;Problem encountered resetting onreadystatechange: &#39; + e.message);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Make sure the timeout timer isn&#39;t running.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.cleanUpTimeoutTimer_ = function() {&quot;,&quot;  if (this.xhr_ &amp;&amp; this.useXhr2Timeout_) {&quot;,&quot;    this.xhr_[goog.net.XhrIo.XHR2_ON_TIMEOUT_] = null;&quot;,&quot;  }&quot;,&quot;  if (this.timeoutId_) {&quot;,&quot;    goog.Timer.clear(this.timeoutId_);&quot;,&quot;    this.timeoutId_ = null;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {boolean} Whether there is an active request.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.isActive = function() {&quot;,&quot;  return !!this.xhr_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {boolean} Whether the request has completed.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.isComplete = function() {&quot;,&quot;  return this.getReadyState() == goog.net.XmlHttp.ReadyState.COMPLETE;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {boolean} Whether the request completed with a success.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.isSuccess = function() {&quot;,&quot;  var status = this.getStatus();&quot;,&quot;  // A zero status code is considered successful for local files.&quot;,&quot;  return goog.net.HttpStatus.isSuccess(status) ||&quot;,&quot;      status === 0 &amp;&amp; !this.isLastUriEffectiveSchemeHttp_();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {boolean} whether the effective scheme of the last URI that was&quot;,&quot; *     fetched was &#39;http&#39; or &#39;https&#39;.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.isLastUriEffectiveSchemeHttp_ = function() {&quot;,&quot;  var scheme = goog.uri.utils.getEffectiveScheme(String(this.lastUri_));&quot;,&quot;  return goog.net.XhrIo.HTTP_SCHEME_PATTERN.test(scheme);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the readystate from the Xhr object&quot;,&quot; * Will only return correct result when called from the context of a callback&quot;,&quot; * @return {goog.net.XmlHttp.ReadyState} goog.net.XmlHttp.ReadyState.*.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getReadyState = function() {&quot;,&quot;  return this.xhr_ ?&quot;,&quot;      /** @type {goog.net.XmlHttp.ReadyState} */ (this.xhr_.readyState) :&quot;,&quot;                                                 goog.net.XmlHttp.ReadyState&quot;,&quot;                                                     .UNINITIALIZED;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the status from the Xhr object&quot;,&quot; * Will only return correct result when called from the context of a callback&quot;,&quot; * @return {number} Http status.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getStatus = function() {&quot;,&quot;  /**&quot;,&quot;   * IE doesn&#39;t like you checking status until the readystate is greater than 2&quot;,&quot;   * (i.e. it is receiving or complete).  The try/catch is used for when the&quot;,&quot;   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.&quot;,&quot;   */&quot;,&quot;  try {&quot;,&quot;    return this.getReadyState() &gt; goog.net.XmlHttp.ReadyState.LOADED ?&quot;,&quot;        this.xhr_.status :&quot;,&quot;        -1;&quot;,&quot;  } catch (e) {&quot;,&quot;    return -1;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the status text from the Xhr object&quot;,&quot; * Will only return correct result when called from the context of a callback&quot;,&quot; * @return {string} Status text.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getStatusText = function() {&quot;,&quot;  /**&quot;,&quot;   * IE doesn&#39;t like you checking status until the readystate is greater than 2&quot;,&quot;   * (i.e. it is receiving or complete).  The try/catch is used for when the&quot;,&quot;   * page is unloading and an ERROR_NOT_AVAILABLE may occur when accessing xhr_.&quot;,&quot;   */&quot;,&quot;  try {&quot;,&quot;    return this.getReadyState() &gt; goog.net.XmlHttp.ReadyState.LOADED ?&quot;,&quot;        this.xhr_.statusText :&quot;,&quot;        &#39;&#39;;&quot;,&quot;  } catch (e) {&quot;,&quot;    goog.log.fine(this.logger_, &#39;Can not get status: &#39; + e.message);&quot;,&quot;    return &#39;&#39;;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the last Uri that was requested&quot;,&quot; * @return {string} Last Uri.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getLastUri = function() {&quot;,&quot;  return String(this.lastUri_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the response text from the Xhr object&quot;,&quot; * Will only return correct result when called from the context of a callback.&quot;,&quot; * @return {string} Result from the server, or &#39;&#39; if no result available.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getResponseText = function() {&quot;,&quot;  try {&quot;,&quot;    return this.xhr_ ? this.xhr_.responseText : &#39;&#39;;&quot;,&quot;  } catch (e) {&quot;,&quot;    // http://www.w3.org/TR/XMLHttpRequest/#the-responsetext-attribute&quot;,&quot;    // states that responseText should return &#39;&#39; (and responseXML null)&quot;,&quot;    // when the state is not LOADING or DONE. Instead, IE can&quot;,&quot;    // throw unexpected exceptions, for example when a request is aborted&quot;,&quot;    // or no data is available yet.&quot;,&quot;    goog.log.fine(this.logger_, &#39;Can not get responseText: &#39; + e.message);&quot;,&quot;    return &#39;&#39;;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the response body from the Xhr object. This property is only available&quot;,&quot; * in IE since version 7 according to MSDN:&quot;,&quot; * http://msdn.microsoft.com/en-us/library/ie/ms534368(v=vs.85).aspx&quot;,&quot; * Will only return correct result when called from the context of a callback.&quot;,&quot; *&quot;,&quot; * One option is to construct a VBArray from the returned object and convert&quot;,&quot; * it to a JavaScript array using the toArray method:&quot;,&quot; * {@code (new window[&#39;VBArray&#39;](xhrIo.getResponseBody())).toArray()}&quot;,&quot; * This will result in an array of numbers in the range of [0..255]&quot;,&quot; *&quot;,&quot; * Another option is to use the VBScript CStr method to convert it into a&quot;,&quot; * string as outlined in http://stackoverflow.com/questions/1919972&quot;,&quot; *&quot;,&quot; * @return {Object} Binary result from the server or null if not available.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getResponseBody = function() {&quot;,null,&quot;  try {&quot;,&quot;    if (this.xhr_ &amp;&amp; &#39;responseBody&#39; in this.xhr_) {&quot;,&quot;      return this.xhr_[&#39;responseBody&#39;];&quot;,&quot;    }&quot;,&quot;  } catch (e) {&quot;,&quot;    // IE can throw unexpected exceptions, for example when a request is aborted&quot;,&quot;    // or no data is yet available.&quot;,&quot;    goog.log.fine(this.logger_, &#39;Can not get responseBody: &#39; + e.message);&quot;,&quot;  }&quot;,&quot;  return null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the response XML from the Xhr object&quot;,&quot; * Will only return correct result when called from the context of a callback.&quot;,&quot; * @return {Document} The DOM Document representing the XML file, or null&quot;,&quot; * if no result available.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getResponseXml = function() {&quot;,null,&quot;  try {&quot;,&quot;    return this.xhr_ ? this.xhr_.responseXML : null;&quot;,&quot;  } catch (e) {&quot;,&quot;    goog.log.fine(this.logger_, &#39;Can not get responseXML: &#39; + e.message);&quot;,&quot;    return null;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the response and evaluates it as JSON from the Xhr object&quot;,&quot; * Will only return correct result when called from the context of a callback&quot;,&quot; * @param {string=} opt_xssiPrefix Optional XSSI prefix string to use for&quot;,&quot; *     stripping of the response before parsing. This needs to be set only if&quot;,&quot; *     your backend server prepends the same prefix string to the JSON response.&quot;,&quot; * @throws Error if the response text is invalid JSON.&quot;,&quot; * @return {Object|undefined} JavaScript object.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getResponseJson = function(opt_xssiPrefix) {&quot;,&quot;  if (!this.xhr_) {&quot;,&quot;    return undefined;&quot;,&quot;  }&quot;,null,&quot;  var responseText = this.xhr_.responseText;&quot;,&quot;  if (opt_xssiPrefix &amp;&amp; responseText.indexOf(opt_xssiPrefix) == 0) {&quot;,&quot;    responseText = responseText.substring(opt_xssiPrefix.length);&quot;,&quot;  }&quot;,null,&quot;  return goog.json.hybrid.parse(responseText);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the response as the type specificed by {@link #setResponseType}. At time&quot;,&quot; * of writing, this is only directly supported in very recent versions of WebKit&quot;,&quot; * (10.0.612.1 dev and later). If the field is not supported directly, we will&quot;,&quot; * try to emulate it.&quot;,&quot; *&quot;,&quot; * Emulating the response means following the rules laid out at&quot;,&quot; * http://www.w3.org/TR/XMLHttpRequest/#the-response-attribute&quot;,&quot; *&quot;,&quot; * On browsers with no support for this (Chrome &lt; 10, Firefox &lt; 4, etc), only&quot;,&quot; * response types of DEFAULT or TEXT may be used, and the response returned will&quot;,&quot; * be the text response.&quot;,&quot; *&quot;,&quot; * On browsers with Mozilla&#39;s draft support for array buffers (Firefox 4, 5),&quot;,&quot; * only response types of DEFAULT, TEXT, and ARRAY_BUFFER may be used, and the&quot;,&quot; * response returned will be either the text response or the Mozilla&quot;,&quot; * implementation of the array buffer response.&quot;,&quot; *&quot;,&quot; * On browsers will full support, any valid response type supported by the&quot;,&quot; * browser may be used, and the response provided by the browser will be&quot;,&quot; * returned.&quot;,&quot; *&quot;,&quot; * @return {*} The response.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getResponse = function() {&quot;,null,&quot;  try {&quot;,&quot;    if (!this.xhr_) {&quot;,&quot;      return null;&quot;,&quot;    }&quot;,&quot;    if (&#39;response&#39; in this.xhr_) {&quot;,&quot;      return this.xhr_.response;&quot;,&quot;    }&quot;,&quot;    switch (this.responseType_) {&quot;,&quot;      case goog.net.XhrIo.ResponseType.DEFAULT:&quot;,&quot;      case goog.net.XhrIo.ResponseType.TEXT:&quot;,&quot;        return this.xhr_.responseText;&quot;,&quot;      // DOCUMENT and BLOB don&#39;t need to be handled here because they are&quot;,&quot;      // introduced in the same spec that adds the .response field, and would&quot;,&quot;      // have been caught above.&quot;,&quot;      // ARRAY_BUFFER needs an implementation for Firefox 4, where it was&quot;,&quot;      // implemented using a draft spec rather than the final spec.&quot;,&quot;      case goog.net.XhrIo.ResponseType.ARRAY_BUFFER:&quot;,&quot;        if (&#39;mozResponseArrayBuffer&#39; in this.xhr_) {&quot;,&quot;          return this.xhr_.mozResponseArrayBuffer;&quot;,&quot;        }&quot;,&quot;    }&quot;,&quot;    // Fell through to a response type that is not supported on this browser.&quot;,&quot;    goog.log.error(&quot;,&quot;        this.logger_, &#39;Response type &#39; + this.responseType_ + &#39; is not &#39; +&quot;,&quot;            &#39;supported on this browser&#39;);&quot;,&quot;    return null;&quot;,&quot;  } catch (e) {&quot;,&quot;    goog.log.fine(this.logger_, &#39;Can not get response: &#39; + e.message);&quot;,&quot;    return null;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the value of the response-header with the given name from the Xhr object&quot;,&quot; * Will only return correct result when called from the context of a callback&quot;,&quot; * and the request has completed&quot;,&quot; * @param {string} key The name of the response-header to retrieve.&quot;,&quot; * @return {string|undefined} The value of the response-header named key.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getResponseHeader = function(key) {&quot;,&quot;  if (!this.xhr_ || !this.isComplete()) {&quot;,&quot;    return undefined;&quot;,&quot;  }&quot;,null,&quot;  var value = this.xhr_.getResponseHeader(key);&quot;,&quot;  return goog.isNull(value) ? undefined : value;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the text of all the headers in the response.&quot;,&quot; * Will only return correct result when called from the context of a callback&quot;,&quot; * and the request has completed.&quot;,&quot; * @return {string} The value of the response headers or empty string.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getAllResponseHeaders = function() {&quot;,&quot;  return this.xhr_ &amp;&amp; this.isComplete() ? this.xhr_.getAllResponseHeaders() :&quot;,&quot;                                          &#39;&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns all response headers as a key-value map.&quot;,&quot; * Multiple values for the same header key can be combined into one,&quot;,&quot; * separated by a comma and a space.&quot;,&quot; * Note that the native getResponseHeader method for retrieving a single header&quot;,&quot; * does a case insensitive match on the header name. This method does not&quot;,&quot; * include any case normalization logic, it will just return a key-value&quot;,&quot; * representation of the headers.&quot;,&quot; * See: http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method&quot;,&quot; * @return {!Object&lt;string, string&gt;} An object with the header keys as keys&quot;,&quot; *     and header values as values.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getResponseHeaders = function() {&quot;,&quot;  var headersObject = {};&quot;,&quot;  var headersArray = this.getAllResponseHeaders().split(&#39;\\r\\n&#39;);&quot;,&quot;  for (var i = 0; i &lt; headersArray.length; i++) {&quot;,&quot;    if (goog.string.isEmptyOrWhitespace(headersArray[i])) {&quot;,&quot;      continue;&quot;,&quot;    }&quot;,&quot;    var keyValue = goog.string.splitLimit(headersArray[i], &#39;: &#39;, 2);&quot;,&quot;    if (headersObject[keyValue[0]]) {&quot;,&quot;      headersObject[keyValue[0]] += &#39;, &#39; + keyValue[1];&quot;,&quot;    } else {&quot;,&quot;      headersObject[keyValue[0]] = keyValue[1];&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return headersObject;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the value of the response-header with the given name from the Xhr object.&quot;,&quot; * As opposed to {@link #getResponseHeader}, this method does not require that&quot;,&quot; * the request has completed.&quot;,&quot; * @param {string} key The name of the response-header to retrieve.&quot;,&quot; * @return {?string} The value of the response-header, or null if it is&quot;,&quot; *     unavailable.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getStreamingResponseHeader = function(key) {&quot;,&quot;  return this.xhr_ ? this.xhr_.getResponseHeader(key) : null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the text of all the headers in the response. As opposed to&quot;,&quot; * {@link #getAllResponseHeaders}, this method does not require that the request&quot;,&quot; * has completed.&quot;,&quot; * @return {string} The value of the response headers or empty string.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getAllStreamingResponseHeaders = function() {&quot;,&quot;  return this.xhr_ ? this.xhr_.getAllResponseHeaders() : &#39;&#39;;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the last error message&quot;,&quot; * @return {goog.net.ErrorCode} Last error code.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getLastErrorCode = function() {&quot;,&quot;  return this.lastErrorCode_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the last error message&quot;,&quot; * @return {string} Last error message.&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.getLastError = function() {&quot;,&quot;  return goog.isString(this.lastError_) ? this.lastError_ :&quot;,&quot;                                          String(this.lastError_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds the last method, status and URI to the message.  This is used to add&quot;,&quot; * this information to the logging calls.&quot;,&quot; * @param {string} msg The message text that we want to add the extra text to.&quot;,&quot; * @return {string} The message with the extra text appended.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.net.XhrIo.prototype.formatMsg_ = function(msg) {&quot;,&quot;  return msg + &#39; [&#39; + this.lastMethod_ + &#39; &#39; + this.lastUri_ + &#39; &#39; +&quot;,&quot;      this.getStatus() + &#39;]&#39;;&quot;,&quot;};&quot;,null,null,&quot;// Register the xhr handler as an entry point, so that&quot;,&quot;// it can be monitored for exception handling, etc.&quot;,&quot;goog.debug.entryPointRegistry.register(&quot;,&quot;    /**&quot;,&quot;     * @param {function(!Function): !Function} transformer The transforming&quot;,&quot;     *     function.&quot;,&quot;     */&quot;,&quot;    function(transformer) {&quot;,&quot;      goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_ =&quot;,&quot;          transformer(goog.net.XhrIo.prototype.onReadyStateChangeEntryPoint_);&quot;,&quot;    });&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>