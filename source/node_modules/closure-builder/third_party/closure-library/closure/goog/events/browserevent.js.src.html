<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>browserevent.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;browserevent.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/events/browserevent.js&quot;,[&quot;// Copyright 2005 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview A patched, standardized event object for browser events.&quot;,&quot; *&quot;,&quot; * &lt;pre&gt;&quot;,&quot; * The patched event object contains the following members:&quot;,&quot; * - type           {string}    Event type, e.g. &#39;click&#39;&quot;,&quot; * - target         {Object}    The element that actually triggered the event&quot;,&quot; * - currentTarget  {Object}    The element the listener is attached to&quot;,&quot; * - relatedTarget  {Object}    For mouseover and mouseout, the previous object&quot;,&quot; * - offsetX        {number}    X-coordinate relative to target&quot;,&quot; * - offsetY        {number}    Y-coordinate relative to target&quot;,&quot; * - clientX        {number}    X-coordinate relative to viewport&quot;,&quot; * - clientY        {number}    Y-coordinate relative to viewport&quot;,&quot; * - screenX        {number}    X-coordinate relative to the edge of the screen&quot;,&quot; * - screenY        {number}    Y-coordinate relative to the edge of the screen&quot;,&quot; * - button         {number}    Mouse button. Use isButton() to test.&quot;,&quot; * - keyCode        {number}    Key-code&quot;,&quot; * - ctrlKey        {boolean}   Was ctrl key depressed&quot;,&quot; * - altKey         {boolean}   Was alt key depressed&quot;,&quot; * - shiftKey       {boolean}   Was shift key depressed&quot;,&quot; * - metaKey        {boolean}   Was meta key depressed&quot;,&quot; * - pointerId      {number}    Pointer ID&quot;,&quot; * - pointerType    {string}    Pointer type, e.g. &#39;mouse&#39;, &#39;pen&#39;, or &#39;touch&#39;&quot;,&quot; * - defaultPrevented {boolean} Whether the default action has been prevented&quot;,&quot; * - state          {Object}    History state object&quot;,&quot; *&quot;,&quot; * NOTE: The keyCode member contains the raw browser keyCode. For normalized&quot;,&quot; * key and character code use {@link goog.events.KeyHandler}.&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * @author arv@google.com (Erik Arvidsson)&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.events.BrowserEvent&#39;);&quot;,&quot;goog.provide(&#39;goog.events.BrowserEvent.MouseButton&#39;);&quot;,&quot;goog.provide(&#39;goog.events.BrowserEvent.PointerType&#39;);&quot;,null,&quot;goog.require(&#39;goog.debug&#39;);&quot;,&quot;goog.require(&#39;goog.events.BrowserFeature&#39;);&quot;,&quot;goog.require(&#39;goog.events.Event&#39;);&quot;,&quot;goog.require(&#39;goog.events.EventType&#39;);&quot;,&quot;goog.require(&#39;goog.reflect&#39;);&quot;,&quot;goog.require(&#39;goog.userAgent&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * Accepts a browser event object and creates a patched, cross browser event&quot;,&quot; * object.&quot;,&quot; * The content of this object will not be initialized if no event object is&quot;,&quot; * provided. If this is the case, init() needs to be invoked separately.&quot;,&quot; * @param {Event=} opt_e Browser event object.&quot;,&quot; * @param {EventTarget=} opt_currentTarget Current target for event.&quot;,&quot; * @constructor&quot;,&quot; * @extends {goog.events.Event}&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent = function(opt_e, opt_currentTarget) {&quot;,&quot;  goog.events.BrowserEvent.base(this, &#39;constructor&#39;, opt_e ? opt_e.type : &#39;&#39;);&quot;,null,&quot;  /**&quot;,&quot;   * Target that fired the event.&quot;,&quot;   * @override&quot;,&quot;   * @type {Node}&quot;,&quot;   */&quot;,&quot;  this.target = null;&quot;,null,&quot;  /**&quot;,&quot;   * Node that had the listener attached.&quot;,&quot;   * @override&quot;,&quot;   * @type {Node|undefined}&quot;,&quot;   */&quot;,&quot;  this.currentTarget = null;&quot;,null,&quot;  /**&quot;,&quot;   * For mouseover and mouseout events, the related object for the event.&quot;,&quot;   * @type {Node}&quot;,&quot;   */&quot;,&quot;  this.relatedTarget = null;&quot;,null,&quot;  /**&quot;,&quot;   * X-coordinate relative to target.&quot;,&quot;   * @type {number}&quot;,&quot;   */&quot;,&quot;  this.offsetX = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Y-coordinate relative to target.&quot;,&quot;   * @type {number}&quot;,&quot;   */&quot;,&quot;  this.offsetY = 0;&quot;,null,&quot;  /**&quot;,&quot;   * X-coordinate relative to the window.&quot;,&quot;   * @type {number}&quot;,&quot;   */&quot;,&quot;  this.clientX = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Y-coordinate relative to the window.&quot;,&quot;   * @type {number}&quot;,&quot;   */&quot;,&quot;  this.clientY = 0;&quot;,null,&quot;  /**&quot;,&quot;   * X-coordinate relative to the monitor.&quot;,&quot;   * @type {number}&quot;,&quot;   */&quot;,&quot;  this.screenX = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Y-coordinate relative to the monitor.&quot;,&quot;   * @type {number}&quot;,&quot;   */&quot;,&quot;  this.screenY = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Which mouse button was pressed.&quot;,&quot;   * @type {number}&quot;,&quot;   */&quot;,&quot;  this.button = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Key of key press.&quot;,&quot;   * @type {string}&quot;,&quot;   */&quot;,&quot;  this.key = &#39;&#39;;&quot;,null,&quot;  /**&quot;,&quot;   * Keycode of key press.&quot;,&quot;   * @type {number}&quot;,&quot;   */&quot;,&quot;  this.keyCode = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Keycode of key press.&quot;,&quot;   * @type {number}&quot;,&quot;   */&quot;,&quot;  this.charCode = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Whether control was pressed at time of event.&quot;,&quot;   * @type {boolean}&quot;,&quot;   */&quot;,&quot;  this.ctrlKey = false;&quot;,null,&quot;  /**&quot;,&quot;   * Whether alt was pressed at time of event.&quot;,&quot;   * @type {boolean}&quot;,&quot;   */&quot;,&quot;  this.altKey = false;&quot;,null,&quot;  /**&quot;,&quot;   * Whether shift was pressed at time of event.&quot;,&quot;   * @type {boolean}&quot;,&quot;   */&quot;,&quot;  this.shiftKey = false;&quot;,null,&quot;  /**&quot;,&quot;   * Whether the meta key was pressed at time of event.&quot;,&quot;   * @type {boolean}&quot;,&quot;   */&quot;,&quot;  this.metaKey = false;&quot;,null,&quot;  /**&quot;,&quot;   * History state object, only set for PopState events where it&#39;s a copy of the&quot;,&quot;   * state object provided to pushState or replaceState.&quot;,&quot;   * @type {Object}&quot;,&quot;   */&quot;,&quot;  this.state = null;&quot;,null,&quot;  /**&quot;,&quot;   * Whether the default platform modifier key was pressed at time of event.&quot;,&quot;   * (This is control for all platforms except Mac, where it&#39;s Meta.)&quot;,&quot;   * @type {boolean}&quot;,&quot;   */&quot;,&quot;  this.platformModifierKey = false;&quot;,null,&quot;  /**&quot;,&quot;   * @type {number}&quot;,&quot;   */&quot;,&quot;  this.pointerId = 0;&quot;,null,&quot;  /**&quot;,&quot;   * @type {string}&quot;,&quot;   */&quot;,&quot;  this.pointerType = &#39;&#39;;&quot;,null,&quot;  /**&quot;,&quot;   * The browser event object.&quot;,&quot;   * @private {Event}&quot;,&quot;   */&quot;,&quot;  this.event_ = null;&quot;,null,&quot;  if (opt_e) {&quot;,&quot;    this.init(opt_e, opt_currentTarget);&quot;,&quot;  }&quot;,&quot;};&quot;,&quot;goog.inherits(goog.events.BrowserEvent, goog.events.Event);&quot;,null,null,&quot;/**&quot;,&quot; * Normalized button constants for the mouse.&quot;,&quot; * @enum {number}&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent.MouseButton = {&quot;,&quot;  LEFT: 0,&quot;,&quot;  MIDDLE: 1,&quot;,&quot;  RIGHT: 2&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Normalized pointer type constants for pointer events.&quot;,&quot; * @enum {string}&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent.PointerType = {&quot;,&quot;  MOUSE: &#39;mouse&#39;,&quot;,&quot;  PEN: &#39;pen&#39;,&quot;,&quot;  TOUCH: &#39;touch&#39;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Static data for mapping mouse buttons.&quot;,&quot; * @type {!Array&lt;number&gt;}&quot;,&quot; * @deprecated Use {@code goog.events.BrowserEvent.IE_BUTTON_MAP} instead.&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent.IEButtonMap = goog.debug.freeze([&quot;,&quot;  1,  // LEFT&quot;,&quot;  4,  // MIDDLE&quot;,&quot;  2   // RIGHT&quot;,&quot;]);&quot;,null,null,&quot;/**&quot;,&quot; * Static data for mapping mouse buttons.&quot;,&quot; * @const {!Array&lt;number&gt;}&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent.IE_BUTTON_MAP = goog.events.BrowserEvent.IEButtonMap;&quot;,null,null,&quot;/**&quot;,&quot; * Static data for mapping MSPointerEvent types to PointerEvent types.&quot;,&quot; * @const {!Object&lt;number, goog.events.BrowserEvent.PointerType&gt;}&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent.IE_POINTER_TYPE_MAP = goog.debug.freeze({&quot;,&quot;  2: goog.events.BrowserEvent.PointerType.TOUCH,&quot;,&quot;  3: goog.events.BrowserEvent.PointerType.PEN,&quot;,&quot;  4: goog.events.BrowserEvent.PointerType.MOUSE&quot;,&quot;});&quot;,null,null,&quot;/**&quot;,&quot; * Accepts a browser event object and creates a patched, cross browser event&quot;,&quot; * object.&quot;,&quot; * @param {Event} e Browser event object.&quot;,&quot; * @param {EventTarget=} opt_currentTarget Current target for event.&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent.prototype.init = function(e, opt_currentTarget) {&quot;,&quot;  var type = this.type = e.type;&quot;,null,&quot;  /**&quot;,&quot;   * On touch devices use the first \&quot;changed touch\&quot; as the relevant touch.&quot;,&quot;   * @type {Touch}&quot;,&quot;   */&quot;,&quot;  var relevantTouch = e.changedTouches ? e.changedTouches[0] : null;&quot;,null,&quot;  // TODO(nicksantos): Change this.target to type EventTarget.&quot;,&quot;  this.target = /** @type {Node} */ (e.target) || e.srcElement;&quot;,null,&quot;  // TODO(nicksantos): Change this.currentTarget to type EventTarget.&quot;,&quot;  this.currentTarget = /** @type {Node} */ (opt_currentTarget);&quot;,null,&quot;  var relatedTarget = /** @type {Node} */ (e.relatedTarget);&quot;,&quot;  if (relatedTarget) {&quot;,&quot;    // There&#39;s a bug in FireFox where sometimes, relatedTarget will be a&quot;,&quot;    // chrome element, and accessing any property of it will get a permission&quot;,&quot;    // denied exception. See:&quot;,&quot;    // https://bugzilla.mozilla.org/show_bug.cgi?id=497780&quot;,&quot;    if (goog.userAgent.GECKO) {&quot;,&quot;      if (!goog.reflect.canAccessProperty(relatedTarget, &#39;nodeName&#39;)) {&quot;,&quot;        relatedTarget = null;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  } else if (type == goog.events.EventType.MOUSEOVER) {&quot;,&quot;    relatedTarget = e.fromElement;&quot;,&quot;  } else if (type == goog.events.EventType.MOUSEOUT) {&quot;,&quot;    relatedTarget = e.toElement;&quot;,&quot;  }&quot;,null,&quot;  this.relatedTarget = relatedTarget;&quot;,null,&quot;  if (!goog.isNull(relevantTouch)) {&quot;,&quot;    this.clientX = relevantTouch.clientX !== undefined ? relevantTouch.clientX :&quot;,&quot;                                                         relevantTouch.pageX;&quot;,&quot;    this.clientY = relevantTouch.clientY !== undefined ? relevantTouch.clientY :&quot;,&quot;                                                         relevantTouch.pageY;&quot;,&quot;    this.screenX = relevantTouch.screenX || 0;&quot;,&quot;    this.screenY = relevantTouch.screenY || 0;&quot;,&quot;  } else {&quot;,&quot;    // Webkit emits a lame warning whenever layerX/layerY is accessed.&quot;,&quot;    // http://code.google.com/p/chromium/issues/detail?id=101733&quot;,&quot;    this.offsetX = (goog.userAgent.WEBKIT || e.offsetX !== undefined) ?&quot;,&quot;        e.offsetX :&quot;,&quot;        e.layerX;&quot;,&quot;    this.offsetY = (goog.userAgent.WEBKIT || e.offsetY !== undefined) ?&quot;,&quot;        e.offsetY :&quot;,&quot;        e.layerY;&quot;,&quot;    this.clientX = e.clientX !== undefined ? e.clientX : e.pageX;&quot;,&quot;    this.clientY = e.clientY !== undefined ? e.clientY : e.pageY;&quot;,&quot;    this.screenX = e.screenX || 0;&quot;,&quot;    this.screenY = e.screenY || 0;&quot;,&quot;  }&quot;,null,&quot;  this.button = e.button;&quot;,null,&quot;  this.keyCode = e.keyCode || 0;&quot;,&quot;  this.key = e.key || &#39;&#39;;&quot;,&quot;  this.charCode = e.charCode || (type == &#39;keypress&#39; ? e.keyCode : 0);&quot;,&quot;  this.ctrlKey = e.ctrlKey;&quot;,&quot;  this.altKey = e.altKey;&quot;,&quot;  this.shiftKey = e.shiftKey;&quot;,&quot;  this.metaKey = e.metaKey;&quot;,&quot;  this.platformModifierKey = goog.userAgent.MAC ? e.metaKey : e.ctrlKey;&quot;,&quot;  this.pointerId = e.pointerId || 0;&quot;,&quot;  this.pointerType = goog.events.BrowserEvent.getPointerType_(e);&quot;,&quot;  this.state = e.state;&quot;,&quot;  this.event_ = e;&quot;,&quot;  if (e.defaultPrevented) {&quot;,&quot;    this.preventDefault();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Tests to see which button was pressed during the event. This is really only&quot;,&quot; * useful in IE and Gecko browsers. And in IE, it&#39;s only useful for&quot;,&quot; * mousedown/mouseup events, because click only fires for the left mouse button.&quot;,&quot; *&quot;,&quot; * Safari 2 only reports the left button being clicked, and uses the value &#39;1&#39;&quot;,&quot; * instead of 0. Opera only reports a mousedown event for the middle button, and&quot;,&quot; * no mouse events for the right button. Opera has default behavior for left and&quot;,&quot; * middle click that can only be overridden via a configuration setting.&quot;,&quot; *&quot;,&quot; * There&#39;s a nice table of this mess at http://www.unixpapa.com/js/mouse.html.&quot;,&quot; *&quot;,&quot; * @param {goog.events.BrowserEvent.MouseButton} button The button&quot;,&quot; *     to test for.&quot;,&quot; * @return {boolean} True if button was pressed.&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent.prototype.isButton = function(button) {&quot;,&quot;  if (!goog.events.BrowserFeature.HAS_W3C_BUTTON) {&quot;,&quot;    if (this.type == &#39;click&#39;) {&quot;,&quot;      return button == goog.events.BrowserEvent.MouseButton.LEFT;&quot;,&quot;    } else {&quot;,&quot;      return !!(&quot;,&quot;          this.event_.button &amp; goog.events.BrowserEvent.IE_BUTTON_MAP[button]);&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    return this.event_.button == button;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Whether this has an \&quot;action\&quot;-producing mouse button.&quot;,&quot; *&quot;,&quot; * By definition, this includes left-click on windows/linux, and left-click&quot;,&quot; * without the ctrl key on Macs.&quot;,&quot; *&quot;,&quot; * @return {boolean} The result.&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent.prototype.isMouseActionButton = function() {&quot;,&quot;  // Webkit does not ctrl+click to be a right-click, so we&quot;,&quot;  // normalize it to behave like Gecko and Opera.&quot;,&quot;  return this.isButton(goog.events.BrowserEvent.MouseButton.LEFT) &amp;&amp;&quot;,&quot;      !(goog.userAgent.WEBKIT &amp;&amp; goog.userAgent.MAC &amp;&amp; this.ctrlKey);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @override&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent.prototype.stopPropagation = function() {&quot;,&quot;  goog.events.BrowserEvent.superClass_.stopPropagation.call(this);&quot;,&quot;  if (this.event_.stopPropagation) {&quot;,&quot;    this.event_.stopPropagation();&quot;,&quot;  } else {&quot;,&quot;    this.event_.cancelBubble = true;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @override&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent.prototype.preventDefault = function() {&quot;,&quot;  goog.events.BrowserEvent.superClass_.preventDefault.call(this);&quot;,&quot;  var be = this.event_;&quot;,&quot;  if (!be.preventDefault) {&quot;,&quot;    be.returnValue = false;&quot;,&quot;    if (goog.events.BrowserFeature.SET_KEY_CODE_TO_PREVENT_DEFAULT) {&quot;,null,&quot;      try {&quot;,&quot;        // Most keys can be prevented using returnValue. Some special keys&quot;,&quot;        // require setting the keyCode to -1 as well:&quot;,&quot;        //&quot;,&quot;        // In IE7:&quot;,&quot;        // F3, F5, F10, F11, Ctrl+P, Crtl+O, Ctrl+F (these are taken from IE6)&quot;,&quot;        //&quot;,&quot;        // In IE8:&quot;,&quot;        // Ctrl+P, Crtl+O, Ctrl+F (F1-F12 cannot be stopped through the event)&quot;,&quot;        //&quot;,&quot;        // We therefore do this for all function keys as well as when Ctrl key&quot;,&quot;        // is pressed.&quot;,&quot;        var VK_F1 = 112;&quot;,&quot;        var VK_F12 = 123;&quot;,&quot;        if (be.ctrlKey || be.keyCode &gt;= VK_F1 &amp;&amp; be.keyCode &lt;= VK_F12) {&quot;,&quot;          be.keyCode = -1;&quot;,&quot;        }&quot;,&quot;      } catch (ex) {&quot;,&quot;        // IE throws an &#39;access denied&#39; exception when trying to change&quot;,&quot;        // keyCode in some situations (e.g. srcElement is input[type=file],&quot;,&quot;        // or srcElement is an anchor tag rewritten by parent&#39;s innerHTML).&quot;,&quot;        // Do nothing in this case.&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    be.preventDefault();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {Event} The underlying browser event object.&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent.prototype.getBrowserEvent = function() {&quot;,&quot;  return this.event_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Extracts the pointer type from the given event.&quot;,&quot; * @param {!Event} e&quot;,&quot; * @return {string} The pointer type, e.g. &#39;mouse&#39;, &#39;pen&#39;, or &#39;touch&#39;.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.BrowserEvent.getPointerType_ = function(e) {&quot;,&quot;  if (goog.isString(e.pointerType)) {&quot;,&quot;    return e.pointerType;&quot;,&quot;  }&quot;,&quot;  // IE10 uses integer codes for pointer type.&quot;,&quot;  // https://msdn.microsoft.com/en-us/library/hh772359(v=vs.85).aspx&quot;,&quot;  return goog.events.BrowserEvent.IE_POINTER_TYPE_MAP[e.pointerType] || &#39;&#39;;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>