<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>listenable.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;listenable.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/events/listenable.js&quot;,[&quot;// Copyright 2012 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview An interface for a listenable JavaScript object.&quot;,&quot; * @author chrishenry@google.com (Chris Henry)&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.events.Listenable&#39;);&quot;,&quot;goog.provide(&#39;goog.events.ListenableKey&#39;);&quot;,null,&quot;/** @suppress {extraRequire} */&quot;,&quot;goog.require(&#39;goog.events.EventId&#39;);&quot;,null,&quot;goog.forwardDeclare(&#39;goog.events.EventLike&#39;);&quot;,&quot;goog.forwardDeclare(&#39;goog.events.EventTarget&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * A listenable interface. A listenable is an object with the ability&quot;,&quot; * to dispatch/broadcast events to \&quot;event listeners\&quot; registered via&quot;,&quot; * listen/listenOnce.&quot;,&quot; *&quot;,&quot; * The interface allows for an event propagation mechanism similar&quot;,&quot; * to one offered by native browser event targets, such as&quot;,&quot; * capture/bubble mechanism, stopping propagation, and preventing&quot;,&quot; * default actions. Capture/bubble mechanism depends on the ancestor&quot;,&quot; * tree constructed via {@code #getParentEventTarget}; this tree&quot;,&quot; * must be directed acyclic graph. The meaning of default action(s)&quot;,&quot; * in preventDefault is specific to a particular use case.&quot;,&quot; *&quot;,&quot; * Implementations that do not support capture/bubble or can not have&quot;,&quot; * a parent listenable can simply not implement any ability to set the&quot;,&quot; * parent listenable (and have {@code #getParentEventTarget} return&quot;,&quot; * null).&quot;,&quot; *&quot;,&quot; * Implementation of this class can be used with or independently from&quot;,&quot; * goog.events.&quot;,&quot; *&quot;,&quot; * Implementation must call {@code #addImplementation(implClass)}.&quot;,&quot; *&quot;,&quot; * @interface&quot;,&quot; * @see goog.events&quot;,&quot; * @see http://www.w3.org/TR/DOM-Level-2-Events/events.html&quot;,&quot; */&quot;,&quot;goog.events.Listenable = function() {};&quot;,null,null,&quot;/**&quot;,&quot; * An expando property to indicate that an object implements&quot;,&quot; * goog.events.Listenable.&quot;,&quot; *&quot;,&quot; * See addImplementation/isImplementedBy.&quot;,&quot; *&quot;,&quot; * @type {string}&quot;,&quot; * @const&quot;,&quot; */&quot;,&quot;goog.events.Listenable.IMPLEMENTED_BY_PROP =&quot;,&quot;    &#39;closure_listenable_&#39; + ((Math.random() * 1e6) | 0);&quot;,null,null,&quot;/**&quot;,&quot; * Marks a given class (constructor) as an implementation of&quot;,&quot; * Listenable, do that we can query that fact at runtime. The class&quot;,&quot; * must have already implemented the interface.&quot;,&quot; * @param {!function(new:goog.events.Listenable,...)} cls The class constructor.&quot;,&quot; *     The corresponding class must have already implemented the interface.&quot;,&quot; */&quot;,&quot;goog.events.Listenable.addImplementation = function(cls) {&quot;,&quot;  cls.prototype[goog.events.Listenable.IMPLEMENTED_BY_PROP] = true;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {Object} obj The object to check.&quot;,&quot; * @return {boolean} Whether a given instance implements Listenable. The&quot;,&quot; *     class/superclass of the instance must call addImplementation.&quot;,&quot; */&quot;,&quot;goog.events.Listenable.isImplementedBy = function(obj) {&quot;,&quot;  return !!(obj &amp;&amp; obj[goog.events.Listenable.IMPLEMENTED_BY_PROP]);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds an event listener. A listener can only be added once to an&quot;,&quot; * object and if it is added again the key for the listener is&quot;,&quot; * returned. Note that if the existing listener is a one-off listener&quot;,&quot; * (registered via listenOnce), it will no longer be a one-off&quot;,&quot; * listener after a call to listen().&quot;,&quot; *&quot;,&quot; * @param {string|!goog.events.EventId&lt;EVENTOBJ&gt;} type The event type id.&quot;,&quot; * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback&quot;,&quot; *     method.&quot;,&quot; * @param {boolean=} opt_useCapture Whether to fire in capture phase&quot;,&quot; *     (defaults to false).&quot;,&quot; * @param {SCOPE=} opt_listenerScope Object in whose scope to call the&quot;,&quot; *     listener.&quot;,&quot; * @return {!goog.events.ListenableKey} Unique key for the listener.&quot;,&quot; * @template SCOPE,EVENTOBJ&quot;,&quot; */&quot;,&quot;goog.events.Listenable.prototype.listen;&quot;,null,null,&quot;/**&quot;,&quot; * Adds an event listener that is removed automatically after the&quot;,&quot; * listener fired once.&quot;,&quot; *&quot;,&quot; * If an existing listener already exists, listenOnce will do&quot;,&quot; * nothing. In particular, if the listener was previously registered&quot;,&quot; * via listen(), listenOnce() will not turn the listener into a&quot;,&quot; * one-off listener. Similarly, if there is already an existing&quot;,&quot; * one-off listener, listenOnce does not modify the listeners (it is&quot;,&quot; * still a once listener).&quot;,&quot; *&quot;,&quot; * @param {string|!goog.events.EventId&lt;EVENTOBJ&gt;} type The event type id.&quot;,&quot; * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback&quot;,&quot; *     method.&quot;,&quot; * @param {boolean=} opt_useCapture Whether to fire in capture phase&quot;,&quot; *     (defaults to false).&quot;,&quot; * @param {SCOPE=} opt_listenerScope Object in whose scope to call the&quot;,&quot; *     listener.&quot;,&quot; * @return {!goog.events.ListenableKey} Unique key for the listener.&quot;,&quot; * @template SCOPE,EVENTOBJ&quot;,&quot; */&quot;,&quot;goog.events.Listenable.prototype.listenOnce;&quot;,null,null,&quot;/**&quot;,&quot; * Removes an event listener which was added with listen() or listenOnce().&quot;,&quot; *&quot;,&quot; * @param {string|!goog.events.EventId&lt;EVENTOBJ&gt;} type The event type id.&quot;,&quot; * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback&quot;,&quot; *     method.&quot;,&quot; * @param {boolean=} opt_useCapture Whether to fire in capture phase&quot;,&quot; *     (defaults to false).&quot;,&quot; * @param {SCOPE=} opt_listenerScope Object in whose scope to call&quot;,&quot; *     the listener.&quot;,&quot; * @return {boolean} Whether any listener was removed.&quot;,&quot; * @template SCOPE,EVENTOBJ&quot;,&quot; */&quot;,&quot;goog.events.Listenable.prototype.unlisten;&quot;,null,null,&quot;/**&quot;,&quot; * Removes an event listener which was added with listen() by the key&quot;,&quot; * returned by listen().&quot;,&quot; *&quot;,&quot; * @param {!goog.events.ListenableKey} key The key returned by&quot;,&quot; *     listen() or listenOnce().&quot;,&quot; * @return {boolean} Whether any listener was removed.&quot;,&quot; */&quot;,&quot;goog.events.Listenable.prototype.unlistenByKey;&quot;,null,null,&quot;/**&quot;,&quot; * Dispatches an event (or event like object) and calls all listeners&quot;,&quot; * listening for events of this type. The type of the event is decided by the&quot;,&quot; * type property on the event object.&quot;,&quot; *&quot;,&quot; * If any of the listeners returns false OR calls preventDefault then this&quot;,&quot; * function will return false.  If one of the capture listeners calls&quot;,&quot; * stopPropagation, then the bubble listeners won&#39;t fire.&quot;,&quot; *&quot;,&quot; * @param {goog.events.EventLike} e Event object.&quot;,&quot; * @return {boolean} If anyone called preventDefault on the event object (or&quot;,&quot; *     if any of the listeners returns false) this will also return false.&quot;,&quot; */&quot;,&quot;goog.events.Listenable.prototype.dispatchEvent;&quot;,null,null,&quot;/**&quot;,&quot; * Removes all listeners from this listenable. If type is specified,&quot;,&quot; * it will only remove listeners of the particular type. otherwise all&quot;,&quot; * registered listeners will be removed.&quot;,&quot; *&quot;,&quot; * @param {string=} opt_type Type of event to remove, default is to&quot;,&quot; *     remove all types.&quot;,&quot; * @return {number} Number of listeners removed.&quot;,&quot; */&quot;,&quot;goog.events.Listenable.prototype.removeAllListeners;&quot;,null,null,&quot;/**&quot;,&quot; * Returns the parent of this event target to use for capture/bubble&quot;,&quot; * mechanism.&quot;,&quot; *&quot;,&quot; * NOTE(chrishenry): The name reflects the original implementation of&quot;,&quot; * custom event target ({@code goog.events.EventTarget}). We decided&quot;,&quot; * that changing the name is not worth it.&quot;,&quot; *&quot;,&quot; * @return {goog.events.Listenable} The parent EventTarget or null if&quot;,&quot; *     there is no parent.&quot;,&quot; */&quot;,&quot;goog.events.Listenable.prototype.getParentEventTarget;&quot;,null,null,&quot;/**&quot;,&quot; * Fires all registered listeners in this listenable for the given&quot;,&quot; * type and capture mode, passing them the given eventObject. This&quot;,&quot; * does not perform actual capture/bubble. Only implementors of the&quot;,&quot; * interface should be using this.&quot;,&quot; *&quot;,&quot; * @param {string|!goog.events.EventId&lt;EVENTOBJ&gt;} type The type of the&quot;,&quot; *     listeners to fire.&quot;,&quot; * @param {boolean} capture The capture mode of the listeners to fire.&quot;,&quot; * @param {EVENTOBJ} eventObject The event object to fire.&quot;,&quot; * @return {boolean} Whether all listeners succeeded without&quot;,&quot; *     attempting to prevent default behavior. If any listener returns&quot;,&quot; *     false or called goog.events.Event#preventDefault, this returns&quot;,&quot; *     false.&quot;,&quot; * @template EVENTOBJ&quot;,&quot; */&quot;,&quot;goog.events.Listenable.prototype.fireListeners;&quot;,null,null,&quot;/**&quot;,&quot; * Gets all listeners in this listenable for the given type and&quot;,&quot; * capture mode.&quot;,&quot; *&quot;,&quot; * @param {string|!goog.events.EventId} type The type of the listeners to fire.&quot;,&quot; * @param {boolean} capture The capture mode of the listeners to fire.&quot;,&quot; * @return {!Array&lt;!goog.events.ListenableKey&gt;} An array of registered&quot;,&quot; *     listeners.&quot;,&quot; * @template EVENTOBJ&quot;,&quot; */&quot;,&quot;goog.events.Listenable.prototype.getListeners;&quot;,null,null,&quot;/**&quot;,&quot; * Gets the goog.events.ListenableKey for the event or null if no such&quot;,&quot; * listener is in use.&quot;,&quot; *&quot;,&quot; * @param {string|!goog.events.EventId&lt;EVENTOBJ&gt;} type The name of the event&quot;,&quot; *     without the &#39;on&#39; prefix.&quot;,&quot; * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener The&quot;,&quot; *     listener function to get.&quot;,&quot; * @param {boolean} capture Whether the listener is a capturing listener.&quot;,&quot; * @param {SCOPE=} opt_listenerScope Object in whose scope to call the&quot;,&quot; *     listener.&quot;,&quot; * @return {goog.events.ListenableKey} the found listener or null if not found.&quot;,&quot; * @template SCOPE,EVENTOBJ&quot;,&quot; */&quot;,&quot;goog.events.Listenable.prototype.getListener;&quot;,null,null,&quot;/**&quot;,&quot; * Whether there is any active listeners matching the specified&quot;,&quot; * signature. If either the type or capture parameters are&quot;,&quot; * unspecified, the function will match on the remaining criteria.&quot;,&quot; *&quot;,&quot; * @param {string|!goog.events.EventId&lt;EVENTOBJ&gt;=} opt_type Event type.&quot;,&quot; * @param {boolean=} opt_capture Whether to check for capture or bubble&quot;,&quot; *     listeners.&quot;,&quot; * @return {boolean} Whether there is any active listeners matching&quot;,&quot; *     the requested type and/or capture phase.&quot;,&quot; * @template EVENTOBJ&quot;,&quot; */&quot;,&quot;goog.events.Listenable.prototype.hasListener;&quot;,null,null,null,&quot;/**&quot;,&quot; * An interface that describes a single registered listener.&quot;,&quot; * @interface&quot;,&quot; */&quot;,&quot;goog.events.ListenableKey = function() {};&quot;,null,null,&quot;/**&quot;,&quot; * Counter used to create a unique key&quot;,&quot; * @type {number}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.ListenableKey.counter_ = 0;&quot;,null,null,&quot;/**&quot;,&quot; * Reserves a key to be used for ListenableKey#key field.&quot;,&quot; * @return {number} A number to be used to fill ListenableKey#key&quot;,&quot; *     field.&quot;,&quot; */&quot;,&quot;goog.events.ListenableKey.reserveKey = function() {&quot;,&quot;  return ++goog.events.ListenableKey.counter_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * The source event target.&quot;,&quot; * @type {Object|goog.events.Listenable|goog.events.EventTarget}&quot;,&quot; */&quot;,&quot;goog.events.ListenableKey.prototype.src;&quot;,null,null,&quot;/**&quot;,&quot; * The event type the listener is listening to.&quot;,&quot; * @type {string}&quot;,&quot; */&quot;,&quot;goog.events.ListenableKey.prototype.type;&quot;,null,null,&quot;/**&quot;,&quot; * The listener function.&quot;,&quot; * @type {function(?):?|{handleEvent:function(?):?}|null}&quot;,&quot; */&quot;,&quot;goog.events.ListenableKey.prototype.listener;&quot;,null,null,&quot;/**&quot;,&quot; * Whether the listener works on capture phase.&quot;,&quot; * @type {boolean}&quot;,&quot; */&quot;,&quot;goog.events.ListenableKey.prototype.capture;&quot;,null,null,&quot;/**&quot;,&quot; * The &#39;this&#39; object for the listener function&#39;s scope.&quot;,&quot; * @type {Object|undefined}&quot;,&quot; */&quot;,&quot;goog.events.ListenableKey.prototype.handler;&quot;,null,null,&quot;/**&quot;,&quot; * A globally unique number to identify the key.&quot;,&quot; * @type {number}&quot;,&quot; */&quot;,&quot;goog.events.ListenableKey.prototype.key;&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>