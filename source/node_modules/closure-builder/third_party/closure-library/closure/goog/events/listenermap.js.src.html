<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>listenermap.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;listenermap.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/events/listenermap.js&quot;,[&quot;// Copyright 2013 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview A map of listeners that provides utility functions to&quot;,&quot; * deal with listeners on an event target. Used by&quot;,&quot; * {@code goog.events.EventTarget}.&quot;,&quot; *&quot;,&quot; * WARNING: Do not use this class from outside goog.events package.&quot;,&quot; *&quot;,&quot; * @visibility {//closure/goog/bin/sizetests:__pkg__}&quot;,&quot; * @visibility {//closure/goog:__pkg__}&quot;,&quot; * @visibility {//closure/goog/events:__pkg__}&quot;,&quot; * @visibility {//closure/goog/labs/events:__pkg__}&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.events.ListenerMap&#39;);&quot;,null,&quot;goog.require(&#39;goog.array&#39;);&quot;,&quot;goog.require(&#39;goog.events.Listener&#39;);&quot;,&quot;goog.require(&#39;goog.object&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * Creates a new listener map.&quot;,&quot; * @param {EventTarget|goog.events.Listenable} src The src object.&quot;,&quot; * @constructor&quot;,&quot; * @final&quot;,&quot; */&quot;,&quot;goog.events.ListenerMap = function(src) {&quot;,&quot;  /** @type {EventTarget|goog.events.Listenable} */&quot;,&quot;  this.src = src;&quot;,null,&quot;  /**&quot;,&quot;   * Maps of event type to an array of listeners.&quot;,&quot;   * @type {!Object&lt;string, !Array&lt;!goog.events.Listener&gt;&gt;}&quot;,&quot;   */&quot;,&quot;  this.listeners = {};&quot;,null,&quot;  /**&quot;,&quot;   * The count of types in this map that have registered listeners.&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.typeCount_ = 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {number} The count of event types in this map that actually&quot;,&quot; *     have registered listeners.&quot;,&quot; */&quot;,&quot;goog.events.ListenerMap.prototype.getTypeCount = function() {&quot;,&quot;  return this.typeCount_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {number} Total number of registered listeners.&quot;,&quot; */&quot;,&quot;goog.events.ListenerMap.prototype.getListenerCount = function() {&quot;,&quot;  var count = 0;&quot;,&quot;  for (var type in this.listeners) {&quot;,&quot;    count += this.listeners[type].length;&quot;,&quot;  }&quot;,&quot;  return count;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds an event listener. A listener can only be added once to an&quot;,&quot; * object and if it is added again the key for the listener is&quot;,&quot; * returned.&quot;,&quot; *&quot;,&quot; * Note that a one-off listener will not change an existing listener,&quot;,&quot; * if any. On the other hand a normal listener will change existing&quot;,&quot; * one-off listener to become a normal listener.&quot;,&quot; *&quot;,&quot; * @param {string|!goog.events.EventId} type The listener event type.&quot;,&quot; * @param {!Function} listener This listener callback method.&quot;,&quot; * @param {boolean} callOnce Whether the listener is a one-off&quot;,&quot; *     listener.&quot;,&quot; * @param {boolean=} opt_useCapture The capture mode of the listener.&quot;,&quot; * @param {Object=} opt_listenerScope Object in whose scope to call the&quot;,&quot; *     listener.&quot;,&quot; * @return {!goog.events.ListenableKey} Unique key for the listener.&quot;,&quot; */&quot;,&quot;goog.events.ListenerMap.prototype.add = function(&quot;,&quot;    type, listener, callOnce, opt_useCapture, opt_listenerScope) {&quot;,&quot;  var typeStr = type.toString();&quot;,&quot;  var listenerArray = this.listeners[typeStr];&quot;,&quot;  if (!listenerArray) {&quot;,&quot;    listenerArray = this.listeners[typeStr] = [];&quot;,&quot;    this.typeCount_++;&quot;,&quot;  }&quot;,null,&quot;  var listenerObj;&quot;,&quot;  var index = goog.events.ListenerMap.findListenerIndex_(&quot;,&quot;      listenerArray, listener, opt_useCapture, opt_listenerScope);&quot;,&quot;  if (index &gt; -1) {&quot;,&quot;    listenerObj = listenerArray[index];&quot;,&quot;    if (!callOnce) {&quot;,&quot;      // Ensure that, if there is an existing callOnce listener, it is no&quot;,&quot;      // longer a callOnce listener.&quot;,&quot;      listenerObj.callOnce = false;&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    listenerObj = new goog.events.Listener(&quot;,&quot;        listener, null, this.src, typeStr, !!opt_useCapture, opt_listenerScope);&quot;,&quot;    listenerObj.callOnce = callOnce;&quot;,&quot;    listenerArray.push(listenerObj);&quot;,&quot;  }&quot;,&quot;  return listenerObj;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes a matching listener.&quot;,&quot; * @param {string|!goog.events.EventId} type The listener event type.&quot;,&quot; * @param {!Function} listener This listener callback method.&quot;,&quot; * @param {boolean=} opt_useCapture The capture mode of the listener.&quot;,&quot; * @param {Object=} opt_listenerScope Object in whose scope to call the&quot;,&quot; *     listener.&quot;,&quot; * @return {boolean} Whether any listener was removed.&quot;,&quot; */&quot;,&quot;goog.events.ListenerMap.prototype.remove = function(&quot;,&quot;    type, listener, opt_useCapture, opt_listenerScope) {&quot;,&quot;  var typeStr = type.toString();&quot;,&quot;  if (!(typeStr in this.listeners)) {&quot;,&quot;    return false;&quot;,&quot;  }&quot;,null,&quot;  var listenerArray = this.listeners[typeStr];&quot;,&quot;  var index = goog.events.ListenerMap.findListenerIndex_(&quot;,&quot;      listenerArray, listener, opt_useCapture, opt_listenerScope);&quot;,&quot;  if (index &gt; -1) {&quot;,&quot;    var listenerObj = listenerArray[index];&quot;,&quot;    listenerObj.markAsRemoved();&quot;,&quot;    goog.array.removeAt(listenerArray, index);&quot;,&quot;    if (listenerArray.length == 0) {&quot;,&quot;      delete this.listeners[typeStr];&quot;,&quot;      this.typeCount_--;&quot;,&quot;    }&quot;,&quot;    return true;&quot;,&quot;  }&quot;,&quot;  return false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes the given listener object.&quot;,&quot; * @param {!goog.events.ListenableKey} listener The listener to remove.&quot;,&quot; * @return {boolean} Whether the listener is removed.&quot;,&quot; */&quot;,&quot;goog.events.ListenerMap.prototype.removeByKey = function(listener) {&quot;,&quot;  var type = listener.type;&quot;,&quot;  if (!(type in this.listeners)) {&quot;,&quot;    return false;&quot;,&quot;  }&quot;,null,&quot;  var removed = goog.array.remove(this.listeners[type], listener);&quot;,&quot;  if (removed) {&quot;,&quot;    /** @type {!goog.events.Listener} */ (listener).markAsRemoved();&quot;,&quot;    if (this.listeners[type].length == 0) {&quot;,&quot;      delete this.listeners[type];&quot;,&quot;      this.typeCount_--;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return removed;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes all listeners from this map. If opt_type is provided, only&quot;,&quot; * listeners that match the given type are removed.&quot;,&quot; * @param {string|!goog.events.EventId=} opt_type Type of event to remove.&quot;,&quot; * @return {number} Number of listeners removed.&quot;,&quot; */&quot;,&quot;goog.events.ListenerMap.prototype.removeAll = function(opt_type) {&quot;,&quot;  var typeStr = opt_type &amp;&amp; opt_type.toString();&quot;,&quot;  var count = 0;&quot;,&quot;  for (var type in this.listeners) {&quot;,&quot;    if (!typeStr || type == typeStr) {&quot;,&quot;      var listenerArray = this.listeners[type];&quot;,&quot;      for (var i = 0; i &lt; listenerArray.length; i++) {&quot;,&quot;        ++count;&quot;,&quot;        listenerArray[i].markAsRemoved();&quot;,&quot;      }&quot;,&quot;      delete this.listeners[type];&quot;,&quot;      this.typeCount_--;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return count;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets all listeners that match the given type and capture mode. The&quot;,&quot; * returned array is a copy (but the listener objects are not).&quot;,&quot; * @param {string|!goog.events.EventId} type The type of the listeners&quot;,&quot; *     to retrieve.&quot;,&quot; * @param {boolean} capture The capture mode of the listeners to retrieve.&quot;,&quot; * @return {!Array&lt;!goog.events.ListenableKey&gt;} An array of matching&quot;,&quot; *     listeners.&quot;,&quot; */&quot;,&quot;goog.events.ListenerMap.prototype.getListeners = function(type, capture) {&quot;,&quot;  var listenerArray = this.listeners[type.toString()];&quot;,&quot;  var rv = [];&quot;,&quot;  if (listenerArray) {&quot;,&quot;    for (var i = 0; i &lt; listenerArray.length; ++i) {&quot;,&quot;      var listenerObj = listenerArray[i];&quot;,&quot;      if (listenerObj.capture == capture) {&quot;,&quot;        rv.push(listenerObj);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return rv;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the goog.events.ListenableKey for the event or null if no such&quot;,&quot; * listener is in use.&quot;,&quot; *&quot;,&quot; * @param {string|!goog.events.EventId} type The type of the listener&quot;,&quot; *     to retrieve.&quot;,&quot; * @param {!Function} listener The listener function to get.&quot;,&quot; * @param {boolean} capture Whether the listener is a capturing listener.&quot;,&quot; * @param {Object=} opt_listenerScope Object in whose scope to call the&quot;,&quot; *     listener.&quot;,&quot; * @return {goog.events.ListenableKey} the found listener or null if not found.&quot;,&quot; */&quot;,&quot;goog.events.ListenerMap.prototype.getListener = function(&quot;,&quot;    type, listener, capture, opt_listenerScope) {&quot;,&quot;  var listenerArray = this.listeners[type.toString()];&quot;,&quot;  var i = -1;&quot;,&quot;  if (listenerArray) {&quot;,&quot;    i = goog.events.ListenerMap.findListenerIndex_(&quot;,&quot;        listenerArray, listener, capture, opt_listenerScope);&quot;,&quot;  }&quot;,&quot;  return i &gt; -1 ? listenerArray[i] : null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Whether there is a matching listener. If either the type or capture&quot;,&quot; * parameters are unspecified, the function will match on the&quot;,&quot; * remaining criteria.&quot;,&quot; *&quot;,&quot; * @param {string|!goog.events.EventId=} opt_type The type of the listener.&quot;,&quot; * @param {boolean=} opt_capture The capture mode of the listener.&quot;,&quot; * @return {boolean} Whether there is an active listener matching&quot;,&quot; *     the requested type and/or capture phase.&quot;,&quot; */&quot;,&quot;goog.events.ListenerMap.prototype.hasListener = function(&quot;,&quot;    opt_type, opt_capture) {&quot;,&quot;  var hasType = goog.isDef(opt_type);&quot;,&quot;  var typeStr = hasType ? opt_type.toString() : &#39;&#39;;&quot;,&quot;  var hasCapture = goog.isDef(opt_capture);&quot;,null,&quot;  return goog.object.some(this.listeners, function(listenerArray, type) {&quot;,&quot;    for (var i = 0; i &lt; listenerArray.length; ++i) {&quot;,&quot;      if ((!hasType || listenerArray[i].type == typeStr) &amp;&amp;&quot;,&quot;          (!hasCapture || listenerArray[i].capture == opt_capture)) {&quot;,&quot;        return true;&quot;,&quot;      }&quot;,&quot;    }&quot;,null,&quot;    return false;&quot;,&quot;  });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Finds the index of a matching goog.events.Listener in the given&quot;,&quot; * listenerArray.&quot;,&quot; * @param {!Array&lt;!goog.events.Listener&gt;} listenerArray Array of listener.&quot;,&quot; * @param {!Function} listener The listener function.&quot;,&quot; * @param {boolean=} opt_useCapture The capture flag for the listener.&quot;,&quot; * @param {Object=} opt_listenerScope The listener scope.&quot;,&quot; * @return {number} The index of the matching listener within the&quot;,&quot; *     listenerArray.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.ListenerMap.findListenerIndex_ = function(&quot;,&quot;    listenerArray, listener, opt_useCapture, opt_listenerScope) {&quot;,&quot;  for (var i = 0; i &lt; listenerArray.length; ++i) {&quot;,&quot;    var listenerObj = listenerArray[i];&quot;,&quot;    if (!listenerObj.removed &amp;&amp; listenerObj.listener == listener &amp;&amp;&quot;,&quot;        listenerObj.capture == !!opt_useCapture &amp;&amp;&quot;,&quot;        listenerObj.handler == opt_listenerScope) {&quot;,&quot;      return i;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return -1;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>