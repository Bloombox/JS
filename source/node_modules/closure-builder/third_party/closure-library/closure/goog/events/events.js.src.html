<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>events.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;events.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/events/events.js&quot;,[&quot;// Copyright 2005 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview An event manager for both native browser event&quot;,&quot; * targets and custom JavaScript event targets&quot;,&quot; * ({@code goog.events.Listenable}). This provides an abstraction&quot;,&quot; * over browsers&#39; event systems.&quot;,&quot; *&quot;,&quot; * It also provides a simulation of W3C event model&#39;s capture phase in&quot;,&quot; * Internet Explorer (IE 8 and below). Caveat: the simulation does not&quot;,&quot; * interact well with listeners registered directly on the elements&quot;,&quot; * (bypassing goog.events) or even with listeners registered via&quot;,&quot; * goog.events in a separate JS binary. In these cases, we provide&quot;,&quot; * no ordering guarantees.&quot;,&quot; *&quot;,&quot; * The listeners will receive a \&quot;patched\&quot; event object. Such event object&quot;,&quot; * contains normalized values for certain event properties that differs in&quot;,&quot; * different browsers.&quot;,&quot; *&quot;,&quot; * Example usage:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; * goog.events.listen(myNode, &#39;click&#39;, function(e) { alert(&#39;woo&#39;) });&quot;,&quot; * goog.events.listen(myNode, &#39;mouseover&#39;, mouseHandler, true);&quot;,&quot; * goog.events.unlisten(myNode, &#39;mouseover&#39;, mouseHandler, true);&quot;,&quot; * goog.events.removeAll(myNode);&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; *                                            in IE and event object patching]&quot;,&quot; * @author arv@google.com (Erik Arvidsson)&quot;,&quot; *&quot;,&quot; * @see ../demos/events.html&quot;,&quot; * @see ../demos/event-propagation.html&quot;,&quot; * @see ../demos/stopevent.html&quot;,&quot; */&quot;,null,&quot;// IMPLEMENTATION NOTES:&quot;,&quot;// goog.events stores an auxiliary data structure on each EventTarget&quot;,&quot;// source being listened on. This allows us to take advantage of GC,&quot;,&quot;// having the data structure GC&#39;d when the EventTarget is GC&#39;d. This&quot;,&quot;// GC behavior is equivalent to using W3C DOM Events directly.&quot;,null,&quot;goog.provide(&#39;goog.events&#39;);&quot;,&quot;goog.provide(&#39;goog.events.CaptureSimulationMode&#39;);&quot;,&quot;goog.provide(&#39;goog.events.Key&#39;);&quot;,&quot;goog.provide(&#39;goog.events.ListenableType&#39;);&quot;,null,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;goog.debug.entryPointRegistry&#39;);&quot;,&quot;goog.require(&#39;goog.events.BrowserEvent&#39;);&quot;,&quot;goog.require(&#39;goog.events.BrowserFeature&#39;);&quot;,&quot;goog.require(&#39;goog.events.Listenable&#39;);&quot;,&quot;goog.require(&#39;goog.events.ListenerMap&#39;);&quot;,null,&quot;goog.forwardDeclare(&#39;goog.debug.ErrorHandler&#39;);&quot;,&quot;goog.forwardDeclare(&#39;goog.events.EventWrapper&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * @typedef {number|goog.events.ListenableKey}&quot;,&quot; */&quot;,&quot;goog.events.Key;&quot;,null,null,&quot;/**&quot;,&quot; * @typedef {EventTarget|goog.events.Listenable}&quot;,&quot; */&quot;,&quot;goog.events.ListenableType;&quot;,null,null,&quot;/**&quot;,&quot; * Property name on a native event target for the listener map&quot;,&quot; * associated with the event target.&quot;,&quot; * @private @const {string}&quot;,&quot; */&quot;,&quot;goog.events.LISTENER_MAP_PROP_ = &#39;closure_lm_&#39; + ((Math.random() * 1e6) | 0);&quot;,null,null,&quot;/**&quot;,&quot; * String used to prepend to IE event types.&quot;,&quot; * @const&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.onString_ = &#39;on&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * Map of computed \&quot;on&lt;eventname&gt;\&quot; strings for IE event types. Caching&quot;,&quot; * this removes an extra object allocation in goog.events.listen which&quot;,&quot; * improves IE6 performance.&quot;,&quot; * @const&quot;,&quot; * @dict&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.onStringMap_ = {};&quot;,null,null,&quot;/**&quot;,&quot; * @enum {number} Different capture simulation mode for IE8-.&quot;,&quot; */&quot;,&quot;goog.events.CaptureSimulationMode = {&quot;,&quot;  /**&quot;,&quot;   * Does not perform capture simulation. Will asserts in IE8- when you&quot;,&quot;   * add capture listeners.&quot;,&quot;   */&quot;,&quot;  OFF_AND_FAIL: 0,&quot;,null,&quot;  /**&quot;,&quot;   * Does not perform capture simulation, silently ignore capture&quot;,&quot;   * listeners.&quot;,&quot;   */&quot;,&quot;  OFF_AND_SILENT: 1,&quot;,null,&quot;  /**&quot;,&quot;   * Performs capture simulation.&quot;,&quot;   */&quot;,&quot;  ON: 2&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @define {number} The capture simulation mode for IE8-. By default,&quot;,&quot; *     this is ON.&quot;,&quot; */&quot;,&quot;goog.define(&#39;goog.events.CAPTURE_SIMULATION_MODE&#39;, 2);&quot;,null,null,&quot;/**&quot;,&quot; * Estimated count of total native listeners.&quot;,&quot; * @private {number}&quot;,&quot; */&quot;,&quot;goog.events.listenerCountEstimate_ = 0;&quot;,null,null,&quot;/**&quot;,&quot; * Adds an event listener for a specific event on a native event&quot;,&quot; * target (such as a DOM element) or an object that has implemented&quot;,&quot; * {@link goog.events.Listenable}. A listener can only be added once&quot;,&quot; * to an object and if it is added again the key for the listener is&quot;,&quot; * returned. Note that if the existing listener is a one-off listener&quot;,&quot; * (registered via listenOnce), it will no longer be a one-off&quot;,&quot; * listener after a call to listen().&quot;,&quot; *&quot;,&quot; * @param {EventTarget|goog.events.Listenable} src The node to listen&quot;,&quot; *     to events on.&quot;,&quot; * @param {string|Array&lt;string&gt;|&quot;,&quot; *     !goog.events.EventId&lt;EVENTOBJ&gt;|!Array&lt;!goog.events.EventId&lt;EVENTOBJ&gt;&gt;}&quot;,&quot; *     type Event type or array of event types.&quot;,&quot; * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}&quot;,&quot; *     listener Callback method, or an object with a handleEvent function.&quot;,&quot; *     WARNING: passing an Object is now softly deprecated.&quot;,&quot; * @param {(boolean|!AddEventListenerOptions)=} opt_options&quot;,&quot; * @param {T=} opt_handler Element in whose scope to call the listener.&quot;,&quot; * @return {goog.events.Key} Unique key for the listener.&quot;,&quot; * @template T,EVENTOBJ&quot;,&quot; */&quot;,&quot;goog.events.listen = function(src, type, listener, opt_options, opt_handler) {&quot;,&quot;  if (opt_options &amp;&amp; opt_options.once) {&quot;,&quot;    return goog.events.listenOnce(&quot;,&quot;        src, type, listener, opt_options, opt_handler);&quot;,&quot;  }&quot;,&quot;  if (goog.isArray(type)) {&quot;,&quot;    for (var i = 0; i &lt; type.length; i++) {&quot;,&quot;      goog.events.listen(src, type[i], listener, opt_options, opt_handler);&quot;,&quot;    }&quot;,&quot;    return null;&quot;,&quot;  }&quot;,null,&quot;  listener = goog.events.wrapListener(listener);&quot;,&quot;  if (goog.events.Listenable.isImplementedBy(src)) {&quot;,&quot;    var capture =&quot;,&quot;        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;&quot;,&quot;    return src.listen(&quot;,&quot;        /** @type {string|!goog.events.EventId} */ (type), listener, capture,&quot;,&quot;        opt_handler);&quot;,&quot;  } else {&quot;,&quot;    return goog.events.listen_(&quot;,&quot;        /** @type {!EventTarget} */ (src), type, listener,&quot;,&quot;        /* callOnce */ false, opt_options, opt_handler);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds an event listener for a specific event on a native event&quot;,&quot; * target. A listener can only be added once to an object and if it&quot;,&quot; * is added again the key for the listener is returned.&quot;,&quot; *&quot;,&quot; * Note that a one-off listener will not change an existing listener,&quot;,&quot; * if any. On the other hand a normal listener will change existing&quot;,&quot; * one-off listener to become a normal listener.&quot;,&quot; *&quot;,&quot; * @param {EventTarget} src The node to listen to events on.&quot;,&quot; * @param {string|?goog.events.EventId&lt;EVENTOBJ&gt;} type Event type.&quot;,&quot; * @param {!Function} listener Callback function.&quot;,&quot; * @param {boolean} callOnce Whether the listener is a one-off&quot;,&quot; *     listener or otherwise.&quot;,&quot; * @param {(boolean|!AddEventListenerOptions)=} opt_options&quot;,&quot; * @param {Object=} opt_handler Element in whose scope to call the listener.&quot;,&quot; * @return {goog.events.ListenableKey} Unique key for the listener.&quot;,&quot; * @template EVENTOBJ&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.listen_ = function(&quot;,&quot;    src, type, listener, callOnce, opt_options, opt_handler) {&quot;,&quot;  if (!type) {&quot;,&quot;    throw new Error(&#39;Invalid event type&#39;);&quot;,&quot;  }&quot;,null,&quot;  var capture =&quot;,&quot;      goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;&quot;,&quot;  if (capture &amp;&amp; !goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {&quot;,&quot;    if (goog.events.CAPTURE_SIMULATION_MODE ==&quot;,&quot;        goog.events.CaptureSimulationMode.OFF_AND_FAIL) {&quot;,&quot;      goog.asserts.fail(&#39;Can not register capture listener in IE8-.&#39;);&quot;,&quot;      return null;&quot;,&quot;    } else if (&quot;,&quot;        goog.events.CAPTURE_SIMULATION_MODE ==&quot;,&quot;        goog.events.CaptureSimulationMode.OFF_AND_SILENT) {&quot;,&quot;      return null;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  var listenerMap = goog.events.getListenerMap_(src);&quot;,&quot;  if (!listenerMap) {&quot;,&quot;    src[goog.events.LISTENER_MAP_PROP_] = listenerMap =&quot;,&quot;        new goog.events.ListenerMap(src);&quot;,&quot;  }&quot;,null,&quot;  var listenerObj = /** @type {goog.events.Listener} */ (&quot;,&quot;      listenerMap.add(type, listener, callOnce, capture, opt_handler));&quot;,null,&quot;  // If the listenerObj already has a proxy, it has been set up&quot;,&quot;  // previously. We simply return.&quot;,&quot;  if (listenerObj.proxy) {&quot;,&quot;    return listenerObj;&quot;,&quot;  }&quot;,null,&quot;  var proxy = goog.events.getProxy();&quot;,&quot;  listenerObj.proxy = proxy;&quot;,null,&quot;  proxy.src = src;&quot;,&quot;  proxy.listener = listenerObj;&quot;,null,&quot;  // Attach the proxy through the browser&#39;s API&quot;,&quot;  if (src.addEventListener) {&quot;,&quot;    // Don&#39;t pass an object as `capture` if the browser doesn&#39;t support that.&quot;,&quot;    if (!goog.events.BrowserFeature.PASSIVE_EVENTS) {&quot;,&quot;      opt_options = capture;&quot;,&quot;    }&quot;,&quot;    // Don&#39;t break tests that expect a boolean.&quot;,&quot;    if (opt_options === undefined) opt_options = false;&quot;,&quot;    src.addEventListener(type.toString(), proxy, opt_options);&quot;,&quot;  } else if (src.attachEvent) {&quot;,&quot;    // The else if above used to be an unconditional else. It would call&quot;,&quot;    // exception on IE11, spoiling the day of some callers. The previous&quot;,&quot;    // incarnation of this code, from 2007, indicates that it replaced an&quot;,&quot;    // earlier still version that caused excess allocations on IE6.&quot;,&quot;    src.attachEvent(goog.events.getOnString_(type.toString()), proxy);&quot;,&quot;  } else if (src.addListener &amp;&amp; src.removeListener) {&quot;,&quot;    // In IE, MediaQueryList uses addListener() insteadd of addEventListener. In&quot;,&quot;    // Safari, there is no global for the MediaQueryList constructor, so we just&quot;,&quot;    // check whether the object \&quot;looks like\&quot; MediaQueryList.&quot;,&quot;    goog.asserts.assert(&quot;,&quot;        type === &#39;change&#39;, &#39;MediaQueryList only has a change event&#39;);&quot;,&quot;    src.addListener(proxy);&quot;,&quot;  } else {&quot;,&quot;    throw new Error(&#39;addEventListener and attachEvent are unavailable.&#39;);&quot;,&quot;  }&quot;,null,&quot;  goog.events.listenerCountEstimate_++;&quot;,&quot;  return listenerObj;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Helper function for returning a proxy function.&quot;,&quot; * @return {!Function} A new or reused function object.&quot;,&quot; */&quot;,&quot;goog.events.getProxy = function() {&quot;,&quot;  var proxyCallbackFunction = goog.events.handleBrowserEvent_;&quot;,&quot;  // Use a local var f to prevent one allocation.&quot;,&quot;  var f =&quot;,&quot;      goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT ? function(eventObject) {&quot;,&quot;        return proxyCallbackFunction.call(f.src, f.listener, eventObject);&quot;,&quot;      } : function(eventObject) {&quot;,&quot;        var v = proxyCallbackFunction.call(f.src, f.listener, eventObject);&quot;,&quot;        // NOTE(chrishenry): In IE, we hack in a capture phase. However, if&quot;,&quot;        // there is inline event handler which tries to prevent default (for&quot;,&quot;        // example &lt;a href=\&quot;...\&quot; onclick=\&quot;return false\&quot;&gt;...&lt;/a&gt;) in a&quot;,&quot;        // descendant element, the prevent default will be overridden&quot;,&quot;        // by this listener if this listener were to return true. Hence, we&quot;,&quot;        // return undefined.&quot;,&quot;        if (!v) return v;&quot;,&quot;      };&quot;,&quot;  return f;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds an event listener for a specific event on a native event&quot;,&quot; * target (such as a DOM element) or an object that has implemented&quot;,&quot; * {@link goog.events.Listenable}. After the event has fired the event&quot;,&quot; * listener is removed from the target.&quot;,&quot; *&quot;,&quot; * If an existing listener already exists, listenOnce will do&quot;,&quot; * nothing. In particular, if the listener was previously registered&quot;,&quot; * via listen(), listenOnce() will not turn the listener into a&quot;,&quot; * one-off listener. Similarly, if there is already an existing&quot;,&quot; * one-off listener, listenOnce does not modify the listeners (it is&quot;,&quot; * still a once listener).&quot;,&quot; *&quot;,&quot; * @param {EventTarget|goog.events.Listenable} src The node to listen&quot;,&quot; *     to events on.&quot;,&quot; * @param {string|Array&lt;string&gt;|&quot;,&quot; *     !goog.events.EventId&lt;EVENTOBJ&gt;|!Array&lt;!goog.events.EventId&lt;EVENTOBJ&gt;&gt;}&quot;,&quot; *     type Event type or array of event types.&quot;,&quot; * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}&quot;,&quot; *     listener Callback method.&quot;,&quot; * @param {(boolean|!AddEventListenerOptions)=} opt_options&quot;,&quot; * @param {T=} opt_handler Element in whose scope to call the listener.&quot;,&quot; * @return {goog.events.Key} Unique key for the listener.&quot;,&quot; * @template T,EVENTOBJ&quot;,&quot; */&quot;,&quot;goog.events.listenOnce = function(&quot;,&quot;    src, type, listener, opt_options, opt_handler) {&quot;,&quot;  if (goog.isArray(type)) {&quot;,&quot;    for (var i = 0; i &lt; type.length; i++) {&quot;,&quot;      goog.events.listenOnce(src, type[i], listener, opt_options, opt_handler);&quot;,&quot;    }&quot;,&quot;    return null;&quot;,&quot;  }&quot;,null,&quot;  listener = goog.events.wrapListener(listener);&quot;,&quot;  if (goog.events.Listenable.isImplementedBy(src)) {&quot;,&quot;    var capture =&quot;,&quot;        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;&quot;,&quot;    return src.listenOnce(&quot;,&quot;        /** @type {string|!goog.events.EventId} */ (type), listener, capture,&quot;,&quot;        opt_handler);&quot;,&quot;  } else {&quot;,&quot;    return goog.events.listen_(&quot;,&quot;        /** @type {!EventTarget} */ (src), type, listener,&quot;,&quot;        /* callOnce */ true, opt_options, opt_handler);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds an event listener with a specific event wrapper on a DOM Node or an&quot;,&quot; * object that has implemented {@link goog.events.Listenable}. A listener can&quot;,&quot; * only be added once to an object.&quot;,&quot; *&quot;,&quot; * @param {EventTarget|goog.events.Listenable} src The target to&quot;,&quot; *     listen to events on.&quot;,&quot; * @param {goog.events.EventWrapper} wrapper Event wrapper to use.&quot;,&quot; * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener&quot;,&quot; *     Callback method, or an object with a handleEvent function.&quot;,&quot; * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to&quot;,&quot; *     false).&quot;,&quot; * @param {T=} opt_handler Element in whose scope to call the listener.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.events.listenWithWrapper = function(&quot;,&quot;    src, wrapper, listener, opt_capt, opt_handler) {&quot;,&quot;  wrapper.listen(src, listener, opt_capt, opt_handler);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes an event listener which was added with listen().&quot;,&quot; *&quot;,&quot; * @param {EventTarget|goog.events.Listenable} src The target to stop&quot;,&quot; *     listening to events on.&quot;,&quot; * @param {string|Array&lt;string&gt;|&quot;,&quot; *     !goog.events.EventId&lt;EVENTOBJ&gt;|!Array&lt;!goog.events.EventId&lt;EVENTOBJ&gt;&gt;}&quot;,&quot; *     type Event type or array of event types to unlisten to.&quot;,&quot; * @param {function(?):?|{handleEvent:function(?):?}|null} listener The&quot;,&quot; *     listener function to remove.&quot;,&quot; * @param {(boolean|!EventListenerOptions)=} opt_options&quot;,&quot; *     whether the listener is fired during the capture or bubble phase of the&quot;,&quot; *     event.&quot;,&quot; * @param {Object=} opt_handler Element in whose scope to call the listener.&quot;,&quot; * @return {?boolean} indicating whether the listener was there to remove.&quot;,&quot; * @template EVENTOBJ&quot;,&quot; */&quot;,&quot;goog.events.unlisten = function(src, type, listener, opt_options, opt_handler) {&quot;,&quot;  if (goog.isArray(type)) {&quot;,&quot;    for (var i = 0; i &lt; type.length; i++) {&quot;,&quot;      goog.events.unlisten(src, type[i], listener, opt_options, opt_handler);&quot;,&quot;    }&quot;,&quot;    return null;&quot;,&quot;  }&quot;,&quot;  var capture =&quot;,&quot;      goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;&quot;,null,&quot;  listener = goog.events.wrapListener(listener);&quot;,&quot;  if (goog.events.Listenable.isImplementedBy(src)) {&quot;,&quot;    return src.unlisten(&quot;,&quot;        /** @type {string|!goog.events.EventId} */ (type), listener, capture,&quot;,&quot;        opt_handler);&quot;,&quot;  }&quot;,null,&quot;  if (!src) {&quot;,&quot;    // TODO(chrishenry): We should tighten the API to only accept&quot;,&quot;    // non-null objects, or add an assertion here.&quot;,&quot;    return false;&quot;,&quot;  }&quot;,null,&quot;  var listenerMap = goog.events.getListenerMap_(&quot;,&quot;      /** @type {!EventTarget} */ (src));&quot;,&quot;  if (listenerMap) {&quot;,&quot;    var listenerObj = listenerMap.getListener(&quot;,&quot;        /** @type {string|!goog.events.EventId} */ (type), listener, capture,&quot;,&quot;        opt_handler);&quot;,&quot;    if (listenerObj) {&quot;,&quot;      return goog.events.unlistenByKey(listenerObj);&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  return false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes an event listener which was added with listen() by the key&quot;,&quot; * returned by listen().&quot;,&quot; *&quot;,&quot; * @param {goog.events.Key} key The key returned by listen() for this&quot;,&quot; *     event listener.&quot;,&quot; * @return {boolean} indicating whether the listener was there to remove.&quot;,&quot; */&quot;,&quot;goog.events.unlistenByKey = function(key) {&quot;,&quot;  // TODO(chrishenry): Remove this check when tests that rely on this&quot;,&quot;  // are fixed.&quot;,&quot;  if (goog.isNumber(key)) {&quot;,&quot;    return false;&quot;,&quot;  }&quot;,null,&quot;  var listener = key;&quot;,&quot;  if (!listener || listener.removed) {&quot;,&quot;    return false;&quot;,&quot;  }&quot;,null,&quot;  var src = listener.src;&quot;,&quot;  if (goog.events.Listenable.isImplementedBy(src)) {&quot;,&quot;    return /** @type {!goog.events.Listenable} */ (src).unlistenByKey(listener);&quot;,&quot;  }&quot;,null,&quot;  var type = listener.type;&quot;,&quot;  var proxy = listener.proxy;&quot;,&quot;  if (src.removeEventListener) {&quot;,&quot;    src.removeEventListener(type, proxy, listener.capture);&quot;,&quot;  } else if (src.detachEvent) {&quot;,&quot;    src.detachEvent(goog.events.getOnString_(type), proxy);&quot;,&quot;  } else if (src.addListener &amp;&amp; src.removeListener) {&quot;,&quot;    src.removeListener(proxy);&quot;,&quot;  }&quot;,&quot;  goog.events.listenerCountEstimate_--;&quot;,null,&quot;  var listenerMap = goog.events.getListenerMap_(&quot;,&quot;      /** @type {!EventTarget} */ (src));&quot;,&quot;  // TODO(chrishenry): Try to remove this conditional and execute the&quot;,&quot;  // first branch always. This should be safe.&quot;,&quot;  if (listenerMap) {&quot;,&quot;    listenerMap.removeByKey(listener);&quot;,&quot;    if (listenerMap.getTypeCount() == 0) {&quot;,&quot;      // Null the src, just because this is simple to do (and useful&quot;,&quot;      // for IE &lt;= 7).&quot;,&quot;      listenerMap.src = null;&quot;,&quot;      // We don&#39;t use delete here because IE does not allow delete&quot;,&quot;      // on a window object.&quot;,&quot;      src[goog.events.LISTENER_MAP_PROP_] = null;&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    /** @type {!goog.events.Listener} */ (listener).markAsRemoved();&quot;,&quot;  }&quot;,null,&quot;  return true;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes an event listener which was added with listenWithWrapper().&quot;,&quot; *&quot;,&quot; * @param {EventTarget|goog.events.Listenable} src The target to stop&quot;,&quot; *     listening to events on.&quot;,&quot; * @param {goog.events.EventWrapper} wrapper Event wrapper to use.&quot;,&quot; * @param {function(?):?|{handleEvent:function(?):?}|null} listener The&quot;,&quot; *     listener function to remove.&quot;,&quot; * @param {boolean=} opt_capt In DOM-compliant browsers, this determines&quot;,&quot; *     whether the listener is fired during the capture or bubble phase of the&quot;,&quot; *     event.&quot;,&quot; * @param {Object=} opt_handler Element in whose scope to call the listener.&quot;,&quot; */&quot;,&quot;goog.events.unlistenWithWrapper = function(&quot;,&quot;    src, wrapper, listener, opt_capt, opt_handler) {&quot;,&quot;  wrapper.unlisten(src, listener, opt_capt, opt_handler);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes all listeners from an object. You can also optionally&quot;,&quot; * remove listeners of a particular type.&quot;,&quot; *&quot;,&quot; * @param {Object|undefined} obj Object to remove listeners from. Must be an&quot;,&quot; *     EventTarget or a goog.events.Listenable.&quot;,&quot; * @param {string|!goog.events.EventId=} opt_type Type of event to remove.&quot;,&quot; *     Default is all types.&quot;,&quot; * @return {number} Number of listeners removed.&quot;,&quot; */&quot;,&quot;goog.events.removeAll = function(obj, opt_type) {&quot;,&quot;  // TODO(chrishenry): Change the type of obj to&quot;,&quot;  // (!EventTarget|!goog.events.Listenable).&quot;,null,&quot;  if (!obj) {&quot;,&quot;    return 0;&quot;,&quot;  }&quot;,null,&quot;  if (goog.events.Listenable.isImplementedBy(obj)) {&quot;,&quot;    return /** @type {?} */ (obj).removeAllListeners(opt_type);&quot;,&quot;  }&quot;,null,&quot;  var listenerMap = goog.events.getListenerMap_(&quot;,&quot;      /** @type {!EventTarget} */ (obj));&quot;,&quot;  if (!listenerMap) {&quot;,&quot;    return 0;&quot;,&quot;  }&quot;,null,&quot;  var count = 0;&quot;,&quot;  var typeStr = opt_type &amp;&amp; opt_type.toString();&quot;,&quot;  for (var type in listenerMap.listeners) {&quot;,&quot;    if (!typeStr || type == typeStr) {&quot;,&quot;      // Clone so that we don&#39;t need to worry about unlistenByKey&quot;,&quot;      // changing the content of the ListenerMap.&quot;,&quot;      var listeners = listenerMap.listeners[type].concat();&quot;,&quot;      for (var i = 0; i &lt; listeners.length; ++i) {&quot;,&quot;        if (goog.events.unlistenByKey(listeners[i])) {&quot;,&quot;          ++count;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return count;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the listeners for a given object, type and capture phase.&quot;,&quot; *&quot;,&quot; * @param {Object} obj Object to get listeners for.&quot;,&quot; * @param {string|!goog.events.EventId} type Event type.&quot;,&quot; * @param {boolean} capture Capture phase?.&quot;,&quot; * @return {Array&lt;!goog.events.Listener&gt;} Array of listener objects.&quot;,&quot; */&quot;,&quot;goog.events.getListeners = function(obj, type, capture) {&quot;,&quot;  if (goog.events.Listenable.isImplementedBy(obj)) {&quot;,&quot;    return /** @type {!goog.events.Listenable} */ (obj).getListeners(&quot;,&quot;        type, capture);&quot;,&quot;  } else {&quot;,&quot;    if (!obj) {&quot;,&quot;      // TODO(chrishenry): We should tighten the API to accept&quot;,&quot;      // !EventTarget|goog.events.Listenable, and add an assertion here.&quot;,&quot;      return [];&quot;,&quot;    }&quot;,null,&quot;    var listenerMap = goog.events.getListenerMap_(&quot;,&quot;        /** @type {!EventTarget} */ (obj));&quot;,&quot;    return listenerMap ? listenerMap.getListeners(type, capture) : [];&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the goog.events.Listener for the event or null if no such listener is&quot;,&quot; * in use.&quot;,&quot; *&quot;,&quot; * @param {EventTarget|goog.events.Listenable} src The target from&quot;,&quot; *     which to get listeners.&quot;,&quot; * @param {?string|!goog.events.EventId&lt;EVENTOBJ&gt;} type The type of the event.&quot;,&quot; * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null} listener The&quot;,&quot; *     listener function to get.&quot;,&quot; * @param {boolean=} opt_capt In DOM-compliant browsers, this determines&quot;,&quot; *                            whether the listener is fired during the&quot;,&quot; *                            capture or bubble phase of the event.&quot;,&quot; * @param {Object=} opt_handler Element in whose scope to call the listener.&quot;,&quot; * @return {goog.events.ListenableKey} the found listener or null if not found.&quot;,&quot; * @template EVENTOBJ&quot;,&quot; */&quot;,&quot;goog.events.getListener = function(src, type, listener, opt_capt, opt_handler) {&quot;,&quot;  // TODO(chrishenry): Change type from ?string to string, or add assertion.&quot;,&quot;  type = /** @type {string} */ (type);&quot;,&quot;  listener = goog.events.wrapListener(listener);&quot;,&quot;  var capture = !!opt_capt;&quot;,&quot;  if (goog.events.Listenable.isImplementedBy(src)) {&quot;,&quot;    return src.getListener(type, listener, capture, opt_handler);&quot;,&quot;  }&quot;,null,&quot;  if (!src) {&quot;,&quot;    // TODO(chrishenry): We should tighten the API to only accept&quot;,&quot;    // non-null objects, or add an assertion here.&quot;,&quot;    return null;&quot;,&quot;  }&quot;,null,&quot;  var listenerMap = goog.events.getListenerMap_(&quot;,&quot;      /** @type {!EventTarget} */ (src));&quot;,&quot;  if (listenerMap) {&quot;,&quot;    return listenerMap.getListener(type, listener, capture, opt_handler);&quot;,&quot;  }&quot;,&quot;  return null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns whether an event target has any active listeners matching the&quot;,&quot; * specified signature. If either the type or capture parameters are&quot;,&quot; * unspecified, the function will match on the remaining criteria.&quot;,&quot; *&quot;,&quot; * @param {EventTarget|goog.events.Listenable} obj Target to get&quot;,&quot; *     listeners for.&quot;,&quot; * @param {string|!goog.events.EventId=} opt_type Event type.&quot;,&quot; * @param {boolean=} opt_capture Whether to check for capture or bubble-phase&quot;,&quot; *     listeners.&quot;,&quot; * @return {boolean} Whether an event target has one or more listeners matching&quot;,&quot; *     the requested type and/or capture phase.&quot;,&quot; */&quot;,&quot;goog.events.hasListener = function(obj, opt_type, opt_capture) {&quot;,&quot;  if (goog.events.Listenable.isImplementedBy(obj)) {&quot;,&quot;    return obj.hasListener(opt_type, opt_capture);&quot;,&quot;  }&quot;,null,&quot;  var listenerMap = goog.events.getListenerMap_(&quot;,&quot;      /** @type {!EventTarget} */ (obj));&quot;,&quot;  return !!listenerMap &amp;&amp; listenerMap.hasListener(opt_type, opt_capture);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Provides a nice string showing the normalized event objects public members&quot;,&quot; * @param {Object} e Event Object.&quot;,&quot; * @return {string} String of the public members of the normalized event object.&quot;,&quot; */&quot;,&quot;goog.events.expose = function(e) {&quot;,&quot;  var str = [];&quot;,&quot;  for (var key in e) {&quot;,&quot;    if (e[key] &amp;&amp; e[key].id) {&quot;,&quot;      str.push(key + &#39; = &#39; + e[key] + &#39; (&#39; + e[key].id + &#39;)&#39;);&quot;,&quot;    } else {&quot;,&quot;      str.push(key + &#39; = &#39; + e[key]);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return str.join(&#39;\\n&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns a string with on prepended to the specified type. This is used for IE&quot;,&quot; * which expects \&quot;on\&quot; to be prepended. This function caches the string in order&quot;,&quot; * to avoid extra allocations in steady state.&quot;,&quot; * @param {string} type Event type.&quot;,&quot; * @return {string} The type string with &#39;on&#39; prepended.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.getOnString_ = function(type) {&quot;,&quot;  if (type in goog.events.onStringMap_) {&quot;,&quot;    return goog.events.onStringMap_[type];&quot;,&quot;  }&quot;,&quot;  return goog.events.onStringMap_[type] = goog.events.onString_ + type;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Fires an object&#39;s listeners of a particular type and phase&quot;,&quot; *&quot;,&quot; * @param {Object} obj Object whose listeners to call.&quot;,&quot; * @param {string|!goog.events.EventId} type Event type.&quot;,&quot; * @param {boolean} capture Which event phase.&quot;,&quot; * @param {Object} eventObject Event object to be passed to listener.&quot;,&quot; * @return {boolean} True if all listeners returned true else false.&quot;,&quot; */&quot;,&quot;goog.events.fireListeners = function(obj, type, capture, eventObject) {&quot;,&quot;  if (goog.events.Listenable.isImplementedBy(obj)) {&quot;,&quot;    return /** @type {!goog.events.Listenable} */ (obj).fireListeners(&quot;,&quot;        type, capture, eventObject);&quot;,&quot;  }&quot;,null,&quot;  return goog.events.fireListeners_(obj, type, capture, eventObject);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Fires an object&#39;s listeners of a particular type and phase.&quot;,&quot; * @param {Object} obj Object whose listeners to call.&quot;,&quot; * @param {string|!goog.events.EventId} type Event type.&quot;,&quot; * @param {boolean} capture Which event phase.&quot;,&quot; * @param {Object} eventObject Event object to be passed to listener.&quot;,&quot; * @return {boolean} True if all listeners returned true else false.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.fireListeners_ = function(obj, type, capture, eventObject) {&quot;,&quot;  /** @type {boolean} */&quot;,&quot;  var retval = true;&quot;,null,&quot;  var listenerMap = goog.events.getListenerMap_(&quot;,&quot;      /** @type {EventTarget} */ (obj));&quot;,&quot;  if (listenerMap) {&quot;,&quot;    // TODO(chrishenry): Original code avoids array creation when there&quot;,&quot;    // is no listener, so we do the same. If this optimization turns&quot;,&quot;    // out to be not required, we can replace this with&quot;,&quot;    // listenerMap.getListeners(type, capture) instead, which is simpler.&quot;,&quot;    var listenerArray = listenerMap.listeners[type.toString()];&quot;,&quot;    if (listenerArray) {&quot;,&quot;      listenerArray = listenerArray.concat();&quot;,&quot;      for (var i = 0; i &lt; listenerArray.length; i++) {&quot;,&quot;        var listener = listenerArray[i];&quot;,&quot;        // We might not have a listener if the listener was removed.&quot;,&quot;        if (listener &amp;&amp; listener.capture == capture &amp;&amp; !listener.removed) {&quot;,&quot;          var result = goog.events.fireListener(listener, eventObject);&quot;,&quot;          retval = retval &amp;&amp; (result !== false);&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return retval;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Fires a listener with a set of arguments&quot;,&quot; *&quot;,&quot; * @param {goog.events.Listener} listener The listener object to call.&quot;,&quot; * @param {Object} eventObject The event object to pass to the listener.&quot;,&quot; * @return {*} Result of listener.&quot;,&quot; */&quot;,&quot;goog.events.fireListener = function(listener, eventObject) {&quot;,&quot;  var listenerFn = listener.listener;&quot;,&quot;  var listenerHandler = listener.handler || listener.src;&quot;,null,&quot;  if (listener.callOnce) {&quot;,&quot;    goog.events.unlistenByKey(listener);&quot;,&quot;  }&quot;,&quot;  return listenerFn.call(listenerHandler, eventObject);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the total number of listeners currently in the system.&quot;,&quot; * @return {number} Number of listeners.&quot;,&quot; * @deprecated This returns estimated count, now that Closure no longer&quot;,&quot; * stores a central listener registry. We still return an estimation&quot;,&quot; * to keep existing listener-related tests passing. In the near future,&quot;,&quot; * this function will be removed.&quot;,&quot; */&quot;,&quot;goog.events.getTotalListenerCount = function() {&quot;,&quot;  return goog.events.listenerCountEstimate_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Dispatches an event (or event like object) and calls all listeners&quot;,&quot; * listening for events of this type. The type of the event is decided by the&quot;,&quot; * type property on the event object.&quot;,&quot; *&quot;,&quot; * If any of the listeners returns false OR calls preventDefault then this&quot;,&quot; * function will return false.  If one of the capture listeners calls&quot;,&quot; * stopPropagation, then the bubble listeners won&#39;t fire.&quot;,&quot; *&quot;,&quot; * @param {goog.events.Listenable} src The event target.&quot;,&quot; * @param {goog.events.EventLike} e Event object.&quot;,&quot; * @return {boolean} If anyone called preventDefault on the event object (or&quot;,&quot; *     if any of the handlers returns false) this will also return false.&quot;,&quot; *     If there are no handlers, or if all handlers return true, this returns&quot;,&quot; *     true.&quot;,&quot; */&quot;,&quot;goog.events.dispatchEvent = function(src, e) {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      goog.events.Listenable.isImplementedBy(src),&quot;,&quot;      &#39;Can not use goog.events.dispatchEvent with &#39; +&quot;,&quot;          &#39;non-goog.events.Listenable instance.&#39;);&quot;,&quot;  return src.dispatchEvent(e);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Installs exception protection for the browser event entry point using the&quot;,&quot; * given error handler.&quot;,&quot; *&quot;,&quot; * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to&quot;,&quot; *     protect the entry point.&quot;,&quot; */&quot;,&quot;goog.events.protectBrowserEventEntryPoint = function(errorHandler) {&quot;,&quot;  goog.events.handleBrowserEvent_ =&quot;,&quot;      errorHandler.protectEntryPoint(goog.events.handleBrowserEvent_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Handles an event and dispatches it to the correct listeners. This&quot;,&quot; * function is a proxy for the real listener the user specified.&quot;,&quot; *&quot;,&quot; * @param {goog.events.Listener} listener The listener object.&quot;,&quot; * @param {Event=} opt_evt Optional event object that gets passed in via the&quot;,&quot; *     native event handlers.&quot;,&quot; * @return {*} Result of the event handler.&quot;,&quot; * @this {EventTarget} The object or Element that fired the event.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.handleBrowserEvent_ = function(listener, opt_evt) {&quot;,&quot;  if (listener.removed) {&quot;,&quot;    return true;&quot;,&quot;  }&quot;,null,&quot;  // Synthesize event propagation if the browser does not support W3C&quot;,&quot;  // event model.&quot;,&quot;  if (!goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {&quot;,&quot;    var ieEvent = opt_evt ||&quot;,&quot;        /** @type {Event} */ (goog.getObjectByName(&#39;window.event&#39;));&quot;,&quot;    var evt = new goog.events.BrowserEvent(ieEvent, this);&quot;,&quot;    /** @type {*} */&quot;,&quot;    var retval = true;&quot;,null,&quot;    if (goog.events.CAPTURE_SIMULATION_MODE ==&quot;,&quot;        goog.events.CaptureSimulationMode.ON) {&quot;,&quot;      // If we have not marked this event yet, we should perform capture&quot;,&quot;      // simulation.&quot;,&quot;      if (!goog.events.isMarkedIeEvent_(ieEvent)) {&quot;,&quot;        goog.events.markIeEvent_(ieEvent);&quot;,null,&quot;        var ancestors = [];&quot;,&quot;        for (var parent = evt.currentTarget; parent;&quot;,&quot;             parent = parent.parentNode) {&quot;,&quot;          ancestors.push(parent);&quot;,&quot;        }&quot;,null,&quot;        // Fire capture listeners.&quot;,&quot;        var type = listener.type;&quot;,&quot;        for (var i = ancestors.length - 1; !evt.propagationStopped_ &amp;&amp; i &gt;= 0;&quot;,&quot;             i--) {&quot;,&quot;          evt.currentTarget = ancestors[i];&quot;,&quot;          var result =&quot;,&quot;              goog.events.fireListeners_(ancestors[i], type, true, evt);&quot;,&quot;          retval = retval &amp;&amp; result;&quot;,&quot;        }&quot;,null,&quot;        // Fire bubble listeners.&quot;,&quot;        //&quot;,&quot;        // We can technically rely on IE to perform bubble event&quot;,&quot;        // propagation. However, it turns out that IE fires events in&quot;,&quot;        // opposite order of attachEvent registration, which broke&quot;,&quot;        // some code and tests that rely on the order. (While W3C DOM&quot;,&quot;        // Level 2 Events TR leaves the event ordering unspecified,&quot;,&quot;        // modern browsers and W3C DOM Level 3 Events Working Draft&quot;,&quot;        // actually specify the order as the registration order.)&quot;,&quot;        for (var i = 0; !evt.propagationStopped_ &amp;&amp; i &lt; ancestors.length; i++) {&quot;,&quot;          evt.currentTarget = ancestors[i];&quot;,&quot;          var result =&quot;,&quot;              goog.events.fireListeners_(ancestors[i], type, false, evt);&quot;,&quot;          retval = retval &amp;&amp; result;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    } else {&quot;,&quot;      retval = goog.events.fireListener(listener, evt);&quot;,&quot;    }&quot;,&quot;    return retval;&quot;,&quot;  }&quot;,null,&quot;  // Otherwise, simply fire the listener.&quot;,&quot;  return goog.events.fireListener(&quot;,&quot;      listener, new goog.events.BrowserEvent(opt_evt, this));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * This is used to mark the IE event object so we do not do the Closure pass&quot;,&quot; * twice for a bubbling event.&quot;,&quot; * @param {Event} e The IE browser event.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.markIeEvent_ = function(e) {&quot;,&quot;  // Only the keyCode and the returnValue can be changed. We use keyCode for&quot;,&quot;  // non keyboard events.&quot;,&quot;  // event.returnValue is a bit more tricky. It is undefined by default. A&quot;,&quot;  // boolean false prevents the default action. In a window.onbeforeunload and&quot;,&quot;  // the returnValue is non undefined it will be alerted. However, we will only&quot;,&quot;  // modify the returnValue for keyboard events. We can get a problem if non&quot;,&quot;  // closure events sets the keyCode or the returnValue&quot;,null,&quot;  var useReturnValue = false;&quot;,null,&quot;  if (e.keyCode == 0) {&quot;,&quot;    // We cannot change the keyCode in case that srcElement is input[type=file].&quot;,&quot;    // We could test that that is the case but that would allocate 3 objects.&quot;,&quot;    // If we use try/catch we will only allocate extra objects in the case of a&quot;,&quot;    // failure.&quot;,null,&quot;    try {&quot;,&quot;      e.keyCode = -1;&quot;,&quot;      return;&quot;,&quot;    } catch (ex) {&quot;,&quot;      useReturnValue = true;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  if (useReturnValue ||&quot;,&quot;      /** @type {boolean|undefined} */ (e.returnValue) == undefined) {&quot;,&quot;    e.returnValue = true;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * This is used to check if an IE event has already been handled by the Closure&quot;,&quot; * system so we do not do the Closure pass twice for a bubbling event.&quot;,&quot; * @param {Event} e  The IE browser event.&quot;,&quot; * @return {boolean} True if the event object has been marked.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.isMarkedIeEvent_ = function(e) {&quot;,&quot;  return e.keyCode &lt; 0 || e.returnValue != undefined;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Counter to create unique event ids.&quot;,&quot; * @private {number}&quot;,&quot; */&quot;,&quot;goog.events.uniqueIdCounter_ = 0;&quot;,null,null,&quot;/**&quot;,&quot; * Creates a unique event id.&quot;,&quot; *&quot;,&quot; * @param {string} identifier The identifier.&quot;,&quot; * @return {string} A unique identifier.&quot;,&quot; * @idGenerator {unique}&quot;,&quot; */&quot;,&quot;goog.events.getUniqueId = function(identifier) {&quot;,&quot;  return identifier + &#39;_&#39; + goog.events.uniqueIdCounter_++;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {EventTarget} src The source object.&quot;,&quot; * @return {goog.events.ListenerMap} A listener map for the given&quot;,&quot; *     source object, or null if none exists.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.getListenerMap_ = function(src) {&quot;,&quot;  var listenerMap = src[goog.events.LISTENER_MAP_PROP_];&quot;,&quot;  // IE serializes the property as well (e.g. when serializing outer&quot;,&quot;  // HTML). So we must check that the value is of the correct type.&quot;,&quot;  return listenerMap instanceof goog.events.ListenerMap ? listenerMap : null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Expando property for listener function wrapper for Object with&quot;,&quot; * handleEvent.&quot;,&quot; * @private @const {string}&quot;,&quot; */&quot;,&quot;goog.events.LISTENER_WRAPPER_PROP_ =&quot;,&quot;    &#39;__closure_events_fn_&#39; + ((Math.random() * 1e9) &gt;&gt;&gt; 0);&quot;,null,null,&quot;/**&quot;,&quot; * @param {Object|Function} listener The listener function or an&quot;,&quot; *     object that contains handleEvent method.&quot;,&quot; * @return {!Function} Either the original function or a function that&quot;,&quot; *     calls obj.handleEvent. If the same listener is passed to this&quot;,&quot; *     function more than once, the same function is guaranteed to be&quot;,&quot; *     returned.&quot;,&quot; */&quot;,&quot;goog.events.wrapListener = function(listener) {&quot;,&quot;  goog.asserts.assert(listener, &#39;Listener can not be null.&#39;);&quot;,null,&quot;  if (goog.isFunction(listener)) {&quot;,&quot;    return listener;&quot;,&quot;  }&quot;,null,&quot;  goog.asserts.assert(&quot;,&quot;      listener.handleEvent, &#39;An object listener must have handleEvent method.&#39;);&quot;,&quot;  if (!listener[goog.events.LISTENER_WRAPPER_PROP_]) {&quot;,&quot;    listener[goog.events.LISTENER_WRAPPER_PROP_] = function(e) {&quot;,&quot;      return /** @type {?} */ (listener).handleEvent(e);&quot;,&quot;    };&quot;,&quot;  }&quot;,&quot;  return listener[goog.events.LISTENER_WRAPPER_PROP_];&quot;,&quot;};&quot;,null,null,&quot;// Register the browser event handler as an entry point, so that&quot;,&quot;// it can be monitored for exception handling, etc.&quot;,&quot;goog.debug.entryPointRegistry.register(&quot;,&quot;    /**&quot;,&quot;     * @param {function(!Function): !Function} transformer The transforming&quot;,&quot;     *     function.&quot;,&quot;     */&quot;,&quot;    function(transformer) {&quot;,&quot;      goog.events.handleBrowserEvent_ =&quot;,&quot;          transformer(goog.events.handleBrowserEvent_);&quot;,&quot;    });&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>