<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>eventhandler.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;eventhandler.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/events/eventhandler.js&quot;,[&quot;// Copyright 2005 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Class to create objects which want to handle multiple events&quot;,&quot; * and have their listeners easily cleaned up via a dispose method.&quot;,&quot; *&quot;,&quot; * Example:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; * function Something() {&quot;,&quot; *   Something.base(this);&quot;,&quot; *&quot;,&quot; *   ... set up object ...&quot;,&quot; *&quot;,&quot; *   // Add event listeners&quot;,&quot; *   this.listen(this.starEl, goog.events.EventType.CLICK, this.handleStar);&quot;,&quot; *   this.listen(this.headerEl, goog.events.EventType.CLICK, this.expand);&quot;,&quot; *   this.listen(this.collapseEl, goog.events.EventType.CLICK, this.collapse);&quot;,&quot; *   this.listen(this.infoEl, goog.events.EventType.MOUSEOVER, this.showHover);&quot;,&quot; *   this.listen(this.infoEl, goog.events.EventType.MOUSEOUT, this.hideHover);&quot;,&quot; * }&quot;,&quot; * goog.inherits(Something, goog.events.EventHandler);&quot;,&quot; *&quot;,&quot; * Something.prototype.disposeInternal = function() {&quot;,&quot; *   Something.base(this, &#39;disposeInternal&#39;);&quot;,&quot; *   goog.dom.removeNode(this.container);&quot;,&quot; * };&quot;,&quot; *&quot;,&quot; *&quot;,&quot; * // Then elsewhere:&quot;,&quot; *&quot;,&quot; * var activeSomething = null;&quot;,&quot; * function openSomething() {&quot;,&quot; *   activeSomething = new Something();&quot;,&quot; * }&quot;,&quot; *&quot;,&quot; * function closeSomething() {&quot;,&quot; *   if (activeSomething) {&quot;,&quot; *     activeSomething.dispose();  // Remove event listeners&quot;,&quot; *     activeSomething = null;&quot;,&quot; *   }&quot;,&quot; * }&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.events.EventHandler&#39;);&quot;,null,&quot;goog.require(&#39;goog.Disposable&#39;);&quot;,&quot;goog.require(&#39;goog.events&#39;);&quot;,&quot;goog.require(&#39;goog.object&#39;);&quot;,null,&quot;goog.forwardDeclare(&#39;goog.events.EventWrapper&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * Super class for objects that want to easily manage a number of event&quot;,&quot; * listeners.  It allows a short cut to listen and also provides a quick way&quot;,&quot; * to remove all events listeners belonging to this object.&quot;,&quot; * @param {SCOPE=} opt_scope Object in whose scope to call the listeners.&quot;,&quot; * @constructor&quot;,&quot; * @extends {goog.Disposable}&quot;,&quot; * @template SCOPE&quot;,&quot; */&quot;,&quot;goog.events.EventHandler = function(opt_scope) {&quot;,&quot;  goog.Disposable.call(this);&quot;,&quot;  // TODO(mknichel): Rename this to this.scope_ and fix the classes in google3&quot;,&quot;  // that access this private variable. :(&quot;,&quot;  this.handler_ = opt_scope;&quot;,null,&quot;  /**&quot;,&quot;   * Keys for events that are being listened to.&quot;,&quot;   * @type {!Object&lt;!goog.events.Key&gt;}&quot;,&quot;   * @private&quot;,&quot;   */&quot;,&quot;  this.keys_ = {};&quot;,&quot;};&quot;,&quot;goog.inherits(goog.events.EventHandler, goog.Disposable);&quot;,null,null,&quot;/**&quot;,&quot; * Utility array used to unify the cases of listening for an array of types&quot;,&quot; * and listening for a single event, without using recursion or allocating&quot;,&quot; * an array each time.&quot;,&quot; * @type {!Array&lt;string&gt;}&quot;,&quot; * @const&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.typeArray_ = [];&quot;,null,null,&quot;/**&quot;,&quot; * Listen to an event on a Listenable.  If the function is omitted then the&quot;,&quot; * EventHandler&#39;s handleEvent method will be used.&quot;,&quot; * @param {goog.events.ListenableType} src Event source.&quot;,&quot; * @param {string|Array&lt;string&gt;|&quot;,&quot; *     !goog.events.EventId&lt;EVENTOBJ&gt;|!Array&lt;!goog.events.EventId&lt;EVENTOBJ&gt;&gt;}&quot;,&quot; *     type Event type to listen for or array of event types.&quot;,&quot; * @param {function(this:SCOPE, EVENTOBJ):?|{handleEvent:function(?):?}|null=}&quot;,&quot; *     opt_fn Optional callback function to be used as the listener or an object&quot;,&quot; *     with handleEvent function.&quot;,&quot; * @param {(boolean|!AddEventListenerOptions)=} opt_options&quot;,&quot; * @return {THIS} This object, allowing for chaining of calls.&quot;,&quot; * @this {THIS}&quot;,&quot; * @template EVENTOBJ, THIS&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.listen = function(&quot;,&quot;    src, type, opt_fn, opt_options) {&quot;,&quot;  var self = /** @type {!goog.events.EventHandler} */ (this);&quot;,&quot;  return self.listen_(src, type, opt_fn, opt_options);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Listen to an event on a Listenable.  If the function is omitted then the&quot;,&quot; * EventHandler&#39;s handleEvent method will be used.&quot;,&quot; * @param {goog.events.ListenableType} src Event source.&quot;,&quot; * @param {string|Array&lt;string&gt;|&quot;,&quot; *     !goog.events.EventId&lt;EVENTOBJ&gt;|!Array&lt;!goog.events.EventId&lt;EVENTOBJ&gt;&gt;}&quot;,&quot; *     type Event type to listen for or array of event types.&quot;,&quot; * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(this:T, ?):?}|&quot;,&quot; *     null|undefined} fn Optional callback function to be used as the&quot;,&quot; *     listener or an object with handleEvent function.&quot;,&quot; * @param {boolean|!AddEventListenerOptions|undefined} options&quot;,&quot; * @param {T} scope Object in whose scope to call the listener.&quot;,&quot; * @return {THIS} This object, allowing for chaining of calls.&quot;,&quot; * @this {THIS}&quot;,&quot; * @template T, EVENTOBJ, THIS&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.listenWithScope = function(&quot;,&quot;    src, type, fn, options, scope) {&quot;,&quot;  var self = /** @type {!goog.events.EventHandler} */ (this);&quot;,&quot;  // TODO(mknichel): Deprecate this function.&quot;,&quot;  return self.listen_(src, type, fn, options, scope);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Listen to an event on a Listenable.  If the function is omitted then the&quot;,&quot; * EventHandler&#39;s handleEvent method will be used.&quot;,&quot; * @param {goog.events.ListenableType} src Event source.&quot;,&quot; * @param {string|Array&lt;string&gt;|&quot;,&quot; *     !goog.events.EventId&lt;EVENTOBJ&gt;|!Array&lt;!goog.events.EventId&lt;EVENTOBJ&gt;&gt;}&quot;,&quot; *     type Event type to listen for or array of event types.&quot;,&quot; * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null=} opt_fn&quot;,&quot; *     Optional callback function to be used as the listener or an object with&quot;,&quot; *     handleEvent function.&quot;,&quot; * @param {(boolean|!AddEventListenerOptions)=} opt_options&quot;,&quot; * @param {Object=} opt_scope Object in whose scope to call the listener.&quot;,&quot; * @return {THIS} This object, allowing for chaining of calls.&quot;,&quot; * @this {THIS}&quot;,&quot; * @template EVENTOBJ, THIS&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.listen_ = function(&quot;,&quot;    src, type, opt_fn, opt_options, opt_scope) {&quot;,&quot;  var self = /** @type {!goog.events.EventHandler} */ (this);&quot;,&quot;  if (!goog.isArray(type)) {&quot;,&quot;    if (type) {&quot;,&quot;      goog.events.EventHandler.typeArray_[0] = type.toString();&quot;,&quot;    }&quot;,&quot;    type = goog.events.EventHandler.typeArray_;&quot;,&quot;  }&quot;,&quot;  for (var i = 0; i &lt; type.length; i++) {&quot;,&quot;    var listenerObj = goog.events.listen(&quot;,&quot;        src, type[i], opt_fn || self.handleEvent, opt_options || false,&quot;,&quot;        opt_scope || self.handler_ || self);&quot;,null,&quot;    if (!listenerObj) {&quot;,&quot;      // When goog.events.listen run on OFF_AND_FAIL or OFF_AND_SILENT&quot;,&quot;      // (goog.events.CaptureSimulationMode) in IE8-, it will return null&quot;,&quot;      // value.&quot;,&quot;      return self;&quot;,&quot;    }&quot;,null,&quot;    var key = listenerObj.key;&quot;,&quot;    self.keys_[key] = listenerObj;&quot;,&quot;  }&quot;,null,&quot;  return self;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Listen to an event on a Listenable.  If the function is omitted, then the&quot;,&quot; * EventHandler&#39;s handleEvent method will be used. After the event has fired the&quot;,&quot; * event listener is removed from the target. If an array of event types is&quot;,&quot; * provided, each event type will be listened to once.&quot;,&quot; * @param {goog.events.ListenableType} src Event source.&quot;,&quot; * @param {string|Array&lt;string&gt;|&quot;,&quot; *     !goog.events.EventId&lt;EVENTOBJ&gt;|!Array&lt;!goog.events.EventId&lt;EVENTOBJ&gt;&gt;}&quot;,&quot; *     type Event type to listen for or array of event types.&quot;,&quot; * @param {function(this:SCOPE, EVENTOBJ):?|{handleEvent:function(?):?}|null=}&quot;,&quot; * opt_fn&quot;,&quot; *    Optional callback function to be used as the listener or an object with&quot;,&quot; *    handleEvent function.&quot;,&quot; * @param {(boolean|!AddEventListenerOptions)=} opt_options&quot;,&quot; * @return {THIS} This object, allowing for chaining of calls.&quot;,&quot; * @this {THIS}&quot;,&quot; * @template EVENTOBJ, THIS&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.listenOnce = function(&quot;,&quot;    src, type, opt_fn, opt_options) {&quot;,&quot;  var self = /** @type {!goog.events.EventHandler} */ (this);&quot;,&quot;  return self.listenOnce_(src, type, opt_fn, opt_options);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Listen to an event on a Listenable.  If the function is omitted, then the&quot;,&quot; * EventHandler&#39;s handleEvent method will be used. After the event has fired the&quot;,&quot; * event listener is removed from the target. If an array of event types is&quot;,&quot; * provided, each event type will be listened to once.&quot;,&quot; * @param {goog.events.ListenableType} src Event source.&quot;,&quot; * @param {string|Array&lt;string&gt;|&quot;,&quot; *     !goog.events.EventId&lt;EVENTOBJ&gt;|!Array&lt;!goog.events.EventId&lt;EVENTOBJ&gt;&gt;}&quot;,&quot; *     type Event type to listen for or array of event types.&quot;,&quot; * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(this:T, ?):?}|&quot;,&quot; *     null|undefined} fn Optional callback function to be used as the&quot;,&quot; *     listener or an object with handleEvent function.&quot;,&quot; * @param {boolean|undefined} capture Optional whether to use capture phase.&quot;,&quot; * @param {T} scope Object in whose scope to call the listener.&quot;,&quot; * @return {THIS} This object, allowing for chaining of calls.&quot;,&quot; * @this {THIS}&quot;,&quot; * @template T, EVENTOBJ, THIS&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.listenOnceWithScope = function(&quot;,&quot;    src, type, fn, capture, scope) {&quot;,&quot;  var self = /** @type {!goog.events.EventHandler} */ (this);&quot;,&quot;  // TODO(mknichel): Deprecate this function.&quot;,&quot;  return self.listenOnce_(src, type, fn, capture, scope);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Listen to an event on a Listenable.  If the function is omitted, then the&quot;,&quot; * EventHandler&#39;s handleEvent method will be used. After the event has fired&quot;,&quot; * the event listener is removed from the target. If an array of event types is&quot;,&quot; * provided, each event type will be listened to once.&quot;,&quot; * @param {goog.events.ListenableType} src Event source.&quot;,&quot; * @param {string|Array&lt;string&gt;|&quot;,&quot; *     !goog.events.EventId&lt;EVENTOBJ&gt;|!Array&lt;!goog.events.EventId&lt;EVENTOBJ&gt;&gt;}&quot;,&quot; *     type Event type to listen for or array of event types.&quot;,&quot; * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null=} opt_fn&quot;,&quot; *    Optional callback function to be used as the listener or an object with&quot;,&quot; *    handleEvent function.&quot;,&quot; * @param {(boolean|!AddEventListenerOptions)=} opt_options&quot;,&quot; * @param {Object=} opt_scope Object in whose scope to call the listener.&quot;,&quot; * @return {THIS} This object, allowing for chaining of calls.&quot;,&quot; * @this {THIS}&quot;,&quot; * @template EVENTOBJ, THIS&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.listenOnce_ = function(&quot;,&quot;    src, type, opt_fn, opt_options, opt_scope) {&quot;,&quot;  var self = /** @type {!goog.events.EventHandler} */ (this);&quot;,&quot;  if (goog.isArray(type)) {&quot;,&quot;    for (var i = 0; i &lt; type.length; i++) {&quot;,&quot;      self.listenOnce_(src, type[i], opt_fn, opt_options, opt_scope);&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    var listenerObj = goog.events.listenOnce(&quot;,&quot;        src, type, opt_fn || self.handleEvent, opt_options,&quot;,&quot;        opt_scope || self.handler_ || self);&quot;,&quot;    if (!listenerObj) {&quot;,&quot;      // When goog.events.listen run on OFF_AND_FAIL or OFF_AND_SILENT&quot;,&quot;      // (goog.events.CaptureSimulationMode) in IE8-, it will return null&quot;,&quot;      // value.&quot;,&quot;      return self;&quot;,&quot;    }&quot;,null,&quot;    var key = listenerObj.key;&quot;,&quot;    self.keys_[key] = listenerObj;&quot;,&quot;  }&quot;,null,&quot;  return self;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds an event listener with a specific event wrapper on a DOM Node or an&quot;,&quot; * object that has implemented {@link goog.events.EventTarget}. A listener can&quot;,&quot; * only be added once to an object.&quot;,&quot; *&quot;,&quot; * @param {EventTarget|goog.events.EventTarget} src The node to listen to&quot;,&quot; *     events on.&quot;,&quot; * @param {goog.events.EventWrapper} wrapper Event wrapper to use.&quot;,&quot; * @param {function(this:SCOPE, ?):?|{handleEvent:function(?):?}|null} listener&quot;,&quot; *     Callback method, or an object with a handleEvent function.&quot;,&quot; * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to&quot;,&quot; *     false).&quot;,&quot; * @return {THIS} This object, allowing for chaining of calls.&quot;,&quot; * @this {THIS}&quot;,&quot; * @template THIS&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.listenWithWrapper = function(&quot;,&quot;    src, wrapper, listener, opt_capt) {&quot;,&quot;  var self = /** @type {!goog.events.EventHandler} */ (this);&quot;,&quot;  // TODO(mknichel): Remove the opt_scope from this function and then&quot;,&quot;  // templatize it.&quot;,&quot;  return self.listenWithWrapper_(src, wrapper, listener, opt_capt);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds an event listener with a specific event wrapper on a DOM Node or an&quot;,&quot; * object that has implemented {@link goog.events.EventTarget}. A listener can&quot;,&quot; * only be added once to an object.&quot;,&quot; *&quot;,&quot; * @param {EventTarget|goog.events.EventTarget} src The node to listen to&quot;,&quot; *     events on.&quot;,&quot; * @param {goog.events.EventWrapper} wrapper Event wrapper to use.&quot;,&quot; * @param {function(this:T, ?):?|{handleEvent:function(this:T, ?):?}|null}&quot;,&quot; *     listener Optional callback function to be used as the&quot;,&quot; *     listener or an object with handleEvent function.&quot;,&quot; * @param {boolean|undefined} capture Optional whether to use capture phase.&quot;,&quot; * @param {T} scope Object in whose scope to call the listener.&quot;,&quot; * @return {THIS} This object, allowing for chaining of calls.&quot;,&quot; * @this {THIS}&quot;,&quot; * @template T, THIS&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.listenWithWrapperAndScope = function(&quot;,&quot;    src, wrapper, listener, capture, scope) {&quot;,&quot;  var self = /** @type {!goog.events.EventHandler} */ (this);&quot;,&quot;  // TODO(mknichel): Deprecate this function.&quot;,&quot;  return self.listenWithWrapper_(src, wrapper, listener, capture, scope);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds an event listener with a specific event wrapper on a DOM Node or an&quot;,&quot; * object that has implemented {@link goog.events.EventTarget}. A listener can&quot;,&quot; * only be added once to an object.&quot;,&quot; *&quot;,&quot; * @param {EventTarget|goog.events.EventTarget} src The node to listen to&quot;,&quot; *     events on.&quot;,&quot; * @param {goog.events.EventWrapper} wrapper Event wrapper to use.&quot;,&quot; * @param {function(?):?|{handleEvent:function(?):?}|null} listener Callback&quot;,&quot; *     method, or an object with a handleEvent function.&quot;,&quot; * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to&quot;,&quot; *     false).&quot;,&quot; * @param {Object=} opt_scope Element in whose scope to call the listener.&quot;,&quot; * @return {THIS} This object, allowing for chaining of calls.&quot;,&quot; * @this {THIS}&quot;,&quot; * @template THIS&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.listenWithWrapper_ = function(&quot;,&quot;    src, wrapper, listener, opt_capt, opt_scope) {&quot;,&quot;  var self = /** @type {!goog.events.EventHandler} */ (this);&quot;,&quot;  wrapper.listen(&quot;,&quot;      src, listener, opt_capt, opt_scope || self.handler_ || self, self);&quot;,&quot;  return self;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {number} Number of listeners registered by this handler.&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.getListenerCount = function() {&quot;,&quot;  var count = 0;&quot;,&quot;  for (var key in this.keys_) {&quot;,&quot;    if (Object.prototype.hasOwnProperty.call(this.keys_, key)) {&quot;,&quot;      count++;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return count;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Unlistens on an event.&quot;,&quot; * @param {goog.events.ListenableType} src Event source.&quot;,&quot; * @param {string|Array&lt;string&gt;|&quot;,&quot; *     !goog.events.EventId&lt;EVENTOBJ&gt;|!Array&lt;!goog.events.EventId&lt;EVENTOBJ&gt;&gt;}&quot;,&quot; *     type Event type or array of event types to unlisten to.&quot;,&quot; * @param {function(this:?, EVENTOBJ):?|{handleEvent:function(?):?}|null=}&quot;,&quot; *     opt_fn Optional callback function to be used as the listener or an object&quot;,&quot; *     with handleEvent function.&quot;,&quot; * @param {(boolean|!EventListenerOptions)=} opt_options&quot;,&quot; * @param {Object=} opt_scope Object in whose scope to call the listener.&quot;,&quot; * @return {THIS} This object, allowing for chaining of calls.&quot;,&quot; * @this {THIS}&quot;,&quot; * @template EVENTOBJ, THIS&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.unlisten = function(&quot;,&quot;    src, type, opt_fn, opt_options, opt_scope) {&quot;,&quot;  var self = /** @type {!goog.events.EventHandler} */ (this);&quot;,&quot;  if (goog.isArray(type)) {&quot;,&quot;    for (var i = 0; i &lt; type.length; i++) {&quot;,&quot;      self.unlisten(src, type[i], opt_fn, opt_options, opt_scope);&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    var capture =&quot;,&quot;        goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;&quot;,&quot;    var listener = goog.events.getListener(&quot;,&quot;        src, type, opt_fn || self.handleEvent, capture,&quot;,&quot;        opt_scope || self.handler_ || self);&quot;,null,&quot;    if (listener) {&quot;,&quot;      goog.events.unlistenByKey(listener);&quot;,&quot;      delete self.keys_[listener.key];&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  return self;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes an event listener which was added with listenWithWrapper().&quot;,&quot; *&quot;,&quot; * @param {EventTarget|goog.events.EventTarget} src The target to stop&quot;,&quot; *     listening to events on.&quot;,&quot; * @param {goog.events.EventWrapper} wrapper Event wrapper to use.&quot;,&quot; * @param {function(?):?|{handleEvent:function(?):?}|null} listener The&quot;,&quot; *     listener function to remove.&quot;,&quot; * @param {boolean=} opt_capt In DOM-compliant browsers, this determines&quot;,&quot; *     whether the listener is fired during the capture or bubble phase of the&quot;,&quot; *     event.&quot;,&quot; * @param {Object=} opt_scope Element in whose scope to call the listener.&quot;,&quot; * @return {THIS} This object, allowing for chaining of calls.&quot;,&quot; * @this {THIS}&quot;,&quot; * @template THIS&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.unlistenWithWrapper = function(&quot;,&quot;    src, wrapper, listener, opt_capt, opt_scope) {&quot;,&quot;  var self = /** @type {!goog.events.EventHandler} */ (this);&quot;,&quot;  wrapper.unlisten(&quot;,&quot;      src, listener, opt_capt, opt_scope || self.handler_ || self, self);&quot;,&quot;  return self;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Unlistens to all events.&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.removeAll = function() {&quot;,&quot;  goog.object.forEach(this.keys_, function(listenerObj, key) {&quot;,&quot;    if (this.keys_.hasOwnProperty(key)) {&quot;,&quot;      goog.events.unlistenByKey(listenerObj);&quot;,&quot;    }&quot;,&quot;  }, this);&quot;,null,&quot;  this.keys_ = {};&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Disposes of this EventHandler and removes all listeners that it registered.&quot;,&quot; * @override&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.disposeInternal = function() {&quot;,&quot;  goog.events.EventHandler.superClass_.disposeInternal.call(this);&quot;,&quot;  this.removeAll();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Default event handler&quot;,&quot; * @param {goog.events.Event} e Event object.&quot;,&quot; */&quot;,&quot;goog.events.EventHandler.prototype.handleEvent = function(e) {&quot;,&quot;  throw new Error(&#39;EventHandler.handleEvent not implemented&#39;);&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>