<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>eventtarget.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;eventtarget.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/events/eventtarget.js&quot;,[&quot;// Copyright 2005 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview A disposable implementation of a custom&quot;,&quot; * listenable/event target. See also: documentation for&quot;,&quot; * {@code goog.events.Listenable}.&quot;,&quot; *&quot;,&quot; * @author arv@google.com (Erik Arvidsson) [Original implementation]&quot;,&quot; * @see ../demos/eventtarget.html&quot;,&quot; * @see goog.events.Listenable&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.events.EventTarget&#39;);&quot;,null,&quot;goog.require(&#39;goog.Disposable&#39;);&quot;,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;goog.events&#39;);&quot;,&quot;goog.require(&#39;goog.events.Event&#39;);&quot;,&quot;goog.require(&#39;goog.events.Listenable&#39;);&quot;,&quot;goog.require(&#39;goog.events.ListenerMap&#39;);&quot;,&quot;goog.require(&#39;goog.object&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * An implementation of {@code goog.events.Listenable} with full W3C&quot;,&quot; * EventTarget-like support (capture/bubble mechanism, stopping event&quot;,&quot; * propagation, preventing default actions).&quot;,&quot; *&quot;,&quot; * You may subclass this class to turn your class into a Listenable.&quot;,&quot; *&quot;,&quot; * Unless propagation is stopped, an event dispatched by an&quot;,&quot; * EventTarget will bubble to the parent returned by&quot;,&quot; * {@code getParentEventTarget}. To set the parent, call&quot;,&quot; * {@code setParentEventTarget}. Subclasses that don&#39;t support&quot;,&quot; * changing the parent can override the setter to throw an error.&quot;,&quot; *&quot;,&quot; * Example usage:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; *   var source = new goog.events.EventTarget();&quot;,&quot; *   function handleEvent(e) {&quot;,&quot; *     alert(&#39;Type: &#39; + e.type + &#39;; Target: &#39; + e.target);&quot;,&quot; *   }&quot;,&quot; *   source.listen(&#39;foo&#39;, handleEvent);&quot;,&quot; *   // Or: goog.events.listen(source, &#39;foo&#39;, handleEvent);&quot;,&quot; *   ...&quot;,&quot; *   source.dispatchEvent(&#39;foo&#39;);  // will call handleEvent&quot;,&quot; *   ...&quot;,&quot; *   source.unlisten(&#39;foo&#39;, handleEvent);&quot;,&quot; *   // Or: goog.events.unlisten(source, &#39;foo&#39;, handleEvent);&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; *&quot;,&quot; * @constructor&quot;,&quot; * @extends {goog.Disposable}&quot;,&quot; * @implements {goog.events.Listenable}&quot;,&quot; */&quot;,&quot;goog.events.EventTarget = function() {&quot;,&quot;  goog.Disposable.call(this);&quot;,null,&quot;  /**&quot;,&quot;   * Maps of event type to an array of listeners.&quot;,&quot;   * @private {!goog.events.ListenerMap}&quot;,&quot;   */&quot;,&quot;  this.eventTargetListeners_ = new goog.events.ListenerMap(this);&quot;,null,&quot;  /**&quot;,&quot;   * The object to use for event.target. Useful when mixing in an&quot;,&quot;   * EventTarget to another object.&quot;,&quot;   * @private {!Object}&quot;,&quot;   */&quot;,&quot;  this.actualEventTarget_ = this;&quot;,null,&quot;  /**&quot;,&quot;   * Parent event target, used during event bubbling.&quot;,&quot;   *&quot;,&quot;   * TODO(chrishenry): Change this to goog.events.Listenable. This&quot;,&quot;   * currently breaks people who expect getParentEventTarget to return&quot;,&quot;   * goog.events.EventTarget.&quot;,&quot;   *&quot;,&quot;   * @private {goog.events.EventTarget}&quot;,&quot;   */&quot;,&quot;  this.parentEventTarget_ = null;&quot;,&quot;};&quot;,&quot;goog.inherits(goog.events.EventTarget, goog.Disposable);&quot;,&quot;goog.events.Listenable.addImplementation(goog.events.EventTarget);&quot;,null,null,&quot;/**&quot;,&quot; * An artificial cap on the number of ancestors you can have. This is mainly&quot;,&quot; * for loop detection.&quot;,&quot; * @const {number}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.EventTarget.MAX_ANCESTORS_ = 1000;&quot;,null,null,&quot;/**&quot;,&quot; * Returns the parent of this event target to use for bubbling.&quot;,&quot; *&quot;,&quot; * @return {goog.events.EventTarget} The parent EventTarget or null if&quot;,&quot; *     there is no parent.&quot;,&quot; * @override&quot;,&quot; */&quot;,&quot;goog.events.EventTarget.prototype.getParentEventTarget = function() {&quot;,&quot;  return this.parentEventTarget_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the parent of this event target to use for capture/bubble&quot;,&quot; * mechanism.&quot;,&quot; * @param {goog.events.EventTarget} parent Parent listenable (null if none).&quot;,&quot; */&quot;,&quot;goog.events.EventTarget.prototype.setParentEventTarget = function(parent) {&quot;,&quot;  this.parentEventTarget_ = parent;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds an event listener to the event target. The same handler can only be&quot;,&quot; * added once per the type. Even if you add the same handler multiple times&quot;,&quot; * using the same type then it will only be called once when the event is&quot;,&quot; * dispatched.&quot;,&quot; *&quot;,&quot; * @param {string|!goog.events.EventId} type The type of the event to listen for&quot;,&quot; * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function&quot;,&quot; *     to handle the event. The handler can also be an object that implements&quot;,&quot; *     the handleEvent method which takes the event object as argument.&quot;,&quot; * @param {boolean=} opt_capture In DOM-compliant browsers, this determines&quot;,&quot; *     whether the listener is fired during the capture or bubble phase&quot;,&quot; *     of the event.&quot;,&quot; * @param {Object=} opt_handlerScope Object in whose scope to call&quot;,&quot; *     the listener.&quot;,&quot; * @deprecated Use {@code #listen} instead, when possible. Otherwise, use&quot;,&quot; *     {@code goog.events.listen} if you are passing Object&quot;,&quot; *     (instead of Function) as handler.&quot;,&quot; */&quot;,&quot;goog.events.EventTarget.prototype.addEventListener = function(&quot;,&quot;    type, handler, opt_capture, opt_handlerScope) {&quot;,&quot;  goog.events.listen(this, type, handler, opt_capture, opt_handlerScope);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes an event listener from the event target. The handler must be the&quot;,&quot; * same object as the one added. If the handler has not been added then&quot;,&quot; * nothing is done.&quot;,&quot; *&quot;,&quot; * @param {string} type The type of the event to listen for.&quot;,&quot; * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function&quot;,&quot; *     to handle the event. The handler can also be an object that implements&quot;,&quot; *     the handleEvent method which takes the event object as argument.&quot;,&quot; * @param {boolean=} opt_capture In DOM-compliant browsers, this determines&quot;,&quot; *     whether the listener is fired during the capture or bubble phase&quot;,&quot; *     of the event.&quot;,&quot; * @param {Object=} opt_handlerScope Object in whose scope to call&quot;,&quot; *     the listener.&quot;,&quot; * @deprecated Use {@code #unlisten} instead, when possible. Otherwise, use&quot;,&quot; *     {@code goog.events.unlisten} if you are passing Object&quot;,&quot; *     (instead of Function) as handler.&quot;,&quot; */&quot;,&quot;goog.events.EventTarget.prototype.removeEventListener = function(&quot;,&quot;    type, handler, opt_capture, opt_handlerScope) {&quot;,&quot;  goog.events.unlisten(this, type, handler, opt_capture, opt_handlerScope);&quot;,&quot;};&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.events.EventTarget.prototype.dispatchEvent = function(e) {&quot;,&quot;  this.assertInitialized_();&quot;,null,&quot;  var ancestorsTree, ancestor = this.getParentEventTarget();&quot;,&quot;  if (ancestor) {&quot;,&quot;    ancestorsTree = [];&quot;,&quot;    var ancestorCount = 1;&quot;,&quot;    for (; ancestor; ancestor = ancestor.getParentEventTarget()) {&quot;,&quot;      ancestorsTree.push(ancestor);&quot;,&quot;      goog.asserts.assert(&quot;,&quot;          (++ancestorCount &lt; goog.events.EventTarget.MAX_ANCESTORS_),&quot;,&quot;          &#39;infinite loop&#39;);&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  return goog.events.EventTarget.dispatchEventInternal_(&quot;,&quot;      this.actualEventTarget_, e, ancestorsTree);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes listeners from this object.  Classes that extend EventTarget may&quot;,&quot; * need to override this method in order to remove references to DOM Elements&quot;,&quot; * and additional listeners.&quot;,&quot; * @override&quot;,&quot; */&quot;,&quot;goog.events.EventTarget.prototype.disposeInternal = function() {&quot;,&quot;  goog.events.EventTarget.superClass_.disposeInternal.call(this);&quot;,null,&quot;  this.removeAllListeners();&quot;,&quot;  this.parentEventTarget_ = null;&quot;,&quot;};&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.events.EventTarget.prototype.listen = function(&quot;,&quot;    type, listener, opt_useCapture, opt_listenerScope) {&quot;,&quot;  this.assertInitialized_();&quot;,&quot;  return this.eventTargetListeners_.add(&quot;,&quot;      String(type), listener, false /* callOnce */, opt_useCapture,&quot;,&quot;      opt_listenerScope);&quot;,&quot;};&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.events.EventTarget.prototype.listenOnce = function(&quot;,&quot;    type, listener, opt_useCapture, opt_listenerScope) {&quot;,&quot;  return this.eventTargetListeners_.add(&quot;,&quot;      String(type), listener, true /* callOnce */, opt_useCapture,&quot;,&quot;      opt_listenerScope);&quot;,&quot;};&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.events.EventTarget.prototype.unlisten = function(&quot;,&quot;    type, listener, opt_useCapture, opt_listenerScope) {&quot;,&quot;  return this.eventTargetListeners_.remove(&quot;,&quot;      String(type), listener, opt_useCapture, opt_listenerScope);&quot;,&quot;};&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.events.EventTarget.prototype.unlistenByKey = function(key) {&quot;,&quot;  return this.eventTargetListeners_.removeByKey(key);&quot;,&quot;};&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.events.EventTarget.prototype.removeAllListeners = function(opt_type) {&quot;,&quot;  // TODO(chrishenry): Previously, removeAllListeners can be called on&quot;,&quot;  // uninitialized EventTarget, so we preserve that behavior. We&quot;,&quot;  // should remove this when usages that rely on that fact are purged.&quot;,&quot;  if (!this.eventTargetListeners_) {&quot;,&quot;    return 0;&quot;,&quot;  }&quot;,&quot;  return this.eventTargetListeners_.removeAll(opt_type);&quot;,&quot;};&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.events.EventTarget.prototype.fireListeners = function(&quot;,&quot;    type, capture, eventObject) {&quot;,&quot;  // TODO(chrishenry): Original code avoids array creation when there&quot;,&quot;  // is no listener, so we do the same. If this optimization turns&quot;,&quot;  // out to be not required, we can replace this with&quot;,&quot;  // getListeners(type, capture) instead, which is simpler.&quot;,&quot;  var listenerArray = this.eventTargetListeners_.listeners[String(type)];&quot;,&quot;  if (!listenerArray) {&quot;,&quot;    return true;&quot;,&quot;  }&quot;,&quot;  listenerArray = listenerArray.concat();&quot;,null,&quot;  var rv = true;&quot;,&quot;  for (var i = 0; i &lt; listenerArray.length; ++i) {&quot;,&quot;    var listener = listenerArray[i];&quot;,&quot;    // We might not have a listener if the listener was removed.&quot;,&quot;    if (listener &amp;&amp; !listener.removed &amp;&amp; listener.capture == capture) {&quot;,&quot;      var listenerFn = listener.listener;&quot;,&quot;      var listenerHandler = listener.handler || listener.src;&quot;,null,&quot;      if (listener.callOnce) {&quot;,&quot;        this.unlistenByKey(listener);&quot;,&quot;      }&quot;,&quot;      rv = listenerFn.call(listenerHandler, eventObject) !== false &amp;&amp; rv;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  return rv &amp;&amp; eventObject.returnValue_ != false;&quot;,&quot;};&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.events.EventTarget.prototype.getListeners = function(type, capture) {&quot;,&quot;  return this.eventTargetListeners_.getListeners(String(type), capture);&quot;,&quot;};&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.events.EventTarget.prototype.getListener = function(&quot;,&quot;    type, listener, capture, opt_listenerScope) {&quot;,&quot;  return this.eventTargetListeners_.getListener(&quot;,&quot;      String(type), listener, capture, opt_listenerScope);&quot;,&quot;};&quot;,null,null,&quot;/** @override */&quot;,&quot;goog.events.EventTarget.prototype.hasListener = function(&quot;,&quot;    opt_type, opt_capture) {&quot;,&quot;  var id = goog.isDef(opt_type) ? String(opt_type) : undefined;&quot;,&quot;  return this.eventTargetListeners_.hasListener(id, opt_capture);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Sets the target to be used for {@code event.target} when firing&quot;,&quot; * event. Mainly used for testing. For example, see&quot;,&quot; * {@code goog.testing.events.mixinListenable}.&quot;,&quot; * @param {!Object} target The target.&quot;,&quot; */&quot;,&quot;goog.events.EventTarget.prototype.setTargetForTesting = function(target) {&quot;,&quot;  this.actualEventTarget_ = target;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Asserts that the event target instance is initialized properly.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.EventTarget.prototype.assertInitialized_ = function() {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      this.eventTargetListeners_,&quot;,&quot;      &#39;Event target is not initialized. Did you call the superclass &#39; +&quot;,&quot;          &#39;(goog.events.EventTarget) constructor?&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Dispatches the given event on the ancestorsTree.&quot;,&quot; *&quot;,&quot; * @param {!Object} target The target to dispatch on.&quot;,&quot; * @param {goog.events.Event|Object|string} e The event object.&quot;,&quot; * @param {Array&lt;goog.events.Listenable&gt;=} opt_ancestorsTree The ancestors&quot;,&quot; *     tree of the target, in reverse order from the closest ancestor&quot;,&quot; *     to the root event target. May be null if the target has no ancestor.&quot;,&quot; * @return {boolean} If anyone called preventDefault on the event object (or&quot;,&quot; *     if any of the listeners returns false) this will also return false.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.events.EventTarget.dispatchEventInternal_ = function(&quot;,&quot;    target, e, opt_ancestorsTree) {&quot;,&quot;  var type = e.type || /** @type {string} */ (e);&quot;,null,&quot;  // If accepting a string or object, create a custom event object so that&quot;,&quot;  // preventDefault and stopPropagation work with the event.&quot;,&quot;  if (goog.isString(e)) {&quot;,&quot;    e = new goog.events.Event(e, target);&quot;,&quot;  } else if (!(e instanceof goog.events.Event)) {&quot;,&quot;    var oldEvent = e;&quot;,&quot;    e = new goog.events.Event(type, target);&quot;,&quot;    goog.object.extend(e, oldEvent);&quot;,&quot;  } else {&quot;,&quot;    e.target = e.target || target;&quot;,&quot;  }&quot;,null,&quot;  var rv = true, currentTarget;&quot;,null,&quot;  // Executes all capture listeners on the ancestors, if any.&quot;,&quot;  if (opt_ancestorsTree) {&quot;,&quot;    for (var i = opt_ancestorsTree.length - 1; !e.propagationStopped_ &amp;&amp; i &gt;= 0;&quot;,&quot;         i--) {&quot;,&quot;      currentTarget = e.currentTarget = opt_ancestorsTree[i];&quot;,&quot;      rv = currentTarget.fireListeners(type, true, e) &amp;&amp; rv;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // Executes capture and bubble listeners on the target.&quot;,&quot;  if (!e.propagationStopped_) {&quot;,&quot;    currentTarget = /** @type {?} */ (e.currentTarget = target);&quot;,&quot;    rv = currentTarget.fireListeners(type, true, e) &amp;&amp; rv;&quot;,&quot;    if (!e.propagationStopped_) {&quot;,&quot;      rv = currentTarget.fireListeners(type, false, e) &amp;&amp; rv;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // Executes all bubble listeners on the ancestors, if any.&quot;,&quot;  if (opt_ancestorsTree) {&quot;,&quot;    for (i = 0; !e.propagationStopped_ &amp;&amp; i &lt; opt_ancestorsTree.length; i++) {&quot;,&quot;      currentTarget = e.currentTarget = opt_ancestorsTree[i];&quot;,&quot;      rv = currentTarget.fireListeners(type, false, e) &amp;&amp; rv;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  return rv;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>