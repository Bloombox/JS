<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>heap.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;heap.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/structs/heap.js&quot;,[&quot;// Copyright 2006 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Datastructure: Heap.&quot;,&quot; *&quot;,&quot; *&quot;,&quot; * This file provides the implementation of a Heap datastructure. Smaller keys&quot;,&quot; * rise to the top.&quot;,&quot; *&quot;,&quot; * The big-O notation for all operations are below:&quot;,&quot; * &lt;pre&gt;&quot;,&quot; *  Method          big-O&quot;,&quot; * ----------------------------------------------------------------------------&quot;,&quot; * - insert         O(logn)&quot;,&quot; * - remove         O(logn)&quot;,&quot; * - peek           O(1)&quot;,&quot; * - contains       O(n)&quot;,&quot; * &lt;/pre&gt;&quot;,&quot; */&quot;,&quot;// TODO(user): Should this rely on natural ordering via some Comparable&quot;,&quot;//     interface?&quot;,null,null,&quot;goog.provide(&#39;goog.structs.Heap&#39;);&quot;,null,&quot;goog.require(&#39;goog.array&#39;);&quot;,&quot;goog.require(&#39;goog.object&#39;);&quot;,&quot;goog.require(&#39;goog.structs.Node&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * Class for a Heap datastructure.&quot;,&quot; *&quot;,&quot; * @param {goog.structs.Heap|Object=} opt_heap Optional goog.structs.Heap or&quot;,&quot; *     Object to initialize heap with.&quot;,&quot; * @constructor&quot;,&quot; * @template K, V&quot;,&quot; */&quot;,&quot;goog.structs.Heap = function(opt_heap) {&quot;,&quot;  /**&quot;,&quot;   * The nodes of the heap.&quot;,&quot;   * @private&quot;,&quot;   * @type {Array&lt;goog.structs.Node&gt;}&quot;,&quot;   */&quot;,&quot;  this.nodes_ = [];&quot;,null,&quot;  if (opt_heap) {&quot;,&quot;    this.insertAll(opt_heap);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Insert the given value into the heap with the given key.&quot;,&quot; * @param {K} key The key.&quot;,&quot; * @param {V} value The value.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.insert = function(key, value) {&quot;,&quot;  var node = new goog.structs.Node(key, value);&quot;,&quot;  var nodes = this.nodes_;&quot;,&quot;  nodes.push(node);&quot;,&quot;  this.moveUp_(nodes.length - 1);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds multiple key-value pairs from another goog.structs.Heap or Object&quot;,&quot; * @param {goog.structs.Heap|Object} heap Object containing the data to add.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.insertAll = function(heap) {&quot;,&quot;  var keys, values;&quot;,&quot;  if (heap instanceof goog.structs.Heap) {&quot;,&quot;    keys = heap.getKeys();&quot;,&quot;    values = heap.getValues();&quot;,null,&quot;    // If it is a heap and the current heap is empty, I can rely on the fact&quot;,&quot;    // that the keys/values are in the correct order to put in the underlying&quot;,&quot;    // structure.&quot;,&quot;    if (this.getCount() &lt;= 0) {&quot;,&quot;      var nodes = this.nodes_;&quot;,&quot;      for (var i = 0; i &lt; keys.length; i++) {&quot;,&quot;        nodes.push(new goog.structs.Node(keys[i], values[i]));&quot;,&quot;      }&quot;,&quot;      return;&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    keys = goog.object.getKeys(heap);&quot;,&quot;    values = goog.object.getValues(heap);&quot;,&quot;  }&quot;,null,&quot;  for (var i = 0; i &lt; keys.length; i++) {&quot;,&quot;    this.insert(keys[i], values[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Retrieves and removes the root value of this heap.&quot;,&quot; * @return {V} The value removed from the root of the heap.  Returns&quot;,&quot; *     undefined if the heap is empty.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.remove = function() {&quot;,&quot;  var nodes = this.nodes_;&quot;,&quot;  var count = nodes.length;&quot;,&quot;  var rootNode = nodes[0];&quot;,&quot;  if (count &lt;= 0) {&quot;,&quot;    return undefined;&quot;,&quot;  } else if (count == 1) {&quot;,&quot;    goog.array.clear(nodes);&quot;,&quot;  } else {&quot;,&quot;    nodes[0] = nodes.pop();&quot;,&quot;    this.moveDown_(0);&quot;,&quot;  }&quot;,&quot;  return rootNode.getValue();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Retrieves but does not remove the root value of this heap.&quot;,&quot; * @return {V} The value at the root of the heap. Returns&quot;,&quot; *     undefined if the heap is empty.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.peek = function() {&quot;,&quot;  var nodes = this.nodes_;&quot;,&quot;  if (nodes.length == 0) {&quot;,&quot;    return undefined;&quot;,&quot;  }&quot;,&quot;  return nodes[0].getValue();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Retrieves but does not remove the key of the root node of this heap.&quot;,&quot; * @return {K} The key at the root of the heap. Returns undefined if the&quot;,&quot; *     heap is empty.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.peekKey = function() {&quot;,&quot;  return this.nodes_[0] &amp;&amp; this.nodes_[0].getKey();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Moves the node at the given index down to its proper place in the heap.&quot;,&quot; * @param {number} index The index of the node to move down.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.moveDown_ = function(index) {&quot;,&quot;  var nodes = this.nodes_;&quot;,&quot;  var count = nodes.length;&quot;,null,&quot;  // Save the node being moved down.&quot;,&quot;  var node = nodes[index];&quot;,&quot;  // While the current node has a child.&quot;,&quot;  while (index &lt; (count &gt;&gt; 1)) {&quot;,&quot;    var leftChildIndex = this.getLeftChildIndex_(index);&quot;,&quot;    var rightChildIndex = this.getRightChildIndex_(index);&quot;,null,&quot;    // Determine the index of the smaller child.&quot;,&quot;    var smallerChildIndex = rightChildIndex &lt; count &amp;&amp;&quot;,&quot;            nodes[rightChildIndex].getKey() &lt; nodes[leftChildIndex].getKey() ?&quot;,&quot;        rightChildIndex :&quot;,&quot;        leftChildIndex;&quot;,null,&quot;    // If the node being moved down is smaller than its children, the node&quot;,&quot;    // has found the correct index it should be at.&quot;,&quot;    if (nodes[smallerChildIndex].getKey() &gt; node.getKey()) {&quot;,&quot;      break;&quot;,&quot;    }&quot;,null,&quot;    // If not, then take the smaller child as the current node.&quot;,&quot;    nodes[index] = nodes[smallerChildIndex];&quot;,&quot;    index = smallerChildIndex;&quot;,&quot;  }&quot;,&quot;  nodes[index] = node;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Moves the node at the given index up to its proper place in the heap.&quot;,&quot; * @param {number} index The index of the node to move up.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.moveUp_ = function(index) {&quot;,&quot;  var nodes = this.nodes_;&quot;,&quot;  var node = nodes[index];&quot;,null,&quot;  // While the node being moved up is not at the root.&quot;,&quot;  while (index &gt; 0) {&quot;,&quot;    // If the parent is less than the node being moved up, move the parent down.&quot;,&quot;    var parentIndex = this.getParentIndex_(index);&quot;,&quot;    if (nodes[parentIndex].getKey() &gt; node.getKey()) {&quot;,&quot;      nodes[index] = nodes[parentIndex];&quot;,&quot;      index = parentIndex;&quot;,&quot;    } else {&quot;,&quot;      break;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  nodes[index] = node;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the index of the left child of the node at the given index.&quot;,&quot; * @param {number} index The index of the node to get the left child for.&quot;,&quot; * @return {number} The index of the left child.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.getLeftChildIndex_ = function(index) {&quot;,&quot;  return index * 2 + 1;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the index of the right child of the node at the given index.&quot;,&quot; * @param {number} index The index of the node to get the right child for.&quot;,&quot; * @return {number} The index of the right child.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.getRightChildIndex_ = function(index) {&quot;,&quot;  return index * 2 + 2;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the index of the parent of the node at the given index.&quot;,&quot; * @param {number} index The index of the node to get the parent for.&quot;,&quot; * @return {number} The index of the parent.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.getParentIndex_ = function(index) {&quot;,&quot;  return (index - 1) &gt;&gt; 1;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the values of the heap.&quot;,&quot; * @return {!Array&lt;V&gt;} The values in the heap.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.getValues = function() {&quot;,&quot;  var nodes = this.nodes_;&quot;,&quot;  var rv = [];&quot;,&quot;  var l = nodes.length;&quot;,&quot;  for (var i = 0; i &lt; l; i++) {&quot;,&quot;    rv.push(nodes[i].getValue());&quot;,&quot;  }&quot;,&quot;  return rv;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Gets the keys of the heap.&quot;,&quot; * @return {!Array&lt;K&gt;} The keys in the heap.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.getKeys = function() {&quot;,&quot;  var nodes = this.nodes_;&quot;,&quot;  var rv = [];&quot;,&quot;  var l = nodes.length;&quot;,&quot;  for (var i = 0; i &lt; l; i++) {&quot;,&quot;    rv.push(nodes[i].getKey());&quot;,&quot;  }&quot;,&quot;  return rv;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Whether the heap contains the given value.&quot;,&quot; * @param {V} val The value to check for.&quot;,&quot; * @return {boolean} Whether the heap contains the value.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.containsValue = function(val) {&quot;,&quot;  return goog.array.some(&quot;,&quot;      this.nodes_, function(node) { return node.getValue() == val; });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Whether the heap contains the given key.&quot;,&quot; * @param {K} key The key to check for.&quot;,&quot; * @return {boolean} Whether the heap contains the key.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.containsKey = function(key) {&quot;,&quot;  return goog.array.some(&quot;,&quot;      this.nodes_, function(node) { return node.getKey() == key; });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Clones a heap and returns a new heap&quot;,&quot; * @return {!goog.structs.Heap} A new goog.structs.Heap with the same key-value&quot;,&quot; *     pairs.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.clone = function() {&quot;,&quot;  return new goog.structs.Heap(this);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * The number of key-value pairs in the map&quot;,&quot; * @return {number} The number of pairs.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.getCount = function() {&quot;,&quot;  return this.nodes_.length;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns true if this heap contains no elements.&quot;,&quot; * @return {boolean} Whether this heap contains no elements.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.isEmpty = function() {&quot;,&quot;  return goog.array.isEmpty(this.nodes_);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes all elements from the heap.&quot;,&quot; */&quot;,&quot;goog.structs.Heap.prototype.clear = function() {&quot;,&quot;  goog.array.clear(this.nodes_);&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>