<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>map.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;map.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/structs/map.js&quot;,[&quot;// Copyright 2006 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Datastructure: Hash Map.&quot;,&quot; *&quot;,&quot; * @author arv@google.com (Erik Arvidsson)&quot;,&quot; *&quot;,&quot; * This file contains an implementation of a Map structure. It implements a lot&quot;,&quot; * of the methods used in goog.structs so those functions work on hashes. This&quot;,&quot; * is best suited for complex key types. For simple keys such as numbers and&quot;,&quot; * strings consider using the lighter-weight utilities in goog.object.&quot;,&quot; */&quot;,null,null,&quot;goog.provide(&#39;goog.structs.Map&#39;);&quot;,null,&quot;goog.require(&#39;goog.iter.Iterator&#39;);&quot;,&quot;goog.require(&#39;goog.iter.StopIteration&#39;);&quot;,&quot;goog.require(&#39;goog.object&#39;);&quot;,null,null,null,&quot;/**&quot;,&quot; * Class for Hash Map datastructure.&quot;,&quot; * @param {*=} opt_map Map or Object to initialize the map with.&quot;,&quot; * @param {...*} var_args If 2 or more arguments are present then they&quot;,&quot; *     will be used as key-value pairs.&quot;,&quot; * @constructor&quot;,&quot; * @template K, V&quot;,&quot; * @deprecated This type is misleading: use ES6 Map instead.&quot;,&quot; */&quot;,&quot;goog.structs.Map = function(opt_map, var_args) {&quot;,null,&quot;  /**&quot;,&quot;   * Underlying JS object used to implement the map.&quot;,&quot;   * @private {!Object}&quot;,&quot;   */&quot;,&quot;  this.map_ = {};&quot;,null,&quot;  /**&quot;,&quot;   * An array of keys. This is necessary for two reasons:&quot;,&quot;   *   1. Iterating the keys using for (var key in this.map_) allocates an&quot;,&quot;   *      object for every key in IE which is really bad for IE6 GC perf.&quot;,&quot;   *   2. Without a side data structure, we would need to escape all the keys&quot;,&quot;   *      as that would be the only way we could tell during iteration if the&quot;,&quot;   *      key was an internal key or a property of the object.&quot;,&quot;   *&quot;,&quot;   * This array can contain deleted keys so it&#39;s necessary to check the map&quot;,&quot;   * as well to see if the key is still in the map (this doesn&#39;t require a&quot;,&quot;   * memory allocation in IE).&quot;,&quot;   * @private {!Array&lt;string&gt;}&quot;,&quot;   */&quot;,&quot;  this.keys_ = [];&quot;,null,&quot;  /**&quot;,&quot;   * The number of key value pairs in the map.&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.count_ = 0;&quot;,null,&quot;  /**&quot;,&quot;   * Version used to detect changes while iterating.&quot;,&quot;   * @private {number}&quot;,&quot;   */&quot;,&quot;  this.version_ = 0;&quot;,null,&quot;  var argLength = arguments.length;&quot;,null,&quot;  if (argLength &gt; 1) {&quot;,&quot;    if (argLength % 2) {&quot;,&quot;      throw new Error(&#39;Uneven number of arguments&#39;);&quot;,&quot;    }&quot;,&quot;    for (var i = 0; i &lt; argLength; i += 2) {&quot;,&quot;      this.set(arguments[i], arguments[i + 1]);&quot;,&quot;    }&quot;,&quot;  } else if (opt_map) {&quot;,&quot;    this.addAll(/** @type {Object} */ (opt_map));&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {number} The number of key-value pairs in the map.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.getCount = function() {&quot;,&quot;  return this.count_;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the values of the map.&quot;,&quot; * @return {!Array&lt;V&gt;} The values in the map.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.getValues = function() {&quot;,&quot;  this.cleanupKeysArray_();&quot;,null,&quot;  var rv = [];&quot;,&quot;  for (var i = 0; i &lt; this.keys_.length; i++) {&quot;,&quot;    var key = this.keys_[i];&quot;,&quot;    rv.push(this.map_[key]);&quot;,&quot;  }&quot;,&quot;  return rv;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the keys of the map.&quot;,&quot; * @return {!Array&lt;string&gt;} Array of string values.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.getKeys = function() {&quot;,&quot;  this.cleanupKeysArray_();&quot;,&quot;  return /** @type {!Array&lt;string&gt;} */ (this.keys_.concat());&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Whether the map contains the given key.&quot;,&quot; * @param {*} key The key to check for.&quot;,&quot; * @return {boolean} Whether the map contains the key.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.containsKey = function(key) {&quot;,&quot;  return goog.structs.Map.hasKey_(this.map_, key);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Whether the map contains the given value. This is O(n).&quot;,&quot; * @param {V} val The value to check for.&quot;,&quot; * @return {boolean} Whether the map contains the value.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.containsValue = function(val) {&quot;,&quot;  for (var i = 0; i &lt; this.keys_.length; i++) {&quot;,&quot;    var key = this.keys_[i];&quot;,&quot;    if (goog.structs.Map.hasKey_(this.map_, key) &amp;&amp; this.map_[key] == val) {&quot;,&quot;      return true;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Whether this map is equal to the argument map.&quot;,&quot; * @param {goog.structs.Map} otherMap The map against which to test equality.&quot;,&quot; * @param {function(V, V): boolean=} opt_equalityFn Optional equality function&quot;,&quot; *     to test equality of values. If not specified, this will test whether&quot;,&quot; *     the values contained in each map are identical objects.&quot;,&quot; * @return {boolean} Whether the maps are equal.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {&quot;,&quot;  if (this === otherMap) {&quot;,&quot;    return true;&quot;,&quot;  }&quot;,null,&quot;  if (this.count_ != otherMap.getCount()) {&quot;,&quot;    return false;&quot;,&quot;  }&quot;,null,&quot;  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;&quot;,null,&quot;  this.cleanupKeysArray_();&quot;,&quot;  for (var key, i = 0; key = this.keys_[i]; i++) {&quot;,&quot;    if (!equalityFn(this.get(key), otherMap.get(key))) {&quot;,&quot;      return false;&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  return true;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Default equality test for values.&quot;,&quot; * @param {*} a The first value.&quot;,&quot; * @param {*} b The second value.&quot;,&quot; * @return {boolean} Whether a and b reference the same object.&quot;,&quot; */&quot;,&quot;goog.structs.Map.defaultEquals = function(a, b) {&quot;,&quot;  return a === b;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {boolean} Whether the map is empty.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.isEmpty = function() {&quot;,&quot;  return this.count_ == 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes all key-value pairs from the map.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.clear = function() {&quot;,&quot;  this.map_ = {};&quot;,&quot;  this.keys_.length = 0;&quot;,&quot;  this.count_ = 0;&quot;,&quot;  this.version_ = 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Removes a key-value pair based on the key. This is O(logN) amortized due to&quot;,&quot; * updating the keys array whenever the count becomes half the size of the keys&quot;,&quot; * in the keys array.&quot;,&quot; * @param {*} key  The key to remove.&quot;,&quot; * @return {boolean} Whether object was removed.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.remove = function(key) {&quot;,&quot;  if (goog.structs.Map.hasKey_(this.map_, key)) {&quot;,&quot;    delete this.map_[key];&quot;,&quot;    this.count_--;&quot;,&quot;    this.version_++;&quot;,null,&quot;    // clean up the keys array if the threshold is hit&quot;,&quot;    if (this.keys_.length &gt; 2 * this.count_) {&quot;,&quot;      this.cleanupKeysArray_();&quot;,&quot;    }&quot;,null,&quot;    return true;&quot;,&quot;  }&quot;,&quot;  return false;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Cleans up the temp keys array by removing entries that are no longer in the&quot;,&quot; * map.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.cleanupKeysArray_ = function() {&quot;,&quot;  if (this.count_ != this.keys_.length) {&quot;,&quot;    // First remove keys that are no longer in the map.&quot;,&quot;    var srcIndex = 0;&quot;,&quot;    var destIndex = 0;&quot;,&quot;    while (srcIndex &lt; this.keys_.length) {&quot;,&quot;      var key = this.keys_[srcIndex];&quot;,&quot;      if (goog.structs.Map.hasKey_(this.map_, key)) {&quot;,&quot;        this.keys_[destIndex++] = key;&quot;,&quot;      }&quot;,&quot;      srcIndex++;&quot;,&quot;    }&quot;,&quot;    this.keys_.length = destIndex;&quot;,&quot;  }&quot;,null,&quot;  if (this.count_ != this.keys_.length) {&quot;,&quot;    // If the count still isn&#39;t correct, that means we have duplicates. This can&quot;,&quot;    // happen when the same key is added and removed multiple times. Now we have&quot;,&quot;    // to allocate one extra Object to remove the duplicates. This could have&quot;,&quot;    // been done in the first pass, but in the common case, we can avoid&quot;,&quot;    // allocating an extra object by only doing this when necessary.&quot;,&quot;    var seen = {};&quot;,&quot;    var srcIndex = 0;&quot;,&quot;    var destIndex = 0;&quot;,&quot;    while (srcIndex &lt; this.keys_.length) {&quot;,&quot;      var key = this.keys_[srcIndex];&quot;,&quot;      if (!(goog.structs.Map.hasKey_(seen, key))) {&quot;,&quot;        this.keys_[destIndex++] = key;&quot;,&quot;        seen[key] = 1;&quot;,&quot;      }&quot;,&quot;      srcIndex++;&quot;,&quot;    }&quot;,&quot;    this.keys_.length = destIndex;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns the value for the given key.  If the key is not found and the default&quot;,&quot; * value is not given this will return {@code undefined}.&quot;,&quot; * @param {*} key The key to get the value for.&quot;,&quot; * @param {DEFAULT=} opt_val The value to return if no item is found for the&quot;,&quot; *     given key, defaults to undefined.&quot;,&quot; * @return {V|DEFAULT} The value for the given key.&quot;,&quot; * @template DEFAULT&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.get = function(key, opt_val) {&quot;,&quot;  if (goog.structs.Map.hasKey_(this.map_, key)) {&quot;,&quot;    return this.map_[key];&quot;,&quot;  }&quot;,&quot;  return opt_val;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds a key-value pair to the map.&quot;,&quot; * @param {*} key The key.&quot;,&quot; * @param {V} value The value to add.&quot;,&quot; * @return {*} Some subclasses return a value.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.set = function(key, value) {&quot;,&quot;  if (!(goog.structs.Map.hasKey_(this.map_, key))) {&quot;,&quot;    this.count_++;&quot;,&quot;    // TODO(johnlenz): This class lies, it claims to return an array of string&quot;,&quot;    // keys, but instead returns the original object used.&quot;,&quot;    this.keys_.push(/** @type {?} */ (key));&quot;,&quot;    // Only change the version if we add a new key.&quot;,&quot;    this.version_++;&quot;,&quot;  }&quot;,&quot;  this.map_[key] = value;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Adds multiple key-value pairs from another goog.structs.Map or Object.&quot;,&quot; * @param {Object} map  Object containing the data to add.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.addAll = function(map) {&quot;,&quot;  var keys, values;&quot;,&quot;  if (map instanceof goog.structs.Map) {&quot;,&quot;    keys = map.getKeys();&quot;,&quot;    values = map.getValues();&quot;,&quot;  } else {&quot;,&quot;    keys = goog.object.getKeys(map);&quot;,&quot;    values = goog.object.getValues(map);&quot;,&quot;  }&quot;,&quot;  // we could use goog.array.forEach here but I don&#39;t want to introduce that&quot;,&quot;  // dependency just for this.&quot;,&quot;  for (var i = 0; i &lt; keys.length; i++) {&quot;,&quot;    this.set(keys[i], values[i]);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Calls the given function on each entry in the map.&quot;,&quot; * @param {function(this:T, V, K, goog.structs.Map&lt;K,V&gt;)} f&quot;,&quot; * @param {T=} opt_obj The value of \&quot;this\&quot; inside f.&quot;,&quot; * @template T&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.forEach = function(f, opt_obj) {&quot;,&quot;  var keys = this.getKeys();&quot;,&quot;  for (var i = 0; i &lt; keys.length; i++) {&quot;,&quot;    var key = keys[i];&quot;,&quot;    var value = this.get(key);&quot;,&quot;    f.call(opt_obj, value, key, this);&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Clones a map and returns a new map.&quot;,&quot; * @return {!goog.structs.Map} A new map with the same key-value pairs.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.clone = function() {&quot;,&quot;  return new goog.structs.Map(this);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns a new map in which all the keys and values are interchanged&quot;,&quot; * (keys become values and values become keys). If multiple keys map to the&quot;,&quot; * same value, the chosen transposed value is implementation-dependent.&quot;,&quot; *&quot;,&quot; * It acts very similarly to {goog.object.transpose(Object)}.&quot;,&quot; *&quot;,&quot; * @return {!goog.structs.Map} The transposed map.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.transpose = function() {&quot;,&quot;  var transposed = new goog.structs.Map();&quot;,&quot;  for (var i = 0; i &lt; this.keys_.length; i++) {&quot;,&quot;    var key = this.keys_[i];&quot;,&quot;    var value = this.map_[key];&quot;,&quot;    transposed.set(value, key);&quot;,&quot;  }&quot;,null,&quot;  return transposed;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @return {!Object} Object representation of the map.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.toObject = function() {&quot;,&quot;  this.cleanupKeysArray_();&quot;,&quot;  var obj = {};&quot;,&quot;  for (var i = 0; i &lt; this.keys_.length; i++) {&quot;,&quot;    var key = this.keys_[i];&quot;,&quot;    obj[key] = this.map_[key];&quot;,&quot;  }&quot;,&quot;  return obj;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns an iterator that iterates over the keys in the map.  Removal of keys&quot;,&quot; * while iterating might have undesired side effects.&quot;,&quot; * @return {!goog.iter.Iterator} An iterator over the keys in the map.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.getKeyIterator = function() {&quot;,&quot;  return this.__iterator__(true);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns an iterator that iterates over the values in the map.  Removal of&quot;,&quot; * keys while iterating might have undesired side effects.&quot;,&quot; * @return {!goog.iter.Iterator} An iterator over the values in the map.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.getValueIterator = function() {&quot;,&quot;  return this.__iterator__(false);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Returns an iterator that iterates over the values or the keys in the map.&quot;,&quot; * This throws an exception if the map was mutated since the iterator was&quot;,&quot; * created.&quot;,&quot; * @param {boolean=} opt_keys True to iterate over the keys. False to iterate&quot;,&quot; *     over the values.  The default value is false.&quot;,&quot; * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.&quot;,&quot; */&quot;,&quot;goog.structs.Map.prototype.__iterator__ = function(opt_keys) {&quot;,&quot;  // Clean up keys to minimize the risk of iterating over dead keys.&quot;,&quot;  this.cleanupKeysArray_();&quot;,null,&quot;  var i = 0;&quot;,&quot;  var version = this.version_;&quot;,&quot;  var selfObj = this;&quot;,null,&quot;  var newIter = new goog.iter.Iterator;&quot;,&quot;  newIter.next = function() {&quot;,&quot;    if (version != selfObj.version_) {&quot;,&quot;      throw new Error(&#39;The map has changed since the iterator was created&#39;);&quot;,&quot;    }&quot;,&quot;    if (i &gt;= selfObj.keys_.length) {&quot;,&quot;      throw goog.iter.StopIteration;&quot;,&quot;    }&quot;,&quot;    var key = selfObj.keys_[i++];&quot;,&quot;    return opt_keys ? key : selfObj.map_[key];&quot;,&quot;  };&quot;,&quot;  return newIter;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Safe way to test for hasOwnProperty.  It even allows testing for&quot;,&quot; * &#39;hasOwnProperty&#39;.&quot;,&quot; * @param {Object} obj The object to test for presence of the given key.&quot;,&quot; * @param {*} key The key to check for.&quot;,&quot; * @return {boolean} Whether the object has the key.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.structs.Map.hasKey_ = function(obj, key) {&quot;,&quot;  return Object.prototype.hasOwnProperty.call(obj, key);&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>