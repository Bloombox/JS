<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>base64.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;base64.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/crypt/base64.js&quot;,[&quot;// Copyright 2007 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Base64 en/decoding. Not much to say here except that we&quot;,&quot; * work with decoded values in arrays of bytes. By \&quot;byte\&quot; I mean a number&quot;,&quot; * in [0, 255].&quot;,&quot; *&quot;,&quot; * @author doughtie@google.com (Gavin Doughtie)&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.crypt.base64&#39;);&quot;,null,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,&quot;goog.require(&#39;goog.crypt&#39;);&quot;,&quot;goog.require(&#39;goog.string&#39;);&quot;,&quot;goog.require(&#39;goog.userAgent&#39;);&quot;,&quot;goog.require(&#39;goog.userAgent.product&#39;);&quot;,null,&quot;// Static lookup maps, lazily populated by init_()&quot;,null,null,&quot;/**&quot;,&quot; * Maps bytes to characters.&quot;,&quot; * @type {Object}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.crypt.base64.byteToCharMap_ = null;&quot;,null,null,&quot;/**&quot;,&quot; * Maps characters to bytes. Used for normal and websafe characters.&quot;,&quot; * @type {Object}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.crypt.base64.charToByteMap_ = null;&quot;,null,null,&quot;/**&quot;,&quot; * Maps bytes to websafe characters.&quot;,&quot; * @type {Object}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.crypt.base64.byteToCharMapWebSafe_ = null;&quot;,null,null,&quot;/**&quot;,&quot; * Our default alphabet, shared between&quot;,&quot; * ENCODED_VALS and ENCODED_VALS_WEBSAFE&quot;,&quot; * @type {string}&quot;,&quot; */&quot;,&quot;goog.crypt.base64.ENCODED_VALS_BASE = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; +&quot;,&quot;    &#39;abcdefghijklmnopqrstuvwxyz&#39; +&quot;,&quot;    &#39;0123456789&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * Our default alphabet. Value 64 (=) is special; it means \&quot;nothing.\&quot;&quot;,&quot; * @type {string}&quot;,&quot; */&quot;,&quot;goog.crypt.base64.ENCODED_VALS = goog.crypt.base64.ENCODED_VALS_BASE + &#39;+/=&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * Our websafe alphabet.&quot;,&quot; * @type {string}&quot;,&quot; */&quot;,&quot;goog.crypt.base64.ENCODED_VALS_WEBSAFE =&quot;,&quot;    goog.crypt.base64.ENCODED_VALS_BASE + &#39;-_.&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * White list of implementations with known-good native atob and btoa functions.&quot;,&quot; * Listing these explicitly (via the ASSUME_* wrappers) benefits dead-code&quot;,&quot; * removal in per-browser compilations.&quot;,&quot; * @private {boolean}&quot;,&quot; */&quot;,&quot;goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ = goog.userAgent.GECKO ||&quot;,&quot;    (goog.userAgent.WEBKIT &amp;&amp; !goog.userAgent.product.SAFARI) ||&quot;,&quot;    goog.userAgent.OPERA;&quot;,null,null,&quot;/**&quot;,&quot; * Does this browser have a working btoa function?&quot;,&quot; * @private {boolean}&quot;,&quot; */&quot;,&quot;goog.crypt.base64.HAS_NATIVE_ENCODE_ =&quot;,&quot;    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||&quot;,&quot;    typeof(goog.global.btoa) == &#39;function&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * Does this browser have a working atob function?&quot;,&quot; * We blacklist known-bad implementations:&quot;,&quot; *  - IE (10+) added atob() but it does not tolerate whitespace on the input.&quot;,&quot; * @private {boolean}&quot;,&quot; */&quot;,&quot;goog.crypt.base64.HAS_NATIVE_DECODE_ =&quot;,&quot;    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||&quot;,&quot;    (!goog.userAgent.product.SAFARI &amp;&amp; !goog.userAgent.IE &amp;&amp;&quot;,&quot;     typeof(goog.global.atob) == &#39;function&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * Base64-encode an array of bytes.&quot;,&quot; *&quot;,&quot; * @param {Array&lt;number&gt;|Uint8Array} input An array of bytes (numbers with&quot;,&quot; *     value in [0, 255]) to encode.&quot;,&quot; * @param {boolean=} opt_webSafe True indicates we should use the alternative&quot;,&quot; *     alphabet, which does not require escaping for use in URLs.&quot;,&quot; * @return {string} The base64 encoded string.&quot;,&quot; */&quot;,&quot;goog.crypt.base64.encodeByteArray = function(input, opt_webSafe) {&quot;,&quot;  // Assert avoids runtime dependency on goog.isArrayLike, which helps reduce&quot;,&quot;  // size of jscompiler output, and which yields slight performance increase.&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      goog.isArrayLike(input), &#39;encodeByteArray takes an array as a parameter&#39;);&quot;,null,&quot;  goog.crypt.base64.init_();&quot;,null,&quot;  var byteToCharMap = opt_webSafe ? goog.crypt.base64.byteToCharMapWebSafe_ :&quot;,&quot;                                    goog.crypt.base64.byteToCharMap_;&quot;,null,&quot;  var output = [];&quot;,null,&quot;  for (var i = 0; i &lt; input.length; i += 3) {&quot;,&quot;    var byte1 = input[i];&quot;,&quot;    var haveByte2 = i + 1 &lt; input.length;&quot;,&quot;    var byte2 = haveByte2 ? input[i + 1] : 0;&quot;,&quot;    var haveByte3 = i + 2 &lt; input.length;&quot;,&quot;    var byte3 = haveByte3 ? input[i + 2] : 0;&quot;,null,&quot;    var outByte1 = byte1 &gt;&gt; 2;&quot;,&quot;    var outByte2 = ((byte1 &amp; 0x03) &lt;&lt; 4) | (byte2 &gt;&gt; 4);&quot;,&quot;    var outByte3 = ((byte2 &amp; 0x0F) &lt;&lt; 2) | (byte3 &gt;&gt; 6);&quot;,&quot;    var outByte4 = byte3 &amp; 0x3F;&quot;,null,&quot;    if (!haveByte3) {&quot;,&quot;      outByte4 = 64;&quot;,null,&quot;      if (!haveByte2) {&quot;,&quot;        outByte3 = 64;&quot;,&quot;      }&quot;,&quot;    }&quot;,null,&quot;    output.push(&quot;,&quot;        byteToCharMap[outByte1], byteToCharMap[outByte2],&quot;,&quot;        byteToCharMap[outByte3], byteToCharMap[outByte4]);&quot;,&quot;  }&quot;,null,&quot;  return output.join(&#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Base64-encode a string.&quot;,&quot; *&quot;,&quot; * @param {string} input A string to encode.&quot;,&quot; * @param {boolean=} opt_webSafe True indicates we should use the alternative&quot;,&quot; *     alphabet, which does not require escaping for use in URLs.&quot;,&quot; * @return {string} The base64 encoded string.&quot;,&quot; */&quot;,&quot;goog.crypt.base64.encodeString = function(input, opt_webSafe) {&quot;,&quot;  // Shortcut for browsers that implement&quot;,&quot;  // a native base64 encoder in the form of \&quot;btoa/atob\&quot;&quot;,&quot;  if (goog.crypt.base64.HAS_NATIVE_ENCODE_ &amp;&amp; !opt_webSafe) {&quot;,&quot;    return goog.global.btoa(input);&quot;,&quot;  }&quot;,&quot;  return goog.crypt.base64.encodeByteArray(&quot;,&quot;      goog.crypt.stringToByteArray(input), opt_webSafe);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Base64-decode a string.&quot;,&quot; *&quot;,&quot; * @param {string} input Input to decode. Any whitespace is ignored, and the&quot;,&quot; *     input maybe encoded with either supported alphabet (or a mix thereof).&quot;,&quot; * @param {boolean=} opt_webSafe True indicates we should use the alternative&quot;,&quot; *     alphabet, which does not require escaping for use in URLs. Note that&quot;,&quot; *     passing false may also still allow webSafe input decoding, when the&quot;,&quot; *     fallback decoder is used on browsers without native support.&quot;,&quot; * @return {string} string representing the decoded value.&quot;,&quot; */&quot;,&quot;goog.crypt.base64.decodeString = function(input, opt_webSafe) {&quot;,&quot;  // Shortcut for browsers that implement&quot;,&quot;  // a native base64 encoder in the form of \&quot;btoa/atob\&quot;&quot;,&quot;  if (goog.crypt.base64.HAS_NATIVE_DECODE_ &amp;&amp; !opt_webSafe) {&quot;,&quot;    return goog.global.atob(input);&quot;,&quot;  }&quot;,&quot;  var output = &#39;&#39;;&quot;,&quot;  function pushByte(b) { output += String.fromCharCode(b); }&quot;,null,&quot;  goog.crypt.base64.decodeStringInternal_(input, pushByte);&quot;,null,&quot;  return output;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Base64-decode a string to an Array of numbers.&quot;,&quot; *&quot;,&quot; * In base-64 decoding, groups of four characters are converted into three&quot;,&quot; * bytes.  If the encoder did not apply padding, the input length may not&quot;,&quot; * be a multiple of 4.&quot;,&quot; *&quot;,&quot; * In this case, the last group will have fewer than 4 characters, and&quot;,&quot; * padding will be inferred.  If the group has one or two characters, it decodes&quot;,&quot; * to one byte.  If the group has three characters, it decodes to two bytes.&quot;,&quot; *&quot;,&quot; * @param {string} input Input to decode. Any whitespace is ignored, and the&quot;,&quot; *     input maybe encoded with either supported alphabet (or a mix thereof).&quot;,&quot; * @param {boolean=} opt_ignored Unused parameter, retained for compatibility.&quot;,&quot; * @return {!Array&lt;number&gt;} bytes representing the decoded value.&quot;,&quot; */&quot;,&quot;goog.crypt.base64.decodeStringToByteArray = function(input, opt_ignored) {&quot;,&quot;  var output = [];&quot;,&quot;  function pushByte(b) { output.push(b); }&quot;,null,&quot;  goog.crypt.base64.decodeStringInternal_(input, pushByte);&quot;,null,&quot;  return output;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Base64-decode a string to a Uint8Array.&quot;,&quot; *&quot;,&quot; * Note that Uint8Array is not supported on older browsers, e.g. IE &lt; 10.&quot;,&quot; * @see http://caniuse.com/uint8array&quot;,&quot; *&quot;,&quot; * In base-64 decoding, groups of four characters are converted into three&quot;,&quot; * bytes.  If the encoder did not apply padding, the input length may not&quot;,&quot; * be a multiple of 4.&quot;,&quot; *&quot;,&quot; * In this case, the last group will have fewer than 4 characters, and&quot;,&quot; * padding will be inferred.  If the group has one or two characters, it decodes&quot;,&quot; * to one byte.  If the group has three characters, it decodes to two bytes.&quot;,&quot; *&quot;,&quot; * @param {string} input Input to decode. Any whitespace is ignored, and the&quot;,&quot; *     input maybe encoded with either supported alphabet (or a mix thereof).&quot;,&quot; * @return {!Uint8Array} bytes representing the decoded value.&quot;,&quot; */&quot;,&quot;goog.crypt.base64.decodeStringToUint8Array = function(input) {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      !goog.userAgent.IE || goog.userAgent.isVersionOrHigher(&#39;10&#39;),&quot;,&quot;      &#39;Browser does not support typed arrays&#39;);&quot;,&quot;  var len = input.length;&quot;,&quot;  // Check if there are trailing &#39;=&#39; as padding in the b64 string.&quot;,&quot;  var placeholders = 0;&quot;,&quot;  if (input[len - 2] === &#39;=&#39;) {&quot;,&quot;    placeholders = 2;&quot;,&quot;  } else if (input[len - 1] === &#39;=&#39;) {&quot;,&quot;    placeholders = 1;&quot;,&quot;  }&quot;,&quot;  var output = new Uint8Array(Math.ceil(len * 3 / 4) - placeholders);&quot;,&quot;  var outLen = 0;&quot;,&quot;  function pushByte(b) {&quot;,&quot;    output[outLen++] = b;&quot;,&quot;  }&quot;,null,&quot;  goog.crypt.base64.decodeStringInternal_(input, pushByte);&quot;,null,&quot;  return output.subarray(0, outLen);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * @param {string} input Input to decode.&quot;,&quot; * @param {function(number):void} pushByte result accumulator.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.crypt.base64.decodeStringInternal_ = function(input, pushByte) {&quot;,&quot;  goog.crypt.base64.init_();&quot;,null,&quot;  var nextCharIndex = 0;&quot;,&quot;  /**&quot;,&quot;   * @param {number} default_val Used for end-of-input.&quot;,&quot;   * @return {number} The next 6-bit value, or the default for end-of-input.&quot;,&quot;   */&quot;,&quot;  function getByte(default_val) {&quot;,&quot;    while (nextCharIndex &lt; input.length) {&quot;,&quot;      var ch = input.charAt(nextCharIndex++);&quot;,&quot;      var b = goog.crypt.base64.charToByteMap_[ch];&quot;,&quot;      if (b != null) {&quot;,&quot;        return b;  // Common case: decoded the char.&quot;,&quot;      }&quot;,&quot;      if (!goog.string.isEmptyOrWhitespace(ch)) {&quot;,&quot;        throw new Error(&#39;Unknown base64 encoding at char: &#39; + ch);&quot;,&quot;      }&quot;,&quot;      // We encountered whitespace: loop around to the next input char.&quot;,&quot;    }&quot;,&quot;    return default_val;  // No more input remaining.&quot;,&quot;  }&quot;,null,&quot;  while (true) {&quot;,&quot;    var byte1 = getByte(-1);&quot;,&quot;    var byte2 = getByte(0);&quot;,&quot;    var byte3 = getByte(64);&quot;,&quot;    var byte4 = getByte(64);&quot;,null,&quot;    // The common case is that all four bytes are present, so if we have byte4&quot;,&quot;    // we can skip over the truncated input special case handling.&quot;,&quot;    if (byte4 === 64) {&quot;,&quot;      if (byte1 === -1) {&quot;,&quot;        return;  // Terminal case: no input left to decode.&quot;,&quot;      }&quot;,&quot;      // Here we know an intermediate number of bytes are missing.&quot;,&quot;      // The defaults for byte2, byte3 and byte4 apply the inferred padding&quot;,&quot;      // rules per the public API documentation. i.e: 1 byte&quot;,&quot;      // missing should yield 2 bytes of output, but 2 or 3 missing bytes yield&quot;,&quot;      // a single byte of output. (Recall that 64 corresponds the padding char).&quot;,&quot;    }&quot;,null,&quot;    var outByte1 = (byte1 &lt;&lt; 2) | (byte2 &gt;&gt; 4);&quot;,&quot;    pushByte(outByte1);&quot;,null,&quot;    if (byte3 != 64) {&quot;,&quot;      var outByte2 = ((byte2 &lt;&lt; 4) &amp; 0xF0) | (byte3 &gt;&gt; 2);&quot;,&quot;      pushByte(outByte2);&quot;,null,&quot;      if (byte4 != 64) {&quot;,&quot;        var outByte3 = ((byte3 &lt;&lt; 6) &amp; 0xC0) | byte4;&quot;,&quot;        pushByte(outByte3);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Lazy static initialization function. Called before&quot;,&quot; * accessing any of the static map variables.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;goog.crypt.base64.init_ = function() {&quot;,&quot;  if (!goog.crypt.base64.byteToCharMap_) {&quot;,&quot;    goog.crypt.base64.byteToCharMap_ = {};&quot;,&quot;    goog.crypt.base64.charToByteMap_ = {};&quot;,&quot;    goog.crypt.base64.byteToCharMapWebSafe_ = {};&quot;,null,&quot;    // We want quick mappings back and forth, so we precompute two maps.&quot;,&quot;    for (var i = 0; i &lt; goog.crypt.base64.ENCODED_VALS.length; i++) {&quot;,&quot;      goog.crypt.base64.byteToCharMap_[i] =&quot;,&quot;          goog.crypt.base64.ENCODED_VALS.charAt(i);&quot;,&quot;      goog.crypt.base64.charToByteMap_[goog.crypt.base64.byteToCharMap_[i]] = i;&quot;,&quot;      goog.crypt.base64.byteToCharMapWebSafe_[i] =&quot;,&quot;          goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(i);&quot;,null,&quot;      // Be forgiving when decoding and correctly decode both encodings.&quot;,&quot;      if (i &gt;= goog.crypt.base64.ENCODED_VALS_BASE.length) {&quot;,&quot;        goog.crypt.base64&quot;,&quot;            .charToByteMap_[goog.crypt.base64.ENCODED_VALS_WEBSAFE.charAt(i)] =&quot;,&quot;            i;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>