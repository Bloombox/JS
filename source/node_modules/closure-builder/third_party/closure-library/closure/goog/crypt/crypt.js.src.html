<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>crypt.js</title><link href="../../../../../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;crypt.js&quot;,&quot;node_modules/closure-builder/third_party/closure-library/closure/goog/crypt/crypt.js&quot;,[&quot;// Copyright 2008 The Closure Library Authors. All Rights Reserved.&quot;,&quot;//&quot;,&quot;// Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot;// you may not use this file except in compliance with the License.&quot;,&quot;// You may obtain a copy of the License at&quot;,&quot;//&quot;,&quot;//      http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot;//&quot;,&quot;// Unless required by applicable law or agreed to in writing, software&quot;,&quot;// distributed under the License is distributed on an \&quot;AS-IS\&quot; BASIS,&quot;,&quot;// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot;// See the License for the specific language governing permissions and&quot;,&quot;// limitations under the License.&quot;,null,&quot;/**&quot;,&quot; * @fileoverview Namespace with crypto related helper functions.&quot;,&quot; */&quot;,null,&quot;goog.provide(&#39;goog.crypt&#39;);&quot;,null,&quot;goog.require(&#39;goog.array&#39;);&quot;,&quot;goog.require(&#39;goog.asserts&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * Turns a string into an array of bytes; a \&quot;byte\&quot; being a JS number in the&quot;,&quot; * range 0-255. Multi-byte characters are written as little-endian.&quot;,&quot; * @param {string} str String value to arrify.&quot;,&quot; * @return {!Array&lt;number&gt;} Array of numbers corresponding to the&quot;,&quot; *     UCS character codes of each character in str.&quot;,&quot; */&quot;,&quot;goog.crypt.stringToByteArray = function(str) {&quot;,&quot;  var output = [], p = 0;&quot;,&quot;  for (var i = 0; i &lt; str.length; i++) {&quot;,&quot;    var c = str.charCodeAt(i);&quot;,&quot;    // NOTE: c &lt;= 0xffff since JavaScript strings are UTF-16.&quot;,&quot;    if (c &gt; 0xff) {&quot;,&quot;      output[p++] = c &amp; 0xff;&quot;,&quot;      c &gt;&gt;= 8;&quot;,&quot;    }&quot;,&quot;    output[p++] = c;&quot;,&quot;  }&quot;,&quot;  return output;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Turns an array of numbers into the string given by the concatenation of the&quot;,&quot; * characters to which the numbers correspond.&quot;,&quot; * @param {!Uint8Array|!Array&lt;number&gt;} bytes Array of numbers representing&quot;,&quot; *     characters.&quot;,&quot; * @return {string} Stringification of the array.&quot;,&quot; */&quot;,&quot;goog.crypt.byteArrayToString = function(bytes) {&quot;,&quot;  var CHUNK_SIZE = 8192;&quot;,null,&quot;  // Special-case the simple case for speed&#39;s sake.&quot;,&quot;  if (bytes.length &lt;= CHUNK_SIZE) {&quot;,&quot;    return String.fromCharCode.apply(null, bytes);&quot;,&quot;  }&quot;,null,&quot;  // The remaining logic splits conversion by chunks since&quot;,&quot;  // Function#apply() has a maximum parameter count.&quot;,&quot;  // See discussion: http://goo.gl/LrWmZ9&quot;,null,&quot;  var str = &#39;&#39;;&quot;,&quot;  for (var i = 0; i &lt; bytes.length; i += CHUNK_SIZE) {&quot;,&quot;    var chunk = goog.array.slice(bytes, i, i + CHUNK_SIZE);&quot;,&quot;    str += String.fromCharCode.apply(null, chunk);&quot;,&quot;  }&quot;,&quot;  return str;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Turns an array of numbers into the hex string given by the concatenation of&quot;,&quot; * the hex values to which the numbers correspond.&quot;,&quot; * @param {Uint8Array|Array&lt;number&gt;} array Array of numbers representing&quot;,&quot; *     characters.&quot;,&quot; * @return {string} Hex string.&quot;,&quot; */&quot;,&quot;goog.crypt.byteArrayToHex = function(array) {&quot;,&quot;  return goog.array&quot;,&quot;      .map(&quot;,&quot;          array,&quot;,&quot;          function(numByte) {&quot;,&quot;            var hexByte = numByte.toString(16);&quot;,&quot;            return hexByte.length &gt; 1 ? hexByte : &#39;0&#39; + hexByte;&quot;,&quot;          })&quot;,&quot;      .join(&#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a hex string into an integer array.&quot;,&quot; * @param {string} hexString Hex string of 16-bit integers (two characters&quot;,&quot; *     per integer).&quot;,&quot; * @return {!Array&lt;number&gt;} Array of {0,255} integers for the given string.&quot;,&quot; */&quot;,&quot;goog.crypt.hexToByteArray = function(hexString) {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      hexString.length % 2 == 0, &#39;Key string length must be multiple of 2&#39;);&quot;,&quot;  var arr = [];&quot;,&quot;  for (var i = 0; i &lt; hexString.length; i += 2) {&quot;,&quot;    arr.push(parseInt(hexString.substring(i, i + 2), 16));&quot;,&quot;  }&quot;,&quot;  return arr;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a JS string to a UTF-8 \&quot;byte\&quot; array.&quot;,&quot; * @param {string} str 16-bit unicode string.&quot;,&quot; * @return {!Array&lt;number&gt;} UTF-8 byte array.&quot;,&quot; */&quot;,&quot;goog.crypt.stringToUtf8ByteArray = function(str) {&quot;,&quot;  // TODO(user): Use native implementations if/when available&quot;,&quot;  var out = [], p = 0;&quot;,&quot;  for (var i = 0; i &lt; str.length; i++) {&quot;,&quot;    var c = str.charCodeAt(i);&quot;,&quot;    if (c &lt; 128) {&quot;,&quot;      out[p++] = c;&quot;,&quot;    } else if (c &lt; 2048) {&quot;,&quot;      out[p++] = (c &gt;&gt; 6) | 192;&quot;,&quot;      out[p++] = (c &amp; 63) | 128;&quot;,&quot;    } else if (&quot;,&quot;        ((c &amp; 0xFC00) == 0xD800) &amp;&amp; (i + 1) &lt; str.length &amp;&amp;&quot;,&quot;        ((str.charCodeAt(i + 1) &amp; 0xFC00) == 0xDC00)) {&quot;,&quot;      // Surrogate Pair&quot;,&quot;      c = 0x10000 + ((c &amp; 0x03FF) &lt;&lt; 10) + (str.charCodeAt(++i) &amp; 0x03FF);&quot;,&quot;      out[p++] = (c &gt;&gt; 18) | 240;&quot;,&quot;      out[p++] = ((c &gt;&gt; 12) &amp; 63) | 128;&quot;,&quot;      out[p++] = ((c &gt;&gt; 6) &amp; 63) | 128;&quot;,&quot;      out[p++] = (c &amp; 63) | 128;&quot;,&quot;    } else {&quot;,&quot;      out[p++] = (c &gt;&gt; 12) | 224;&quot;,&quot;      out[p++] = ((c &gt;&gt; 6) &amp; 63) | 128;&quot;,&quot;      out[p++] = (c &amp; 63) | 128;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return out;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Converts a UTF-8 byte array to JavaScript&#39;s 16-bit Unicode.&quot;,&quot; * @param {Uint8Array|Array&lt;number&gt;} bytes UTF-8 byte array.&quot;,&quot; * @return {string} 16-bit Unicode string.&quot;,&quot; */&quot;,&quot;goog.crypt.utf8ByteArrayToString = function(bytes) {&quot;,&quot;  // TODO(user): Use native implementations if/when available&quot;,&quot;  var out = [], pos = 0, c = 0;&quot;,&quot;  while (pos &lt; bytes.length) {&quot;,&quot;    var c1 = bytes[pos++];&quot;,&quot;    if (c1 &lt; 128) {&quot;,&quot;      out[c++] = String.fromCharCode(c1);&quot;,&quot;    } else if (c1 &gt; 191 &amp;&amp; c1 &lt; 224) {&quot;,&quot;      var c2 = bytes[pos++];&quot;,&quot;      out[c++] = String.fromCharCode((c1 &amp; 31) &lt;&lt; 6 | c2 &amp; 63);&quot;,&quot;    } else if (c1 &gt; 239 &amp;&amp; c1 &lt; 365) {&quot;,&quot;      // Surrogate Pair&quot;,&quot;      var c2 = bytes[pos++];&quot;,&quot;      var c3 = bytes[pos++];&quot;,&quot;      var c4 = bytes[pos++];&quot;,&quot;      var u = ((c1 &amp; 7) &lt;&lt; 18 | (c2 &amp; 63) &lt;&lt; 12 | (c3 &amp; 63) &lt;&lt; 6 | c4 &amp; 63) -&quot;,&quot;          0x10000;&quot;,&quot;      out[c++] = String.fromCharCode(0xD800 + (u &gt;&gt; 10));&quot;,&quot;      out[c++] = String.fromCharCode(0xDC00 + (u &amp; 1023));&quot;,&quot;    } else {&quot;,&quot;      var c2 = bytes[pos++];&quot;,&quot;      var c3 = bytes[pos++];&quot;,&quot;      out[c++] =&quot;,&quot;          String.fromCharCode((c1 &amp; 15) &lt;&lt; 12 | (c2 &amp; 63) &lt;&lt; 6 | c3 &amp; 63);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return out.join(&#39;&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * XOR two byte arrays.&quot;,&quot; * @param {!Uint8Array|!Int8Array|!Array&lt;number&gt;} bytes1 Byte array 1.&quot;,&quot; * @param {!Uint8Array|!Int8Array|!Array&lt;number&gt;} bytes2 Byte array 2.&quot;,&quot; * @return {!Array&lt;number&gt;} Resulting XOR of the two byte arrays.&quot;,&quot; */&quot;,&quot;goog.crypt.xorByteArray = function(bytes1, bytes2) {&quot;,&quot;  goog.asserts.assert(&quot;,&quot;      bytes1.length == bytes2.length, &#39;XOR array lengths must match&#39;);&quot;,null,&quot;  var result = [];&quot;,&quot;  for (var i = 0; i &lt; bytes1.length; i++) {&quot;,&quot;    result.push(bytes1[i] ^ bytes2[i]);&quot;,&quot;  }&quot;,&quot;  return result;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../../../../../dossier.js" defer></script>