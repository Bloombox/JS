<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>orders.js</title><link href="../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;orders.js&quot;,&quot;src/shop/ordering/orders.js&quot;,[null,&quot;/*&quot;,&quot; * Copyright 2018, Bloombox, LLC. All rights reserved.&quot;,&quot; *&quot;,&quot; * Source and object computer code contained herein is the private intellectual&quot;,&quot; * property of Bloombox, a California Limited Liability Corporation. Use of this&quot;,&quot; * code in source form requires permission in writing before use or the&quot;,&quot; * assembly, distribution, or publishing of derivative works, for commercial&quot;,&quot; * purposes or any other purpose, from a duly authorized officer of Momentum&quot;,&quot; * Ideas Co.&quot;,&quot; *&quot;,&quot; * Unless required by applicable law or agreed to in writing, software&quot;,&quot; * distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,&quot;,&quot; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot; * See the License for the specific language governing permissions and&quot;,&quot; * limitations under the License.&quot;,&quot; */&quot;,null,&quot;/**&quot;,&quot; * Bloombox: Orders&quot;,&quot; *&quot;,&quot; * @fileoverview Provides the ability to submit orders for pickup and delivery.&quot;,&quot; */&quot;,null,&quot;/*global goog */&quot;,null,&quot;goog.provide(&#39;bloombox.shop.SchedulingType&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.shop.order.Order&#39;);&quot;,&quot;goog.provide(&#39;bloombox.shop.order.OrderException&#39;);&quot;,&quot;goog.provide(&#39;bloombox.shop.order.OrderScheduling&#39;);&quot;,&quot;goog.provide(&#39;bloombox.shop.order.Status&#39;);&quot;,&quot;goog.provide(&#39;bloombox.shop.order.Type&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.config.active&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.logging.error&#39;);&quot;,&quot;goog.require(&#39;bloombox.logging.log&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.product.Key&#39;);&quot;,&quot;goog.require(&#39;bloombox.product.Kind&#39;);&quot;,&quot;goog.require(&#39;bloombox.product.Weight&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.shop.Customer&#39;);&quot;,&quot;goog.require(&#39;bloombox.shop.CustomerName&#39;);&quot;,&quot;goog.require(&#39;bloombox.shop.Item&#39;);&quot;,&quot;goog.require(&#39;bloombox.shop.Routine&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.shop.order.DeliveryLocation&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.shop.rpc.ShopRPC&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.event&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.resolveSessionID&#39;);&quot;,null,&quot;goog.require(&#39;proto.bloombox.schema.services.shop.v1.GetOrder.Response&#39;);&quot;,&quot;goog.require(&#39;proto.bloombox.schema.services.shop.v1.OrderError&#39;);&quot;,&quot;goog.require(&#39;proto.bloombox.schema.services.shop.v1.SubmitOrder.Request&#39;);&quot;,&quot;goog.require(&#39;proto.bloombox.schema.services.shop.v1.SubmitOrder.Response&#39;);&quot;,null,&quot;goog.require(&#39;proto.opencannabis.commerce.Item&#39;);&quot;,&quot;goog.require(&#39;proto.opencannabis.commerce.Order&#39;);&quot;,&quot;goog.require(&#39;proto.opencannabis.commerce.OrderScheduling&#39;);&quot;,&quot;goog.require(&#39;proto.opencannabis.commerce.OrderStatus&#39;);&quot;,&quot;goog.require(&#39;proto.opencannabis.commerce.OrderType&#39;);&quot;,&quot;goog.require(&#39;proto.opencannabis.commerce.ProductVariant&#39;);&quot;,&quot;goog.require(&#39;proto.opencannabis.commerce.ProductWeight&#39;);&quot;,&quot;goog.require(&#39;proto.opencannabis.commerce.SchedulingType&#39;);&quot;,&quot;goog.require(&#39;proto.opencannabis.commerce.VariantSpec&#39;);&quot;,null,&quot;goog.require(&#39;proto.opencannabis.temporal.Instant&#39;);&quot;,null,null,&quot;// -- Structures -- //&quot;,&quot;/**&quot;,&quot; * Callback function for order submission.&quot;,&quot; *&quot;,&quot; * @typedef {function(?string, ?bloombox.shop.order.Order, ?number=)}&quot;,&quot; */&quot;,&quot;bloombox.shop.OrderCallback;&quot;,null,null,&quot;/**&quot;,&quot; * Callback function for order retrieval.&quot;,&quot; *&quot;,&quot; * @typedef {function(?proto.bloombox.schema.services.shop.v1.OrderError,&quot;,&quot; *                    ?bloombox.shop.order.Order,&quot;,&quot; *                    ?number=)}&quot;,&quot; */&quot;,&quot;bloombox.shop.OrderGetCallback;&quot;,null,null,&quot;/**&quot;,&quot; * Specifies types of orders.&quot;,&quot; *&quot;,&quot; * @enum {number}&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Type = {&quot;,&quot;  &#39;PICKUP&#39;: proto.opencannabis.commerce.OrderType.PICKUP,&quot;,&quot;  &#39;DELIVERY&#39;: proto.opencannabis.commerce.OrderType.DELIVERY&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Specifies statuses an order may be in.&quot;,&quot; *&quot;,&quot; * @enum {number}&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Status = {&quot;,&quot;  &#39;PENDING&#39;: proto.opencannabis.commerce.OrderStatus.PENDING,&quot;,&quot;  &#39;REJECTED&#39;: proto.opencannabis.commerce.OrderStatus.REJECTED,&quot;,&quot;  &#39;APPROVED&#39;: proto.opencannabis.commerce.OrderStatus.APPROVED,&quot;,&quot;  &#39;ASSIGNED&#39;: proto.opencannabis.commerce.OrderStatus.ASSIGNED,&quot;,&quot;  &#39;EN_ROUTE&#39;: proto.opencannabis.commerce.OrderStatus.EN_ROUTE,&quot;,&quot;  &#39;FULFILLED&#39;: proto.opencannabis.commerce.OrderStatus.FULFILLED&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Specifies types of order scheduling.&quot;,&quot; *&quot;,&quot; * @enum {number}&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.SchedulingType = {&quot;,&quot;  &#39;ASAP&#39;: proto.opencannabis.commerce.SchedulingType.ASAP,&quot;,&quot;  &#39;TIMED&#39;: proto.opencannabis.commerce.SchedulingType.TIMED&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Represents an exception that occurred while preparing or submitting&quot;,&quot; * an order.&quot;,&quot; *&quot;,&quot; * @param {string} message Exception error message.&quot;,&quot; * @constructor&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.OrderException = function OrderException(message) {&quot;,&quot;  this.message = message;&quot;,&quot;};&quot;,null,null,&quot;// -- Order Scheduling -- //&quot;,&quot;/**&quot;,&quot; * Specifies scheduling options for an order.&quot;,&quot; *&quot;,&quot; * @param {bloombox.shop.SchedulingType} scheduling Scheduling type to apply.&quot;,&quot; * @param {?number} desiredTime Desired time to set for delivery or pickup.&quot;,&quot; * @constructor&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.OrderScheduling = function OrderScheduling(scheduling,&quot;,&quot;                                                               desiredTime) {&quot;,&quot;  this.type = scheduling;&quot;,&quot;  this.desiredTime = desiredTime;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Export this order scheduling specification as a proto object suitable&quot;,&quot; * for use in an RPC.&quot;,&quot; *&quot;,&quot; * @return {proto.opencannabis.commerce.OrderScheduling} Proto order scheduling&quot;,&quot; *         spec.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.shop.order.OrderScheduling.prototype.export = function() {&quot;,&quot;  let protob = new proto.opencannabis.commerce.OrderScheduling();&quot;,&quot;  protob.setScheduling(&quot;,&quot;    /** @type {proto.opencannabis.commerce.SchedulingType&lt;number&gt;} */ (&quot;,&quot;      this.type));&quot;,null,&quot;  // set desired time, if applicable&quot;,&quot;  if (this.desiredTime !== null) {&quot;,&quot;    let desiredTime = new proto.opencannabis.temporal.Instant();&quot;,&quot;    desiredTime.setTimestamp(this.desiredTime);&quot;,&quot;    protob.setDesiredTime(desiredTime);&quot;,&quot;  }&quot;,&quot;  return protob;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Retrieve the scheduling type for this scheduling spec.&quot;,&quot; * @return {bloombox.shop.SchedulingType} Scheduling type.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.OrderScheduling.prototype.getType = function() {&quot;,&quot;  return this.type;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Retrieve the desired delivery or pickup target time.&quot;,&quot; * @return {?number} Target time, or `null` if not applicable.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.OrderScheduling.prototype.getDesiredTime = function() {&quot;,&quot;  return this.desiredTime;&quot;,&quot;};&quot;,null,null,&quot;// -- Order -- //&quot;,&quot;/**&quot;,&quot; * Specifies an order that can be submitted for pickup or delivery.&quot;,&quot; *&quot;,&quot; * @param {bloombox.shop.order.Type} orderType Type of order to build.&quot;,&quot; * @param {bloombox.shop.Customer} customer Customer submitting the order.&quot;,&quot; * @param {?bloombox.shop.order.DeliveryLocation} location Delivery location.&quot;,&quot; * @param {string=} notes Order notes or special instructions.&quot;,&quot; * @throws {bloombox.shop.order.OrderException} If params provided are invalid.&quot;,&quot; * @constructor&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order = function Order(orderType,&quot;,&quot;                                           customer,&quot;,&quot;                                           location,&quot;,&quot;                                           notes) {&quot;,&quot;  // check order type&quot;,&quot;  if (!(orderType === bloombox.shop.order.Type.PICKUP ||&quot;,&quot;        orderType === bloombox.shop.order.Type.DELIVERY))&quot;,&quot;    throw new bloombox.shop.order.OrderException(&quot;,&quot;      &#39;Invalid order type provided. Must be DELIVERY or PICKUP.&#39;);&quot;,null,&quot;  // check customer&quot;,&quot;  if (!(typeof customer === &#39;object&#39; &amp;&amp; (&quot;,&quot;      typeof customer.export === &#39;function&#39;)))&quot;,&quot;    throw new bloombox.shop.order.OrderException(&quot;,&quot;      &#39;Invalid customer provided for order.&#39;);&quot;,null,&quot;  // check location&quot;,&quot;  if (orderType === bloombox.shop.order.Type.DELIVERY &amp;&amp;&quot;,&quot;      (location === null || !(typeof location === &#39;object&#39;) || !location))&quot;,&quot;    // we need a location - it&#39;s type `DELIVERY` - but we didn&#39;t get one&quot;,&quot;    throw new bloombox.shop.order.OrderException(&quot;,&quot;      &#39;Order type was DELIVERY, but no destination info was provided.&#39;);&quot;,null,&quot;  // okay everything is valid&quot;,&quot;  /**&quot;,&quot;   * Order ID, which defaults to `null` until the order has been submitted to&quot;,&quot;   * the shop service, and a resulting ID is assigned and sent back.&quot;,&quot;   *&quot;,&quot;   * @type {?string}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.id = null;&quot;,null,&quot;  /**&quot;,&quot;   * Type of the order, either DELIVERY or PICKUP.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.shop.order.Type}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.type = orderType;&quot;,null,&quot;  /**&quot;,&quot;   * Status for this order.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.shop.order.Status}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.status = bloombox.shop.order.Status[&#39;PENDING&#39;];&quot;,null,&quot;  /**&quot;,&quot;   * Customer who submitted the order.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.shop.Customer}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.customer = customer;&quot;,null,&quot;  /**&quot;,&quot;   * Constituent items that are being ordered as part of this order.&quot;,&quot;   *&quot;,&quot;   * @type {Array&lt;bloombox.shop.Item&gt;}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.items = [];&quot;,null,&quot;  /**&quot;,&quot;   * Location to deliver this order to, if it is a delivery order.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.shop.order.DeliveryLocation}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.location = location;&quot;,null,&quot;  /**&quot;,&quot;   * Arbitrary notes attached to this order, if any.&quot;,&quot;   *&quot;,&quot;   * @type {?string}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.notes = notes || null;&quot;,null,&quot;  /**&quot;,&quot;   * Scheduling type for this order. Either ASAP or a scheduled time.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.shop.order.OrderScheduling}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.scheduling = new bloombox.shop.order.OrderScheduling(&quot;,&quot;    bloombox.shop.SchedulingType.ASAP, null);&quot;,null,&quot;  /**&quot;,&quot;   * When this order was created.&quot;,&quot;   *&quot;,&quot;   * @type {{timestamp: number}}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.createdAt = {&#39;timestamp&#39;: +(new Date())};&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Set the ID for an order, once it has been submitted to the server.&quot;,&quot; *&quot;,&quot; * @param {string} id Order ID.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.setId = function(id) {&quot;,&quot;  this.id = id;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the ID/key for this order.&quot;,&quot; *&quot;,&quot; * @return {?string}&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.getId = function() {&quot;,&quot;  return this.id;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Set the status of this order, after retrieving it/updating status from the&quot;,&quot; * server.&quot;,&quot; *&quot;,&quot; * @param {bloombox.shop.order.Status} status Order status.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.setStatus = function(status) {&quot;,&quot;  this.status = status;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Current status of this order.&quot;,&quot; *&quot;,&quot; * @return {bloombox.shop.order.Status}&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.getStatus = function() {&quot;,&quot;  return this.status;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Set the created-at time for this order.&quot;,&quot; *&quot;,&quot; * @param {number} ts Timestamp to set this order&#39;s creation time to.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.setCreatedAt = function(ts) {&quot;,&quot;  this.createdAt = {&#39;timestamp&#39;: ts};&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the creation timestamp for this order. Available whether or not the order&quot;,&quot; * has been sent to the server. May differ after saving the order depending on&quot;,&quot; * latency and other factors.&quot;,&quot; *&quot;,&quot; * @return {number} Order creation timestamp, at millisecond resolution.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.getCreatedAt = function() {&quot;,&quot;  return this.createdAt[&#39;timestamp&#39;];&quot;,&quot;};&quot;,null,null,&quot;// noinspection JSUnusedGlobalSymbols&quot;,&quot;/**&quot;,&quot; * Set an order to ASAP-style scheduling.&quot;,&quot; *&quot;,&quot; * @return {bloombox.shop.order.Order} Subject order, for chainability.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.setSchedulingTypeASAP = function() {&quot;,&quot;  this.scheduling = new bloombox.shop.order.OrderScheduling(&quot;,&quot;    bloombox.shop.SchedulingType.ASAP, null);&quot;,&quot;  return this;&quot;,&quot;};&quot;,null,null,&quot;// noinspection JSUnusedGlobalSymbols&quot;,&quot;/**&quot;,&quot; * Set an order to a specific target delivery time.&quot;,&quot; *&quot;,&quot; * @param {number} ts Timestamp for delivery target.&quot;,&quot; * @return {bloombox.shop.order.Order} Subject order, for chainability.&quot;,&quot; * @throws {bloombox.shop.order.OrderException} If the provided timestamp is not&quot;,&quot; *         valid.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.setSchedulingTypeTimed = function(ts) {&quot;,&quot;  // check timestamp&quot;,&quot;  if (!((typeof ts === &#39;number&#39;) &amp;&amp; (ts &gt; 100)))&quot;,&quot;    throw new bloombox.shop.order.OrderException(&quot;,&quot;      &#39;Invalid timestamp provided for setSchedulingTypeTimed.&#39;);&quot;,null,&quot;  this.scheduling = new bloombox.shop.order.OrderScheduling(&quot;,&quot;    bloombox.shop.SchedulingType.TIMED, ts);&quot;,&quot;  return this;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Retrieve the scheduling spec for this order, specifying if it is desired ASAP&quot;,&quot; * or at a specified time. The default case is ASAP for both PICKUP and DELIVERY&quot;,&quot; * orders.&quot;,&quot; *&quot;,&quot; * @return {bloombox.shop.order.OrderScheduling}&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.getScheduling = function() {&quot;,&quot;  return this.scheduling;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Set the type of order.&quot;,&quot; *&quot;,&quot; * @param {bloombox.shop.order.Type} type Type to set the order to.&quot;,&quot; * @return {bloombox.shop.order.Order} Subject order, for chain-ability.&quot;,&quot; * @throws {bloombox.shop.order.OrderException} If the provided type isn&#39;t valid&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.setType = function(type) {&quot;,&quot;  // check validity&quot;,&quot;  if (type !== bloombox.shop.order.Type.PICKUP &amp;&amp; (&quot;,&quot;      type !== bloombox.shop.order.Type.DELIVERY))&quot;,&quot;    throw new bloombox.shop.order.OrderException(&quot;,&quot;      &#39;Invalid order type provided to Order.setType. &#39; +&quot;,&quot;        &#39;Must be one of `bloombox.shop.order.Type.DELIVERY` &#39; +&quot;,&quot;        &#39;or `bloombox.shop.order.Type.PICKUP`.&#39;);&quot;,null,&quot;  this.type = type;&quot;,&quot;  return this;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the type of order this is, either PICKUP or DELIVERY.&quot;,&quot; *&quot;,&quot; * @return {bloombox.shop.order.Type} Order type.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.getType = function() {&quot;,&quot;  return this.type;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Set the notes for the order.&quot;,&quot; *&quot;,&quot; * @param {?string} notes Notes for the order, or `null` to unset notes.&quot;,&quot; * @return {bloombox.shop.order.Order} Subject order, for chain-ability.&quot;,&quot; * @throws {bloombox.shop.order.OrderException} If the provided type isn&#39;t valid&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.setNotes = function(notes) {&quot;,&quot;  // check validity&quot;,&quot;  if (notes === null) {&quot;,&quot;    // we&#39;re clearing notes&quot;,&quot;    this.notes = null;&quot;,&quot;  } else if (typeof notes === &#39;string&#39; &amp;&amp; notes.length &gt; 0) {&quot;,&quot;    // it&#39;s notes&quot;,&quot;    this.notes = notes;&quot;,&quot;  } else {&quot;,&quot;    // it&#39;s an invalid type&quot;,&quot;    throw new bloombox.shop.order.OrderException(&quot;,&quot;      &#39;Notes for order aren\\&#39;t valid: \\&#39;&#39; + notes + &#39;\\&#39;.&#39;);&quot;,&quot;  }&quot;,&quot;  return this;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the notes for the order.&quot;,&quot; * @return {?string} Order notes, or `null` if no notes were specified.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.getNotes = function() {&quot;,&quot;  return this.notes;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Set the location for a delivery order.&quot;,&quot; *&quot;,&quot; * @param {?bloombox.shop.order.DeliveryLocation} location Location to set.&quot;,&quot; * @return {bloombox.shop.order.Order} Subject order, for chain-ability.&quot;,&quot; * @throws {bloombox.shop.order.OrderException} If the provided location isn&#39;t&quot;,&quot; *         valid in some way.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.setLocation = function(location) {&quot;,&quot;  // check validity&quot;,&quot;  if (location !== null &amp;&amp; (!(typeof location === &#39;object&#39;) ||&quot;,&quot;        !(typeof location.export === &#39;function&#39;)))&quot;,&quot;    throw new bloombox.shop.order.OrderException(&quot;,&quot;      &#39;Invalid delivery destination provided to Order.setLocation.&#39;);&quot;,null,&quot;  this.location = location;&quot;,&quot;  return this;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Return the delivery location information attached to this order, if any.&quot;,&quot; *&quot;,&quot; * @return {?bloombox.shop.order.DeliveryLocation} Delivery location info, or&quot;,&quot; *         `null` if none is attached to the order.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.getLocation = function() {&quot;,&quot;  return this.location || null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Set the customer for this order.&quot;,&quot; *&quot;,&quot; * @param {bloombox.shop.Customer} customer Customer to set.&quot;,&quot; * @return {bloombox.shop.order.Order} Subject order, for chain-ability.&quot;,&quot; * @throws {bloombox.shop.order.OrderException} If the provided customer is not&quot;,&quot; *         valid in some way.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.setCustomer = function(customer) {&quot;,&quot;  // check validity&quot;,&quot;  if (customer !== null &amp;&amp; (!(typeof customer === &#39;object&#39;) ||&quot;,&quot;        !(typeof customer.export === &#39;function&#39;)))&quot;,&quot;    throw new bloombox.shop.order.OrderException(&quot;,&quot;      &#39;Invalid customer provided to Order.setCustomer.&#39;);&quot;,null,&quot;  this.customer = customer;&quot;,&quot;  return this;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Get the customer for this order.&quot;,&quot; * @return {bloombox.shop.Customer} Order customer.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.getCustomer = function() {&quot;,&quot;  return this.customer;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Add an item to this order.&quot;,&quot; *&quot;,&quot; * @param {bloombox.shop.Item} item Item to add to the order.&quot;,&quot; * @return {bloombox.shop.order.Order} Subject order, for chain-ability.&quot;,&quot; * @throws {bloombox.shop.order.OrderException} If the provided item is not&quot;,&quot; *         valid in some way.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.addItem = function(item) {&quot;,&quot;  // check validity&quot;,&quot;  if (item !== null &amp;&amp; (!(typeof item === &#39;object&#39;) ||&quot;,&quot;        !(typeof item.export === &#39;function&#39;)))&quot;,&quot;    throw new bloombox.shop.order.OrderException(&quot;,&quot;      &#39;Invalid item provided to Order.addItem&#39;);&quot;,null,&quot;  this.items.push(item);&quot;,&quot;  return this;&quot;,&quot;};&quot;,null,null,&quot;// noinspection JSUnusedGlobalSymbols&quot;,&quot;/**&quot;,&quot; * Retrieve the items on this order.&quot;,&quot; *&quot;,&quot; * @return {Array&lt;bloombox.shop.Item&gt;} Items that are part of this order.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.getItems = function() {&quot;,&quot;  return this.items;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Inflate a wire order type into a JS SDK order type.&quot;,&quot; *&quot;,&quot; * @param {proto.opencannabis.commerce.OrderType|string|number} type Proto type&quot;,&quot; *        from an order to inflate into a JS SDK order type.&quot;,&quot; * @return {bloombox.shop.order.Type} Inflated order type.&quot;,&quot; * @throws {bloombox.shop.order.OrderException} If the type provided is not&quot;,&quot; *         valid or cannot be identified.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.inflateType = function(type) {&quot;,&quot;  if (type === null || type === undefined)&quot;,&quot;    return bloombox.shop.order.Type.PICKUP;&quot;,&quot;  switch (type) {&quot;,&quot;    case &#39;PICKUP&#39;: return bloombox.shop.order.Type.PICKUP;&quot;,&quot;    case &#39;DELIVERY&#39;: return bloombox.shop.order.Type.DELIVERY;&quot;,&quot;    case 0: return bloombox.shop.order.Type.PICKUP;&quot;,&quot;    case 1: return bloombox.shop.order.Type.DELIVERY;&quot;,&quot;  }&quot;,&quot;  bloombox.logging.warn(&#39;Unable to resolve order type with value \&quot;&#39; +&quot;,&quot;    type + &#39;\&quot;.&#39;);&quot;,&quot;  return bloombox.shop.order.Type.PICKUP;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Inflate a wire order status into a JS SDK order status.&quot;,&quot; *&quot;,&quot; * @param {proto.opencannabis.commerce.OrderStatus|string|number} status Proto&quot;,&quot; *        status from an order to inflate into a JS SDK order status.&quot;,&quot; * @return {bloombox.shop.order.Status} Inflated order status.&quot;,&quot; * @throws {bloombox.shop.order.OrderException} If the status provided is not&quot;,&quot; *         valid or cannot be identified.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.inflateStatus = function(status) {&quot;,&quot;  if (status === null || status === undefined)&quot;,&quot;    throw new bloombox.shop.order.OrderException(&quot;,&quot;      &#39;Invalid underlying order status value: \&quot;&#39; + status + &#39;\&quot;.&#39;);&quot;,&quot;  switch (status) {&quot;,&quot;    case &#39;PENDING&#39;: return bloombox.shop.order.Status.PENDING;&quot;,&quot;    case &#39;APPROVED&#39;: return bloombox.shop.order.Status.APPROVED;&quot;,&quot;    case &#39;REJECTED&#39;: return bloombox.shop.order.Status.REJECTED;&quot;,&quot;    case &#39;ASSIGNED&#39;: return bloombox.shop.order.Status.ASSIGNED;&quot;,&quot;    case &#39;EN_ROUTE&#39;: return bloombox.shop.order.Status.EN_ROUTE;&quot;,&quot;    case &#39;FULFILLED&#39;: return bloombox.shop.order.Status.FULFILLED;&quot;,&quot;    case 0: return bloombox.shop.order.Status.PENDING;&quot;,&quot;    case 1: return bloombox.shop.order.Status.APPROVED;&quot;,&quot;    case 2: return bloombox.shop.order.Status.REJECTED;&quot;,&quot;    case 3: return bloombox.shop.order.Status.ASSIGNED;&quot;,&quot;    case 4: return bloombox.shop.order.Status.EN_ROUTE;&quot;,&quot;    case 5: return bloombox.shop.order.Status.FULFILLED;&quot;,&quot;  }&quot;,&quot;  bloombox.logging.warn(&#39;Unable to resolve order status with value \&quot;&#39; +&quot;,&quot;    status + &#39;\&quot;. Defaulting to \&quot;PENDING\&quot;.&#39;);&quot;,&quot;  return bloombox.shop.order.Status.PENDING;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Inflate order scheduling information from a raw data object.&quot;,&quot; *&quot;,&quot; * @param {?Object} data Raw data object from an order response.&quot;,&quot; * @return {proto.opencannabis.commerce.OrderScheduling} Order scheduling spec&quot;,&quot; *         object.&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.inflateScheduling = function(data) {&quot;,&quot;  let scheduling = new proto.opencannabis.commerce.OrderScheduling();&quot;,&quot;  if (typeof data === &#39;object&#39;) {&quot;,&quot;    let type = proto.opencannabis.commerce.SchedulingType.ASAP;&quot;,null,&quot;    // decode scheduling type, which should default to &#39;ASAP&#39;&quot;,&quot;    if (data.hasOwnProperty(&#39;scheduling&#39;) &amp;&amp;&quot;,&quot;       (typeof data[&#39;scheduling&#39;] === &#39;object&#39;) &amp;&amp;&quot;,&quot;       ((typeof data[&#39;scheduling&#39;][&#39;scheduling&#39;] === &#39;string&#39;) ||&quot;,&quot;        (typeof data[&#39;scheduling&#39;][&#39;scheduling&#39;] === &#39;number&#39;))) {&quot;,&quot;      switch (data[&#39;scheduling&#39;][&#39;scheduling&#39;].toUpperCase()) {&quot;,&quot;        case &#39;ASAP&#39;:&quot;,&quot;          type = proto.opencannabis.commerce.SchedulingType.ASAP;&quot;,&quot;          break;&quot;,&quot;        case 0:&quot;,&quot;          type = proto.opencannabis.commerce.SchedulingType.ASAP;&quot;,&quot;          break;&quot;,&quot;        case &#39;TIMED&#39;:&quot;,&quot;          type = proto.opencannabis.commerce.SchedulingType.TIMED;&quot;,&quot;          break;&quot;,&quot;        case 1:&quot;,&quot;          type = proto.opencannabis.commerce.SchedulingType.TIMED;&quot;,&quot;          break;&quot;,&quot;        default:&quot;,&quot;          type = proto.opencannabis.commerce.SchedulingType.ASAP;&quot;,&quot;          break;&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    scheduling.setScheduling(type);&quot;,null,&quot;    // decode scheduled time, if available&quot;,&quot;    let desiredTime = /** @type {?number} */ (null);&quot;,&quot;    if (data.hasOwnProperty(&#39;desiredTime&#39;) &amp;&amp;&quot;,&quot;       (typeof data[&#39;desiredTime&#39;] === &#39;object&#39;)) {&quot;,&quot;      // handle ISO8601&quot;,&quot;      if (typeof data[&#39;desiredTime&#39;][&#39;iso8601&#39;] === &#39;string&#39;) {&quot;,&quot;        desiredTime = +(new Date(data[&#39;desiredTime&#39;][&#39;iso8601&#39;]));&quot;,&quot;      } else if (typeof data[&#39;desiredTime&#39;][&#39;timestamp&#39;] === &#39;number&#39;) {&quot;,&quot;        desiredTime = data[&#39;desiredTime&#39;][&#39;timestamp&#39;];&quot;,&quot;      } else {&quot;,&quot;        bloombox.logging.warn(&#39;Unable to decode desired order time.&#39;, data);&quot;,&quot;      }&quot;,&quot;      let timestamp = new proto.opencannabis.temporal.Instant();&quot;,&quot;      timestamp.setTimestamp(desiredTime);&quot;,&quot;      scheduling.setDesiredTime(timestamp);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return scheduling;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Inflate a shop order from its underlying proto object.&quot;,&quot; *&quot;,&quot; * @param {proto.opencannabis.commerce.Order} protob Commercial order object.&quot;,&quot; * @param {bloombox.shop.Customer} customer Customer object for the order.&quot;,&quot; * @param {?bloombox.shop.order.DeliveryLocation} location Delivery destination&quot;,&quot; *        spec object, if applicable.&quot;,&quot; * @param {Array&lt;Object&gt;} items Array of raw items to be attached to the order.&quot;,&quot; * @return {bloombox.shop.order.Order} Inflated SDK order object.&quot;,&quot; * @throws {bloombox.shop.order.OrderException} If required information is not&quot;,&quot; *         provided by the underlying runtime.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.fromProto = function(protob,&quot;,&quot;                                               customer,&quot;,&quot;                                               location,&quot;,&quot;                                               items) {&quot;,&quot;  let targetId = protob.getId();&quot;,&quot;  let underlyingOrderType = protob.getType();&quot;,&quot;  let underlyingStatus = protob.getStatus();&quot;,&quot;  let notes = protob.getNotes();&quot;,null,&quot;  let status = bloombox.shop.order.Order.inflateStatus(underlyingStatus);&quot;,&quot;  let type = bloombox.shop.order.Order.inflateType(underlyingOrderType);&quot;,&quot;  try {&quot;,&quot;    let order = new bloombox.shop.order.Order(&quot;,&quot;      type, customer, location, notes);&quot;,&quot;    order.setId(targetId);&quot;,&quot;    order.setStatus(status);&quot;,&quot;    order.setCreatedAt(protob.getCreatedAt().getTimestamp());&quot;,null,&quot;    if (Array.isArray(items) &amp;&amp; items.length &gt; 0) {&quot;,&quot;      // process items from order&quot;,&quot;      for (let orderI = 0; orderI &lt; items.length; orderI++) {&quot;,&quot;        // for each order, attempt to inflate. if we can inflate it, add it to&quot;,&quot;        // the order we are decoding and either way continue on.&quot;,&quot;        let inflatedItem = bloombox.shop.Item.fromResponse(items[orderI]);&quot;,&quot;        if (inflatedItem !== null) {&quot;,&quot;          // we have an inflated item&quot;,&quot;          order.addItem(inflatedItem);&quot;,&quot;        } else {&quot;,&quot;          // failed to inflate the item&quot;,&quot;          bloombox.logging.warn(&#39;Unable to decode order item. Skipping.&#39;, {&quot;,&quot;            &#39;index&#39;: orderI,&quot;,&quot;            &#39;id&#39;: protob.getId()&quot;,&quot;          });&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    return order;&quot;,&quot;  } catch (e) {&quot;,&quot;    bloombox.logging.error(&#39;Failed to construct fetched Order object.&#39;, {&quot;,&quot;      &#39;error&#39;: e,&quot;,&quot;      &#39;orderId&#39;: targetId,&quot;,&quot;      &#39;status&#39;: status&quot;,&quot;    });&quot;,&quot;    throw e;  // rethrow&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Retrieve a copy of this order from the server, and update the properties on&quot;,&quot; * it accordingly.&quot;,&quot; *&quot;,&quot; * @param {bloombox.shop.OrderGetCallback} callback Callback to dispatch once&quot;,&quot; *        the order update has completed.&quot;,&quot; * @throws {bloombox.shop.order.OrderException} If no order ID is specified on&quot;,&quot; *        the current order, indicating it has not successfully been submitted&quot;,&quot; *        to the shop service yet.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.update = function(callback) {&quot;,&quot;  // check for a valid order ID&quot;,&quot;  if (this.id === null)&quot;,&quot;    throw new bloombox.shop.order.OrderException(&quot;,&quot;      &#39;Cannot update order with no ID.&#39;);&quot;,null,&quot;  let subject = this;&quot;,null,&quot;  bloombox.shop.order.Order.retrieve(this.id, function(err, order) {&quot;,&quot;    if (err !== null || order === null) {&quot;,&quot;      // could not retrieve order update&quot;,&quot;      if (err !== null) {&quot;,&quot;        // an error occurred&quot;,&quot;        bloombox.logging.error(&quot;,&quot;          &#39;Failed to retrieve updated order from server. Got error: \&quot;&#39; +&quot;,&quot;          err.toString() + &#39;, for order ID \&quot;&#39; + subject.id + &#39;\&quot;.&#39;, {&quot;,&quot;            &#39;error&#39;: err,&quot;,&quot;            &#39;order&#39;: order&quot;,&quot;          });&quot;,&quot;        callback(err, null);&quot;,&quot;      } else {&quot;,&quot;        // got no error and no order&quot;,&quot;        bloombox.logging.error(&quot;,&quot;          &#39;Failed to retrieve updated order from server. Additionally &#39; +&quot;,&quot;          &#39;got no error. Order ID \&quot;&#39; + subject.id + &#39;\&quot;.&#39;, {&quot;,&quot;            &#39;error&#39;: err,&quot;,&quot;            &#39;order&#39;: order,&quot;,&quot;            &#39;subject&#39;: subject&quot;,&quot;          });&quot;,&quot;        callback(null, null);&quot;,&quot;      }&quot;,&quot;    } else {&quot;,&quot;      // update the order from the response&quot;,&quot;      if (order.getStatus())&quot;,&quot;        subject.setStatus(&quot;,&quot;          bloombox.shop.order.Order.inflateStatus(order.getStatus()));&quot;,null,&quot;      // dispatch callback, we&#39;re done&quot;,&quot;      callback(null, subject);&quot;,&quot;    }&quot;,&quot;  });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Send analytics data after an order has been submitted.&quot;,&quot; *&quot;,&quot; * @param {?string} orderId Resulting ID of the order, if submission to the shop&quot;,&quot; *        service was completed successfully.&quot;,&quot; * @param {proto.bloombox.schema.services.shop.v1.OrderError=} opt_error Error&quot;,&quot; *        that was encountered when submitting the order, if any.&quot;,&quot; * @param {number=} opt_status Status that the RPC method got back from the&quot;,&quot; *        server, if submission was not successful.&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.sendAnalytics = function(orderId,&quot;,&quot;                                                             opt_error,&quot;,&quot;                                                             opt_status) {&quot;,&quot;  let totalItems = 0;&quot;,&quot;  let itemKeys = /** @type {Object} */ ({});&quot;,&quot;  let itemsBySection = /** @type {Object} */ ({});&quot;,&quot;  let uniqueItemKeys = [];&quot;,&quot;  let uniqueSections = [];&quot;,&quot;  this.items.map((function(item) {&quot;,&quot;    let itemId = item.key.getId();&quot;,null,&quot;    // update total count&quot;,&quot;    totalItems += item.count;&quot;,null,&quot;    // update unique item keys and item counts&quot;,&quot;    if (!itemKeys[itemId]) {&quot;,&quot;      itemKeys[itemId] = item.count;&quot;,&quot;      uniqueItemKeys.push(itemId);&quot;,&quot;    } else {&quot;,&quot;      itemKeys[itemId] += item.count;&quot;,&quot;    }&quot;,null,&quot;    // update unique sections and section counts&quot;,&quot;    let section = item.key.getKind();&quot;,&quot;    if (!itemsBySection[section]) {&quot;,&quot;      itemsBySection[section] = item.count;&quot;,&quot;      uniqueSections.push(section);&quot;,&quot;    } else {&quot;,&quot;      itemsBySection[section] += item.count;&quot;,&quot;    }&quot;,&quot;  }));&quot;,null,&quot;  // @TODO: actual order telemetry event instead of a generic one&quot;,&quot;  bloombox.telemetry.event(&quot;,&quot;    bloombox.telemetry.InternalCollection.ORDERS,&quot;,&quot;    {&#39;action&#39;: opt_error ? &#39;error&#39; : &#39;order&#39;,&quot;,&quot;     &#39;status&#39;: opt_status ? opt_status : 200,&quot;,&quot;     &#39;sid&#39;: bloombox.telemetry.resolveSessionID(),&quot;,&quot;     &#39;order&#39;: {&quot;,&quot;      &#39;id&#39;: orderId,&quot;,&quot;      &#39;type&#39;: this.type,&quot;,&quot;      &#39;items&#39;: uniqueItemKeys,&quot;,&quot;      &#39;sections&#39;: uniqueSections,&quot;,&quot;      &#39;stats&#39;: {&quot;,&quot;        &#39;countByKey&#39;: itemKeys,&quot;,&quot;        &#39;countBySection&#39;: itemsBySection,&quot;,&quot;        &#39;hasOrderNotes&#39;: (&quot;,&quot;          typeof this.getNotes() === &#39;string&#39; &amp;&amp; this.getNotes().length &gt; 0),&quot;,&quot;        &#39;uniqueItemCount&#39;: this.items.length,&quot;,&quot;        &#39;totalItemCount&#39;: totalItems || 1&quot;,&quot;      }}}).send();&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Retrieve an order by its key, which is returned after submission of an order&quot;,&quot; * to the shop service.&quot;,&quot; *&quot;,&quot; * @param {string} key Key for the desired order.&quot;,&quot; * @param {bloombox.shop.OrderGetCallback} callback Callback to dispatch with&quot;,&quot; *        the resulting order.&quot;,&quot; * @throws {bloombox.shop.order.OrderException} If no order ID is specified on&quot;,&quot; *        the current order, indicating it has not successfully been submitted&quot;,&quot; *        to the shop service yet.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.retrieve = function(key, callback) {&quot;,&quot;  // check for a valid order ID&quot;,&quot;  if (key === null || key.length === 0)&quot;,&quot;    throw new bloombox.shop.order.OrderException(&quot;,&quot;      &#39;Cannot retrieve an order with no ID.&#39;);&quot;,null,&quot;  let done = false;&quot;,null,&quot;  let config = bloombox.config.active();&quot;,&quot;  let partner = config.partner;&quot;,&quot;  let location = config.location;&quot;,null,&quot;  if (!partner || !location) {&quot;,&quot;    bloombox.logging.error(&#39;Partner or location code is not defined.&#39;);&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  // make the RPC to retrieve it&quot;,&quot;  new bloombox.shop.rpc.ShopRPC(&quot;,&quot;    /** @type {bloombox.shop.Routine} */ (&quot;,&quot;      bloombox.shop.Routine.GET_ORDER), &#39;GET&#39;, [&quot;,&quot;      &#39;partners&#39;,&quot;,&quot;      partner,&quot;,&quot;      &#39;locations&#39;,&quot;,&quot;      location,&quot;,&quot;      &#39;orders&#39;,&quot;,&quot;      key&quot;,&quot;    ].join(&#39;/&#39;))&quot;,&quot;    .send((function(response) {&quot;,&quot;      if (done) return;&quot;,&quot;      if (response !== null) {&quot;,&quot;        done = true;&quot;,null,&quot;        bloombox.logging.log(&quot;,&quot;          &#39;Response received for order fetch RPC.&#39;, response);&quot;,null,&quot;        // decode the response&quot;,&quot;        let inflated = (&quot;,&quot;          new proto.bloombox.schema.services.shop.v1.GetOrder.Response());&quot;,&quot;        if (response[&#39;success&#39;] === true || response[&#39;order&#39;]) {&quot;,&quot;          // extract and decode order&quot;,&quot;          inflated.setSuccess(true);&quot;,null,&quot;          let rawOrder = /** @type {Object|null|undefined} */ (&quot;,&quot;            response[&#39;order&#39;]);&quot;,&quot;          if (rawOrder !== null &amp;&amp; rawOrder !== undefined &amp;&amp;&quot;,&quot;              typeof rawOrder === &#39;object&#39;) {&quot;,&quot;            // inflate the order and call back&quot;,&quot;            let orderId = /** @type {string} */ (rawOrder[&#39;id&#39;]);&quot;,&quot;            let orderType = /** @type {string} */ (rawOrder[&#39;type&#39;]);&quot;,&quot;            let orderStatus = /** @type {string} */ (rawOrder[&#39;status&#39;]);&quot;,&quot;            let orderNotes = /** @type {string|null|undefined} */ (&quot;,&quot;              rawOrder[&#39;notes&#39;]);&quot;,&quot;            let orderScheduling = /** @type {Object} */ (&quot;,&quot;              rawOrder[&#39;scheduling&#39;]);&quot;,&quot;            let orderCreatedAt = /** @type {Object} */ (&quot;,&quot;              rawOrder[&#39;createdAt&#39;]);&quot;,&quot;            let orderItems = /** @type {Array&lt;Object&gt;} */ (rawOrder[&#39;item&#39;]);&quot;,null,&quot;            // if any of those properties look wrong, it&#39;s an error&quot;,&quot;            if (!orderId ||&quot;,&quot;                  !(typeof orderId === &#39;string&#39;) ||&quot;,&quot;                  orderId.length &lt; 1) {&quot;,&quot;              // order details are invalid&quot;,&quot;              bloombox.logging.error(&quot;,&quot;                &#39;Failed to decode required order details after order &#39; +&quot;,&quot;                &#39;retrieval RPC.&#39;, {&quot;,&quot;                  &#39;orderId&#39;: orderId,&quot;,&quot;                  &#39;orderType&#39;: orderType&quot;,&quot;                });&quot;,&quot;            } else {&quot;,&quot;              // resolve order type and status&quot;,&quot;              let objOrderType = (&quot;,&quot;                bloombox.shop.order.Order.inflateType(orderType));&quot;,&quot;              let objOrderStatus = (&quot;,&quot;                bloombox.shop.order.Order.inflateStatus(&quot;,&quot;                  orderStatus || 0));&quot;,&quot;              let objOrderScheduling = (&quot;,&quot;                bloombox.shop.order.Order.inflateScheduling(orderScheduling));&quot;,null,&quot;              let customerObj = bloombox.shop.Customer.fromResponse(rawOrder);&quot;,&quot;              let locationObj = (&quot;,&quot;                bloombox.shop.order.DeliveryLocation.fromResponse(rawOrder));&quot;,null,&quot;              let instant = new proto.opencannabis.temporal.Instant();&quot;,null,&quot;              if (orderCreatedAt) {&quot;,&quot;                if (typeof orderCreatedAt === &#39;object&#39;) {&quot;,&quot;                  if (typeof orderCreatedAt[&#39;iso8601&#39;] === &#39;string&#39;) {&quot;,&quot;                    // it&#39;s an ISO8601 string&quot;,&quot;                    let orderTimestamp = +(new Date(orderCreatedAt[&#39;iso8601&#39;]));&quot;,&quot;                    instant.setTimestamp(orderTimestamp);&quot;,&quot;                  } else if (typeof orderCreatedAt[&#39;timestamp&#39;] === &#39;number&#39;) {&quot;,&quot;                    let orderTimestamp = orderCreatedAt[&#39;timestamp&#39;];&quot;,&quot;                    instant.setTimestamp(orderTimestamp);&quot;,&quot;                  } else {&quot;,&quot;                    bloombox.logging.warn(&quot;,&quot;                      &#39;Unable to type-identify order createdAt.&#39;,&quot;,&quot;                      {&#39;data&#39;: orderCreatedAt});&quot;,&quot;                  }&quot;,&quot;                } else {&quot;,&quot;                  bloombox.logging.warn(&quot;,&quot;                    &#39;Unable to decode order createdAt.&#39;,&quot;,&quot;                    {&#39;data&#39;: orderCreatedAt});&quot;,&quot;                }&quot;,&quot;              }&quot;,null,&quot;              // build inflated order object&quot;,&quot;              let orderObj = (&quot;,&quot;                new proto.opencannabis.commerce.Order());&quot;,&quot;              orderObj.setId(orderId);&quot;,&quot;              orderObj.setCreatedAt(instant);&quot;,&quot;              orderObj.setType(&quot;,&quot;                /** @type {proto.opencannabis.commerce.OrderType} */ (&quot;,&quot;                  objOrderType));&quot;,&quot;              orderObj.setStatus(&quot;,&quot;                /** @type {proto.opencannabis.commerce.OrderStatus} */ (&quot;,&quot;                  objOrderStatus));&quot;,&quot;              orderObj.setScheduling(objOrderScheduling);&quot;,&quot;              if (orderNotes) orderObj.setNotes(orderNotes);&quot;,null,&quot;              let sdkOrder = bloombox.shop.order.Order.fromProto(&quot;,&quot;                orderObj, customerObj, locationObj, orderItems);&quot;,&quot;              callback(null, sdkOrder);&quot;,&quot;            }&quot;,&quot;          }&quot;,&quot;        } else {&quot;,&quot;          // it failed, with no error&quot;,&quot;          // @TODO order error support here&quot;,&quot;          bloombox.logging.error(&quot;,&quot;            &#39;Order retrieval RPC failed for unknown reason.&#39;, response);&quot;,&quot;          callback(null, null);&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }), function(status) {&quot;,&quot;      // we got an error&quot;,&quot;      bloombox.logging.error(&quot;,&quot;        &#39;Order retrieval RPC failed with status: &#39;, status);&quot;,&quot;      callback(null, null, status);&quot;,&quot;    });&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Submit the order for fulfillment.&quot;,&quot; *&quot;,&quot; * @param {bloombox.shop.OrderCallback} callback Order callback.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.shop.order.Order.prototype.send = function(callback) {&quot;,&quot;  // set basic properties&quot;,&quot;  let payload = new proto.opencannabis.commerce.Order();&quot;,&quot;  payload.setType(&quot;,&quot;    /** @type {proto.opencannabis.commerce.OrderType&lt;number&gt;} */ (this.type));&quot;,null,&quot;  let sid = bloombox.telemetry.resolveSessionID();&quot;,&quot;  payload.setSid(sid);&quot;,null,&quot;  // add notes, if any are specified&quot;,&quot;  let notes = this.notes;&quot;,&quot;  if (notes !== null) payload.setNotes(notes);&quot;,null,&quot;  // add the customer proto&quot;,&quot;  let customer = this.customer.export();&quot;,&quot;  payload.setCustomer(customer);&quot;,null,&quot;  // add scheduling info&quot;,&quot;  let scheduling = this.scheduling.export();&quot;,&quot;  payload.setScheduling(scheduling);&quot;,null,&quot;  // add location info, if it&#39;s delivery&quot;,&quot;  if (this.type === bloombox.shop.order.Type.DELIVERY) {&quot;,&quot;    let location = this.location.export();&quot;,&quot;    payload.setDestination(location);&quot;,&quot;  }&quot;,null,&quot;  this.items.map(function(item) {&quot;,&quot;    let itemobj = /** @type {bloombox.shop.Item} */ (item);&quot;,&quot;    let protob = /** @type {!proto.opencannabis.commerce.Item} */ (&quot;,&quot;      itemobj.export());&quot;,&quot;    payload.addItem(protob);&quot;,&quot;  });&quot;,null,&quot;  let done = false;&quot;,null,&quot;  let config = bloombox.config.active();&quot;,&quot;  let partner = config.partner;&quot;,&quot;  let location = config.location;&quot;,null,&quot;  if (!partner || !location) {&quot;,&quot;    bloombox.logging.error(&#39;Partner or location code is not defined.&#39;);&quot;,&quot;    return;&quot;,&quot;  }&quot;,null,&quot;  let serializedItems = this.items.map(function(item) {&quot;,&quot;    return {&quot;,&quot;      &#39;count&#39;: item.count || 1,&quot;,&quot;      &#39;key&#39;: {&quot;,&quot;        &#39;id&#39;: item.key.id,&quot;,&quot;        &#39;type&#39;: {&quot;,&quot;          &#39;kind&#39;: item.key.kind&quot;,&quot;        }&quot;,&quot;      },&quot;,&quot;      &#39;variant&#39;: item.variants.map(function(variant) {&quot;,&quot;        let baseVariant = {&quot;,&quot;          &#39;variant&#39;: variant.getVariant()&quot;,&quot;        };&quot;,null,&quot;        if (variant.getWeight()) {&quot;,&quot;          baseVariant[&#39;weight&#39;] = variant.getWeight();&quot;,&quot;        } else if (variant.getSize()) {&quot;,&quot;          baseVariant[&#39;size&#39;] = variant.getSize();&quot;,&quot;        } else if (variant.getColor()) {&quot;,&quot;          baseVariant[&#39;color&#39;] = variant.getColor();&quot;,&quot;        }&quot;,&quot;        return baseVariant;&quot;,&quot;      })&quot;,&quot;    };&quot;,&quot;  });&quot;,null,&quot;  let payloadObject = {&quot;,&quot;    &#39;sid&#39;: payload.getSid(),&quot;,&quot;    &#39;type&#39;: payload.getType(),&quot;,&quot;    &#39;partnerCode&#39;: partner,&quot;,&quot;    &#39;locationCode&#39;: location,&quot;,&quot;    &#39;customer&#39;: {&quot;,&quot;      &#39;person&#39;: {&quot;,&quot;        &#39;name&#39;: {&quot;,&quot;          &#39;firstName&#39;: this.customer.person.name.getFirstName(),&quot;,&quot;          &#39;lastName&#39;: this.customer.person.name.getLastName()&quot;,&quot;        },&quot;,&quot;        &#39;contact&#39;: {&quot;,&quot;          &#39;email&#39;: {&#39;address&#39;: this.customer.person.contactInfo.emailAddress},&quot;,&quot;          &#39;phone&#39;: {&#39;e164&#39;: this.customer.person.contactInfo.phoneNumber}&quot;,&quot;        }&quot;,&quot;      },&quot;,&quot;      &#39;foreignId&#39;: this.customer.foreignId&quot;,&quot;    },&quot;,&quot;    &#39;scheduling&#39;: {&quot;,&quot;      &#39;scheduling&#39;: payload.getScheduling().getScheduling()&quot;,&quot;    },&quot;,&quot;    &#39;item&#39;: serializedItems&quot;,&quot;  };&quot;,null,&quot;  if (typeof payload.getNotes() === &#39;string&#39;) {&quot;,&quot;    payloadObject[&#39;notes&#39;] = payload.getNotes();&quot;,&quot;  }&quot;,null,&quot;  if (payload.getType() === bloombox.shop.order.Type.DELIVERY) {&quot;,&quot;    if (!payload.getDestination() || !payload.getDestination().getAddress())&quot;,&quot;      throw new bloombox.shop.order.OrderException(&quot;,&quot;        &#39;Missing destination information, but order type is DELIVERY.&#39;);&quot;,&quot;    payloadObject[&#39;destination&#39;] = {&quot;,&quot;      &#39;address&#39;: {&quot;,&quot;        &#39;firstLine&#39;: payload.getDestination().getAddress().getFirstLine(),&quot;,&quot;        &#39;city&#39;: payload.getDestination().getAddress().getCity(),&quot;,&quot;        &#39;state&#39;: payload.getDestination().getAddress().getState(),&quot;,&quot;        &#39;zipcode&#39;: payload.getDestination().getAddress().getZipcode(),&quot;,&quot;        &#39;country&#39;: payload.getDestination().getAddress().getCountry() || &#39;USA&#39;&quot;,&quot;      }&quot;,&quot;    };&quot;,&quot;    if (payload.getNotes())&quot;,&quot;      payloadObject[&#39;notes&#39;] = payload.getNotes();&quot;,null,&quot;    if (payload.getDestination().getAddress().getSecondLine())&quot;,&quot;      payloadObject[&#39;destination&#39;][&#39;address&#39;][&#39;secondLine&#39;] = (&quot;,&quot;        payload.getDestination().getAddress().getSecondLine());&quot;,null,&quot;    if (payload.getDestination().getInstructions())&quot;,&quot;      payloadObject[&#39;destination&#39;][&#39;instructions&#39;] = (&quot;,&quot;        payload.getDestination().getInstructions());&quot;,&quot;  }&quot;,null,&quot;  // make the RPC&quot;,&quot;  new bloombox.shop.rpc.ShopRPC(&quot;,&quot;    /** @type {bloombox.shop.Routine} */ (&quot;,&quot;      bloombox.shop.Routine.SUBMIT_ORDER), &#39;POST&#39;, [&quot;,&quot;        &#39;partners&#39;,&quot;,&quot;        partner,&quot;,&quot;        &#39;locations&#39;,&quot;,&quot;        location,&quot;,&quot;        &#39;orders&#39;&quot;,&quot;    ].join(&#39;/&#39;), payloadObject)&quot;,&quot;    .send((function(response) {&quot;,&quot;      if (done) return;&quot;,&quot;      if (response !== null) {&quot;,&quot;        done = true;&quot;,null,&quot;        bloombox.logging.log(&quot;,&quot;          &#39;Response received for order submission RPC.&#39;, response);&quot;,null,&quot;        // decode the response&quot;,&quot;        let inflated = (&quot;,&quot;          new proto.bloombox.schema.services.shop.v1.SubmitOrder.Response());&quot;,&quot;        if (response[&#39;error&#39;])&quot;,&quot;          inflated.setError(response[&#39;error&#39;]);&quot;,&quot;        inflated.setOrderId(response[&#39;orderId&#39;]);&quot;,null,&quot;        if ((&quot;,&quot;          inflated.getError() === (&quot;,&quot;            proto.bloombox.schema.services.shop.v1.OrderError.NO_ERROR)) &amp;&amp;&quot;,&quot;            inflated.getOrderId()) {&quot;,&quot;          this.id = inflated.getOrderId();&quot;,&quot;          callback(/** @type {string} */ (inflated.getOrderId()), this, null);&quot;,&quot;          this.sendAnalytics(inflated.getOrderId());&quot;,&quot;          return;&quot;,&quot;        } else {&quot;,&quot;          let error = inflated.getError();&quot;,&quot;          bloombox.logging.error(&quot;,&quot;              &#39;Server indicated order submission failed.&#39;,&quot;,&quot;            {&#39;response&#39;: response, &#39;error&#39;: error});&quot;,&quot;          callback(null, null, error);&quot;,&quot;          this.sendAnalytics(null, error);&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;      callback(null, null);  // an error occurred&quot;,&quot;    }).bind(this), function(status) {&quot;,&quot;      // we got an error&quot;,&quot;      bloombox.logging.error(&quot;,&quot;          &#39;Order submission RPC failed with status: &#39;, status);&quot;,&quot;      callback(null, null, status);&quot;,&quot;      this.sendAnalytics(null, null, status);&quot;,&quot;    });&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../dossier.js" defer></script>