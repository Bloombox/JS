<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>events.js</title><link href="../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;events.js&quot;,&quot;src/telemetry/services/events.js&quot;,[null,&quot;/*&quot;,&quot; * Copyright 2018, Bloombox, LLC. All rights reserved.&quot;,&quot; *&quot;,&quot; * Source and object computer code contained herein is the private intellectual&quot;,&quot; * property of Bloombox, a California Limited Liability Corporation. Use of this&quot;,&quot; * code in source form requires permission in writing before use or the&quot;,&quot; * assembly, distribution, or publishing of derivative works, for commercial&quot;,&quot; * purposes or any other purpose, from a duly authorized officer of Momentum&quot;,&quot; * Ideas Co.&quot;,&quot; *&quot;,&quot; * Unless required by applicable law or agreed to in writing, software&quot;,&quot; * distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,&quot;,&quot; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot; * See the License for the specific language governing permissions and&quot;,&quot; * limitations under the License.&quot;,&quot; */&quot;,null,&quot;/**&quot;,&quot; * Bloombox Telemetry Services: Events&quot;,&quot; *&quot;,&quot; * @fileoverview Provides tools for interacting with the Telemetry Events&quot;,&quot; * API service.&quot;,&quot; */&quot;,null,&quot;/*global goog */&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.BaseEvent&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.Collection&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.Context&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.ContextException&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.globalContext&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.util.Exportable&#39;);&quot;,null,&quot;goog.require(&#39;proto.bloombox.schema.analytics.Context&#39;);&quot;,&quot;goog.require(&#39;proto.bloombox.schema.analytics.generic.Event&#39;);&quot;,&quot;goog.require(&#39;proto.google.protobuf.Struct&#39;);&quot;,&quot;goog.require(&#39;proto.opencannabis.temporal.Instant&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.telemetry.Event&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.InternalCollection&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.event&#39;);&quot;,null,null,&quot;// - Generic Events - //&quot;,&quot;/**&quot;,&quot; * Generic telemetry service event record, for basic event-style analytics.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.Collection} collection Collection to assign this&quot;,&quot; *        event to.&quot;,&quot; * @param {Object=} opt_payload Payload to attach to this event, if any.&quot;,&quot; * @param {?bloombox.telemetry.Context=} opt_context Additional context to apply&quot;,&quot; *        to the default set that is sent globally.&quot;,&quot; * @param {number=} opt_occurred Millisecond-resolution timestamp for when this&quot;,&quot; *        event occurred. If none is provided, a timestamp is taken upon event&quot;,&quot; *        construction.&quot;,&quot; * @constructor&quot;,&quot; * @extends {bloombox.telemetry.BaseEvent&lt;proto.bloombox.schema.analytics.generic.Event&gt;}&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Event = function Event(collection,&quot;,&quot;                                          opt_payload,&quot;,&quot;                                          opt_context,&quot;,&quot;                                          opt_occurred) {&quot;,&quot;  /**&quot;,&quot;   * Event collection to specify.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.telemetry.Collection}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.collection = collection;&quot;,null,&quot;  /**&quot;,&quot;   * Timestamp for when this event occurred. If none is given, a timestamp is&quot;,&quot;   * generated when the event is constructed.&quot;,&quot;   *&quot;,&quot;   * @type {number}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.occurred = opt_occurred || +(new Date());&quot;,null,&quot;  // generate a super context considering the local collection&quot;,&quot;  let supercontext = new bloombox.telemetry.Context(&quot;,&quot;    this.collection);&quot;,null,&quot;  bloombox.telemetry.BaseEvent.apply(&quot;,&quot;    this,&quot;,&quot;    [supercontext,&quot;,&quot;     bloombox.telemetry.Routine.EVENT,&quot;,&quot;     opt_payload,&quot;,&quot;     this.occurred]);&quot;,&quot;};&quot;,&quot;goog.inherits(bloombox.telemetry.Event, bloombox.telemetry.BaseEvent);&quot;,null,null,&quot;/**&quot;,&quot; * Return the corresponding RPC method for a generic event.&quot;,&quot; *&quot;,&quot; * @return {bloombox.telemetry.Routine} RPC routine for this event.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Event.prototype.rpcMethod = function() {&quot;,&quot;  return bloombox.telemetry.Routine.EVENT;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Indicate whether this event is bound for an internal event collection.&quot;,&quot; *&quot;,&quot; * @return {boolean} True if this is an internal event.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Event.prototype.isInternalEvent_ = function() {&quot;,&quot;  return this.collection.name.startsWith((&quot;,&quot;      bloombox.telemetry.InternalCollectionPrefix));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Additionally validate that partner and location codes are present for non-&quot;,&quot; * internal event collections.&quot;,&quot; *&quot;,&quot; * @param {proto.bloombox.schema.analytics.Context} context Final context to&quot;,&quot; *        validate.&quot;,&quot; * @throws {bloombox.telemetry.ContextException} If required context is missing&quot;,&quot; *         or context values are invalid.&quot;,&quot; * @protected&quot;,&quot; * @override&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Event.prototype.validateContext = function(context) {&quot;,&quot;  // validate context w/super method first&quot;,&quot;  bloombox.telemetry.BaseEvent.prototype&quot;,&quot;    .validateContext.apply(this, [context]);&quot;,null,&quot;  // then validate that we&#39;re either pushing an internal event, or we have a&quot;,&quot;  // valid partner and location code&quot;,&quot;  if (!this.isInternalEvent_) {&quot;,&quot;    // get location key&quot;,&quot;    let contextKey = context.getScope().getPartner();&quot;,&quot;    if (contextKey.indexOf(&#39;partner/&#39;) === -1 ||&quot;,&quot;        contextKey.indexOf(&#39;location/&#39;) === -1)&quot;,&quot;      // we are missing a location key or code&quot;,&quot;      throw new bloombox.telemetry.ContextException(&quot;,&quot;        &#39;Must specify a location code before sending analytics events.&#39;);&quot;,&quot;  }&quot;,&quot;  // if we get here, everything is a-o-k.&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Export this generic event as a&quot;,&quot; * `proto.bloombox.schema.analytics.generic.Event`, suitable for sending to the&quot;,&quot; * telemetry service. This includes:&quot;,&quot; * - Rendering the context with `renderContext`&quot;,&quot; * - Rendering the payload with `renderPayload`&quot;,&quot; * - Rendering the occurrence with `renderOccurrence`&quot;,&quot; * - Filling out the proto and related sub-protos&quot;,&quot; *&quot;,&quot; * @return {proto.bloombox.schema.analytics.generic.Event} Prepared event.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Event.prototype.export = function() {&quot;,&quot;  // create our protos&quot;,&quot;  let event = new proto.bloombox.schema.analytics.generic.Event();&quot;,&quot;  let occurrence = new proto.opencannabis.temporal.Instant();&quot;,null,&quot;  // render local values&quot;,&quot;  let payload = this.renderPayload();&quot;,&quot;  let occurred = this.renderOccurrence(+(new Date()));&quot;,&quot;  occurrence.setTimestamp(occurred);&quot;,null,&quot;  // set payload&quot;,&quot;  if (payload &amp;&amp; typeof payload === &#39;object&#39;) {&quot;,&quot;    event.setPayload(proto.google.protobuf.Struct.fromJavaScript(payload));&quot;,&quot;  }&quot;,null,&quot;  // setup event parameters&quot;,&quot;  event.setOccurred(occurrence);&quot;,&quot;  return event;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Provide the attached payload, if any, as the final payload to send for the&quot;,&quot; * event, along with serialized event context.&quot;,&quot; *&quot;,&quot; * @return {?Object} Either `null`, indicating no payload should be attached, or&quot;,&quot; * the attached payload object, provided at construction time.&quot;,&quot; * @override&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Event.prototype.renderPayload = function() {&quot;,&quot;  return {&#39;event&#39;: {&#39;payload&#39;: this.payload}};&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Prefix to use for internal collection names.&quot;,&quot; *&quot;,&quot; * @const {string}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.InternalCollectionPrefix = &#39;_bloom_&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * Separator to use for internal collection names.&quot;,&quot; *&quot;,&quot; * @const {string}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;bloombox.telemetry.InternalCollectionSeparator_ = &#39;:&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * Version to use for internal collection names.&quot;,&quot; *&quot;,&quot; * @const {string}&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;bloombox.telemetry.InternalCollectionVersion_ = &#39;v1beta3&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * Separator to use for internal collection names.&quot;,&quot; *&quot;,&quot; * @param {string} name Actual name to give the collection.&quot;,&quot; * @return {string} Constructed collection name.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internalCollectionName = function(name) {&quot;,&quot;  return [&quot;,&quot;    bloombox.telemetry.InternalCollectionPrefix,&quot;,&quot;    bloombox.telemetry.InternalCollectionVersion_,&quot;,&quot;    name&quot;,&quot;  ].join(bloombox.telemetry.InternalCollectionSeparator_);&quot;,&quot;};&quot;,null,null,null,&quot;/**&quot;,&quot; * Internal event collections used for various metrics and counters.&quot;,&quot; *&quot;,&quot; * @enum {string}&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.InternalCollection = {&quot;,&quot;  LIBRARY: bloombox.telemetry.internalCollectionName(&#39;library&#39;),&quot;,&quot;  PAGEVIEW: bloombox.telemetry.internalCollectionName(&#39;pageview&#39;),&quot;,&quot;  SERVICE: bloombox.telemetry.internalCollectionName(&#39;service&#39;),&quot;,&quot;  ORDERS: bloombox.telemetry.internalCollectionName(&#39;orders&#39;),&quot;,&quot;  ENROLLMENT: bloombox.telemetry.internalCollectionName(&#39;enrollment&#39;),&quot;,&quot;  VERIFICATION: bloombox.telemetry.internalCollectionName(&#39;verification&#39;)&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Utility function to factory a generic event.&quot;,&quot; *&quot;,&quot; * @param {string|bloombox.telemetry.Collection} collection Collection to add&quot;,&quot; *        this event to.&quot;,&quot; * @param {Object=} opt_payload Payload to attach to this event, if any.&quot;,&quot; * @param {bloombox.telemetry.Context=} opt_context Optional context to merge&quot;,&quot; *        into global context before sending this event.&quot;,&quot; * @param {number=} opt_occurred Occurrence timestamp, if any. If none is&quot;,&quot; *        provided, a timestamp is taken when the event is constructed, which&quot;,&quot; *        happens in this method.&quot;,&quot; * @return {bloombox.telemetry.Event} Resulting event.&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.telemetry.event = function(collection,&quot;,&quot;                                    opt_payload,&quot;,&quot;                                    opt_context,&quot;,&quot;                                    opt_occurred) {&quot;,&quot;  let resolvedCollection = typeof collection !== &#39;string&#39; ? collection : (&quot;,&quot;    bloombox.telemetry.Collection.named(/** @type {string} */ (collection)));&quot;,&quot;  return new bloombox.telemetry.Event(&quot;,&quot;    resolvedCollection, opt_payload, null, opt_occurred);&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../dossier.js" defer></script>