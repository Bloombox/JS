<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>state.js</title><link href="../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;state.js&quot;,&quot;src/telemetry/context/state.js&quot;,[null,&quot;/*&quot;,&quot; * Copyright 2018, Bloombox, LLC. All rights reserved.&quot;,&quot; *&quot;,&quot; * Source and object computer code contained herein is the private intellectual&quot;,&quot; * property of Bloombox, a California Limited Liability Corporation. Use of this&quot;,&quot; * code in source form requires permission in writing before use or the&quot;,&quot; * assembly, distribution, or publishing of derivative works, for commercial&quot;,&quot; * purposes or any other purpose, from a duly authorized officer of Momentum&quot;,&quot; * Ideas Co.&quot;,&quot; *&quot;,&quot; * Unless required by applicable law or agreed to in writing, software&quot;,&quot; * distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,&quot;,&quot; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot; * See the License for the specific language governing permissions and&quot;,&quot; * limitations under the License.&quot;,&quot; */&quot;,null,&quot;/**&quot;,&quot; * Bloombox Telemetry Context: State&quot;,&quot; *&quot;,&quot; * @fileoverview Mounts and manages global event context state, such as the&quot;,&quot; * device fingerprint, session ID, order ID, user ID, and so on.&quot;,&quot; */&quot;,null,&quot;/*global goog */&quot;,null,&quot;goog.provide(&#39;bloombox.telemetry.GlobalStateException&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.globalContext&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.notifyUserID&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.resolveFingerprint&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.resolveSessionID&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.Context&#39;);&quot;,&quot;goog.require(&#39;bloombox.util.generateUUID&#39;);&quot;,null,&quot;goog.require(&#39;proto.bloombox.schema.analytics.context.ApplicationType&#39;);&quot;,&quot;goog.require(&#39;proto.bloombox.schema.analytics.context.DeviceApplication&#39;);&quot;,null,&quot;goog.require(&#39;stackdriver.notifyFingerprint&#39;);&quot;,null,null,&quot;// - Global Context - //&quot;,&quot;/**&quot;,&quot; * Globally-cached context singleton for values that are detected or loaded or&quot;,&quot; * computed expensively by the runtime. Merged into event-level context before&quot;,&quot; * events are sent.&quot;,&quot; *&quot;,&quot; * @type {?bloombox.telemetry.Context}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.GLOBAL_CONTEXT = null;&quot;,null,null,&quot;/**&quot;,&quot; * Globally-cached unique fingerprint for this device. Persisted in local&quot;,&quot; * browser storage. Null means it is not yet initialized.&quot;,&quot; *&quot;,&quot; * @type {?string}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.DEVICE_FINGERPRINT = null;&quot;,null,null,&quot;/**&quot;,&quot; * Session-scoped token to indicate the border between different user sessions.&quot;,&quot; * Leverages session storage instead of local storage. Null means it is not yet&quot;,&quot; * initialized.&quot;,&quot; *&quot;,&quot; * @type {?string}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.SESSION_ID = null;&quot;,null,null,&quot;/**&quot;,&quot; * Globally-cached unique order ID for the next order this user submits.&quot;,&quot; * Persisted and used until an order succeeds, at which point it is rotated,&quot;,&quot; * to prevent duplicate orders.&quot;,&quot; *&quot;,&quot; * @type {?string}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.ORDER_ID = null;&quot;,null,null,&quot;/**&quot;,&quot; * Globally-set user ID, to send along with analytics context.&quot;,&quot; *&quot;,&quot; * @type {?string}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.USER_ID = null;&quot;,null,null,&quot;/**&quot;,&quot; * Enumerates kinds of global state the system supports.&quot;,&quot; *&quot;,&quot; * @enum {number}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.GlobalStateType = {&quot;,&quot;  PERSISTED: 0,&quot;,&quot;  SESSION: 1&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Specifies the storage type for each global state value.&quot;,&quot; *&quot;,&quot; * @enum {bloombox.telemetry.GlobalStateType}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.GlobalStateTypeMap = {&quot;,&quot;  FINGERPRINT: bloombox.telemetry.GlobalStateType.PERSISTED,&quot;,&quot;  SESSION_ID: bloombox.telemetry.GlobalStateType.SESSION,&quot;,&quot;  ORDER_ID: bloombox.telemetry.GlobalStateType.PERSISTED,&quot;,&quot;  USER_ID: bloombox.telemetry.GlobalStateType.SESSION&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Enumerates the different global context values, and their keys within the&quot;,&quot; * underlying persistence mechanism, which is handled by `GlobalStateTypeMap`.&quot;,&quot; *&quot;,&quot; * @enum {string}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.GlobalState = {&quot;,&quot;  FINGERPRINT: &#39;bb:v1:t.df&#39;,&quot;,&quot;  SESSION_ID: &#39;bb:v1:t.sid&#39;,&quot;,&quot;  ORDER_ID: &#39;bb:v1:t.oid&#39;,&quot;,&quot;  USER_ID: &#39;bb:v1:t.uid&#39;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Indicates an exception that was encountered while working with global state.&quot;,&quot; * This could mean a state type could not be resolved, or a state key could not&quot;,&quot; * be found, for a given state item.&quot;,&quot; *&quot;,&quot; * @param {string} msg Error message.&quot;,&quot; * @constructor&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.GlobalStateException = function GlobalStateException(msg) {&quot;,&quot;  /**&quot;,&quot;   * Error message.&quot;,&quot;   *&quot;,&quot;   * @type {string}&quot;,&quot;   */&quot;,&quot;  this.message = msg;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Format the exception according to its message.&quot;,&quot; *&quot;,&quot; * @return {string} Message value.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.GlobalStateException.prototype.toString = function() {&quot;,&quot;  return this.message;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Resolve global state type for a given global state item.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.GlobalState} item Item to retrieve state for.&quot;,&quot; * @return {bloombox.telemetry.GlobalStateTypeMap} Type of state for the item&quot;,&quot; *         in question. If it cannot be located, the exception class&quot;,&quot; *         `bloombox.telemetry.GlobalStateException` is thrown.&quot;,&quot; * @throws {bloombox.telemetry.GlobalStateException} If a given state value is&quot;,&quot; *         requested, but its state type or key cannot be resolved.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry._resolveStateType = function(item) {&quot;,&quot;  // resolve global state type and key&quot;,&quot;  let stateType = /** @type {?bloombox.telemetry.GlobalStateTypeMap} */ (null);&quot;,&quot;  switch (item) {&quot;,&quot;    case bloombox.telemetry.GlobalState.FINGERPRINT:&quot;,&quot;      stateType = bloombox.telemetry.GlobalStateTypeMap.FINGERPRINT;&quot;,&quot;      break;&quot;,&quot;    case bloombox.telemetry.GlobalState.SESSION_ID:&quot;,&quot;      stateType = bloombox.telemetry.GlobalStateTypeMap.SESSION_ID;&quot;,&quot;      break;&quot;,&quot;    case bloombox.telemetry.GlobalState.ORDER_ID:&quot;,&quot;      stateType = bloombox.telemetry.GlobalStateTypeMap.ORDER_ID;&quot;,&quot;      break;&quot;,&quot;    case bloombox.telemetry.GlobalState.USER_ID:&quot;,&quot;      stateType = bloombox.telemetry.GlobalStateTypeMap.USER_ID;&quot;,&quot;      break;&quot;,&quot;  }&quot;,&quot;  if (stateType === null) throw new bloombox.telemetry.GlobalStateException(&quot;,&quot;    &#39;Failed to resolve global state of type: \\&#39;&#39; + stateType + &#39;\\&#39;.&#39;);&quot;,&quot;  return stateType;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Resolve an item stored in either persistent or session state.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.GlobalState} item Item to retrieve state for.&quot;,&quot; * @return {?string} State item, or `null`, if a value could not be located.&quot;,&quot; * @throws {bloombox.telemetry.GlobalStateException} If a given state value is&quot;,&quot; *         requested, but its state type or key cannot be resolved.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry._resolveGlobalState = function(item) {&quot;,&quot;  let stateType = bloombox.telemetry._resolveStateType(item);&quot;,&quot;  if (stateType === null) throw new bloombox.telemetry.GlobalStateException(&quot;,&quot;      &#39;Failed to resolve global state of type: \\&#39;&#39; + stateType + &#39;\\&#39;.&#39;);&quot;,null,&quot;  // fetch according to type&quot;,&quot;  let stateValue = /** @type {?string} */ (null);&quot;,&quot;  switch (stateType) {&quot;,&quot;    case bloombox.telemetry.GlobalStateType.PERSISTED:&quot;,&quot;      stateValue = /** @type {?string} */ (window.localStorage.getItem(item));&quot;,&quot;      break;&quot;,null,&quot;    case bloombox.telemetry.GlobalStateType.SESSION:&quot;,&quot;      stateValue = /** @type {?string} */ (window.sessionStorage.getItem(item));&quot;,&quot;      break;&quot;,&quot;  }&quot;,&quot;  if (!stateValue || (typeof stateValue !== &#39;string&#39;))&quot;,&quot;    return null;&quot;,&quot;  return stateValue;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Store an item in global state. If the item is not a native string, encode it&quot;,&quot; * using `JSON.stringify` before storing. Setting a value to `null` triggers any&quot;,&quot; * value stored at the subject key to be cleared.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.GlobalState} item Item to set in persistence.&quot;,&quot; * @param {?Object|string} value Value to set for the global state item. Passing&quot;,&quot; *        `null` clears any set value.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry._setGlobalState = function(item, value) {&quot;,&quot;  let stateType = bloombox.telemetry._resolveStateType(item);&quot;,null,&quot;  // resolve value to store, optionally encoding in JSON&quot;,&quot;  let toStore = /** @type {?string} */ (null);&quot;,&quot;  if (typeof value === &#39;string&#39; &amp;&amp; value) {&quot;,&quot;    toStore = value;&quot;,&quot;  } else {&quot;,&quot;    if (value === null) {&quot;,&quot;      // we&#39;re clearing stuff, do nothing&quot;,&quot;    } else {&quot;,&quot;      toStore = JSON.stringify(value);&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  // fetch according to type&quot;,&quot;  switch (stateType) {&quot;,&quot;    case bloombox.telemetry.GlobalStateType.PERSISTED:&quot;,&quot;      if (toStore !== null) {&quot;,&quot;        window.localStorage.setItem(item, /** @type {string} */ (toStore));&quot;,&quot;      } else {&quot;,&quot;        window.localStorage.removeItem(item);&quot;,&quot;      }&quot;,&quot;      break;&quot;,null,&quot;    case bloombox.telemetry.GlobalStateType.SESSION:&quot;,&quot;      if (toStore !== null) {&quot;,&quot;        window.sessionStorage.setItem(item, /** @type {string} */ (toStore));&quot;,&quot;      } else {&quot;,&quot;        window.sessionStorage.removeItem(item);&quot;,&quot;      }&quot;,&quot;      break;&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Look for a state item that should be a UUID. If it&#39;s found, return it. If it&quot;,&quot; * cannot be found, generate a UUID, set it at that state item, and return it.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.GlobalState} item Global state item.&quot;,&quot; * @return {string} UUID stored for the given state item.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry._resolveGlobalStateUUID = function(item) {&quot;,&quot;  let stateValue = /** {?string} */ (&quot;,&quot;    bloombox.telemetry._resolveGlobalState(item));&quot;,&quot;  if (stateValue === null) {&quot;,&quot;    // create it&quot;,&quot;    stateValue = bloombox.util.generateUUID();&quot;,&quot;    bloombox.telemetry._setGlobalState(&quot;,&quot;      item, /** @type {string} */ (stateValue));&quot;,&quot;  }&quot;,&quot;  return stateValue;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Resolve the device fingerprint, by creating it if it does not yet exist, or&quot;,&quot; * returning the existing one if it does.&quot;,&quot; *&quot;,&quot; * @return {string} Global device fingerprint.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.resolveFingerprint = function() {&quot;,&quot;  if (bloombox.telemetry.DEVICE_FINGERPRINT === null) {&quot;,&quot;    // establish our spot in-memory, it&#39;s potentially in local storage&quot;,&quot;    bloombox.telemetry.DEVICE_FINGERPRINT = (&quot;,&quot;      bloombox.telemetry._resolveGlobalStateUUID(&quot;,&quot;        bloombox.telemetry.GlobalState.FINGERPRINT));&quot;,&quot;    stackdriver.notifyFingerprint(bloombox.telemetry.DEVICE_FINGERPRINT);&quot;,&quot;  }&quot;,&quot;  return bloombox.telemetry.DEVICE_FINGERPRINT;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Resolve the session ID, by creating it if it does not yet exist, or returning&quot;,&quot; * the existing one if it does.&quot;,&quot; *&quot;,&quot; * @return {string} Session-scoped UUID.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.resolveSessionID = function() {&quot;,&quot;  if (bloombox.telemetry.SESSION_ID === null) {&quot;,&quot;    // establish session value, check session storage first&quot;,&quot;    bloombox.telemetry.SESSION_ID = (&quot;,&quot;      bloombox.telemetry._resolveGlobalStateUUID(&quot;,&quot;        bloombox.telemetry.GlobalState.SESSION_ID));&quot;,&quot;  }&quot;,&quot;  return bloombox.telemetry.SESSION_ID;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Resolve the order ID, by creating it if it does not yet exist, or returning&quot;,&quot; * the existing one if it does.&quot;,&quot; *&quot;,&quot; * @return {string} Order-scoped UUID.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.resolveOrderID = function() {&quot;,&quot;  if (bloombox.telemetry.ORDER_ID === null) {&quot;,&quot;    // establish session value, check session storage first&quot;,&quot;    bloombox.telemetry.ORDER_ID = (&quot;,&quot;      bloombox.telemetry._resolveGlobalStateUUID(&quot;,&quot;        bloombox.telemetry.GlobalState.ORDER_ID));&quot;,&quot;  }&quot;,&quot;  return bloombox.telemetry.ORDER_ID;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Resolve the user ID, if any is currently set.&quot;,&quot; *&quot;,&quot; * @return {?string} User ID, or `null` if currently unset.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.resolveUserID = function() {&quot;,&quot;  return bloombox.telemetry.USER_ID;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Notify the telemetry layer of a ready-to-use user ID.&quot;,&quot; *&quot;,&quot; * @param {string} userId User ID value to set.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.notifyUserID = function(userId) {&quot;,&quot;  bloombox.telemetry.USER_ID = userId;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Retrieve globally gathered/specified context. Caching is applied to reduce&quot;,&quot; * overhead. To force a re-gather of expensively calculated information, pass&quot;,&quot; * `opt_force_fresh` as truthy.&quot;,&quot; *&quot;,&quot; * @param {boolean=} opt_force_fresh Force a fresh load of global context.&quot;,&quot; * @return {bloombox.telemetry.Context} Global context.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.globalContext = function(opt_force_fresh) {&quot;,&quot;  let forceFresh = opt_force_fresh || false;&quot;,&quot;  if (bloombox.telemetry.GLOBAL_CONTEXT === null || forceFresh) {&quot;,&quot;    // grab global config&quot;,&quot;    let config = bloombox.config.active();&quot;,&quot;    let partnerCode = config.partner || null;&quot;,&quot;    let locationCode = config.location || null;&quot;,&quot;    let deviceFingerprint = bloombox.telemetry.resolveFingerprint();&quot;,&quot;    let sessionID = bloombox.telemetry.resolveSessionID();&quot;,&quot;    let orderID = bloombox.telemetry.resolveOrderID();&quot;,&quot;    let nativeContext = bloombox.telemetry.buildNativeContext();&quot;,&quot;    let browserContext = bloombox.telemetry.buildBrowserContext();&quot;,null,&quot;    // build app context&quot;,&quot;    let webContext = bloombox.telemetry.buildWebappContext();&quot;,&quot;    let appContext = (&quot;,&quot;      new proto.bloombox.schema.analytics.context.DeviceApplication());&quot;,&quot;    appContext.setWeb(webContext);&quot;,null,&quot;    if (bloombox.INTERNAL) {&quot;,&quot;      // it&#39;s a bloombox app&quot;,&quot;      appContext.setType((&quot;,&quot;        proto.bloombox.schema.analytics.context.ApplicationType.INTERNAL));&quot;,&quot;    } else {&quot;,&quot;      // it&#39;s a partner-side app&quot;,&quot;      appContext.setType((&quot;,&quot;        proto.bloombox.schema.analytics.context.ApplicationType.PARTNER));&quot;,&quot;    }&quot;,null,&quot;    let deviceId = /** @type {?string} */ (&quot;,&quot;      window[&#39;__BLOOMBOX_DEVICE__&#39;] || null);&quot;,null,&quot;    // calculate global context&quot;,&quot;    bloombox.telemetry.GLOBAL_CONTEXT = new bloombox.telemetry.Context(&quot;,&quot;      null,&quot;,&quot;      partnerCode,&quot;,&quot;      locationCode,&quot;,&quot;      deviceFingerprint,&quot;,&quot;      sessionID,&quot;,&quot;      bloombox.telemetry.resolveUserID(),&quot;,&quot;      deviceId,&quot;,&quot;      null,  // section key is set by callers&quot;,&quot;      null,  // item key is set by callers&quot;,&quot;      orderID,&quot;,&quot;      appContext,&quot;,&quot;      browserContext,&quot;,&quot;      nativeContext);&quot;,&quot;  }&quot;,&quot;  return bloombox.telemetry.GLOBAL_CONTEXT;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../dossier.js" defer></script>