<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>rpc.js</title><link href="../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;rpc.js&quot;,&quot;src/telemetry/rpc.js&quot;,[null,&quot;/*&quot;,&quot; * Copyright 2018, Bloombox, LLC. All rights reserved.&quot;,&quot; *&quot;,&quot; * Source and object computer code contained herein is the private intellectual&quot;,&quot; * property of Bloombox, a California Limited Liability Corporation. Use of this&quot;,&quot; * code in source form requires permission in writing before use or the&quot;,&quot; * assembly, distribution, or publishing of derivative works, for commercial&quot;,&quot; * purposes or any other purpose, from a duly authorized officer of Momentum&quot;,&quot; * Ideas Co.&quot;,&quot; *&quot;,&quot; * Unless required by applicable law or agreed to in writing, software&quot;,&quot; * distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,&quot;,&quot; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot; * See the License for the specific language governing permissions and&quot;,&quot; * limitations under the License.&quot;,&quot; */&quot;,null,&quot;/**&quot;,&quot; * Bloombox Telemetry: RPC&quot;,&quot; *&quot;,&quot; * @fileoverview Provides tools for low-level RPCs to the Telemetry API.&quot;,&quot; */&quot;,null,&quot;/*global goog */&quot;,null,&quot;goog.require(&#39;bloombox.config.active&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.logging.error&#39;);&quot;,&quot;goog.require(&#39;bloombox.logging.log&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.rpc.RPC&#39;);&quot;,&quot;goog.require(&#39;bloombox.rpc.RPCException&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.Context&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.TELEMETRY_API_ENDPOINT&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.TELEMETRY_API_VERSION&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.VERSION&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.util.HTTPMethod&#39;);&quot;,null,&quot;goog.require(&#39;proto.bloombox.schema.services.telemetry.v1beta3.OperationStatus&#39;);&quot;,&quot;goog.require(&#39;proto.bloombox.schema.services.telemetry.v1beta3.TelemetryError&#39;);&quot;,&quot;goog.require(&#39;proto.bloombox.schema.services.telemetry.v1beta3.TelemetryResponse&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.telemetry.OperationStatus&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.Routine&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.TelemetryError&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.endpoint&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.renderEndpoint&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.rpc.CONTEXT_HEADER&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.rpc.ENABLE_CONTEXT_HEADER&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.rpc.TelemetryRPC&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * Context header setting.&quot;,&quot; *&quot;,&quot; * @define {boolean} ENABLE_CONTEXT_HEADER Context header flag.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.rpc.ENABLE_CONTEXT_HEADER = false;&quot;,null,null,&quot;/**&quot;,&quot; * Context header.&quot;,&quot; *&quot;,&quot; * @type {string}&quot;,&quot; * @const&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.rpc.CONTEXT_HEADER = &#39;X-Bloom-Context&#39;;&quot;,null,null,null,&quot;/**&quot;,&quot; * Enumerates methods in the Telemetry API.&quot;,&quot; *&quot;,&quot; * @enum {string}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Routine = {&quot;,&quot;  PING: &#39;PING&#39;,&quot;,&quot;  EVENT: &#39;EVENT&#39;,&quot;,&quot;  EXCEPTION: &#39;EXCEPTION&#39;,&quot;,&quot;  SECTION_IMPRESSION: &#39;SECTION_IMPRESSION&#39;,&quot;,&quot;  SECTION_VIEW: &#39;SECTION_VIEW&#39;,&quot;,&quot;  SECTION_ACTION: &#39;SECTION_ACTION&#39;,&quot;,&quot;  PRODUCT_IMPRESSION: &#39;PRODUCT_IMPRESSION&#39;,&quot;,&quot;  PRODUCT_VIEW: &#39;PRODUCT_VIEW&#39;,&quot;,&quot;  PRODUCT_ACTION: &#39;PRODUCT_ACTION&#39;,&quot;,&quot;  USER_ACTION: &#39;USER_ACTION&#39;,&quot;,&quot;  ORDER_ACTION: &#39;ORDER_ACTION&#39;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Enumerates operation statuses that result from Telemetry API RPC calls.&quot;,&quot; *&quot;,&quot; * @enum {proto.bloombox.schema.services.telemetry.v1beta3.OperationStatus}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.OperationStatus = {&quot;,&quot;  OK: proto.bloombox.schema.services.telemetry.v1beta3.OperationStatus.OK,&quot;,&quot;  ERROR: proto.bloombox.schema.services.telemetry.v1beta3.OperationStatus.ERROR&quot;,&quot;};&quot;,null,null,&quot;// private alias&quot;,&quot;let _TelemetryError = (&quot;,&quot;  proto.bloombox.schema.services.telemetry.v1beta3.TelemetryError);&quot;,null,null,&quot;/**&quot;,&quot; * Enumerates errors in the Telemetry API.&quot;,&quot; *&quot;,&quot; * @enum {proto.bloombox.schema.services.telemetry.v1beta3.TelemetryError}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.TelemetryError = {&quot;,&quot;  &#39;UNKNOWN&#39;: _TelemetryError.UNKNOWN,&quot;,&quot;  &#39;INVALID_COLLECTION&#39;: _TelemetryError.INVALID_COLLECTION,&quot;,&quot;  &#39;INVALID_PARTNER&#39;: _TelemetryError.INVALID_PARTNER,&quot;,&quot;  &#39;INVALID_LOCATION&#39;: _TelemetryError.INVALID_LOCATION,&quot;,&quot;  &#39;INVALID_DEVICE&#39;: _TelemetryError.INVALID_DEVICE,&quot;,&quot;  &#39;INVALID_USER&#39;: _TelemetryError.INVALID_USER,&quot;,&quot;  &#39;INVALID_CLIENT&#39;: _TelemetryError.INVALID_CLIENT,&quot;,&quot;  &#39;PARTNER_NOT_FOUND&#39;: _TelemetryError.PARTNER_NOT_FOUND,&quot;,&quot;  &#39;LOCATION_NOT_FOUND&#39;: _TelemetryError.LOCATION_NOT_FOUND,&quot;,&quot;  &#39;INVALID_PAYLOAD&#39;: _TelemetryError.INVALID_PAYLOAD&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Render a URL endpoint for a given RPC type.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.Routine} type RPC routine.&quot;,&quot; * @param {proto.bloombox.schema.analytics.Context=} opt_context Contextual&quot;,&quot; *        information that may be needed to render the URL.&quot;,&quot; * @return {string} Rendered URL endpoint.&quot;,&quot; * @throws {bloombox.rpc.RPCException} If the subject renderer cannot be found.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.renderEndpoint = function(type, opt_context) {&quot;,&quot;  // retrieve renderer&quot;,&quot;  let renderer = bloombox.telemetry.TelemetryEndpoint[type];&quot;,&quot;  if (!renderer)&quot;,&quot;    throw new bloombox.rpc.RPCException(&quot;,&quot;      &#39;Cannot render RPC of type \&quot;&#39; + type + &#39;\&quot;.&#39;);&quot;,&quot;  return renderer(opt_context);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Calculate a telemetry API endpoint, given an RPC method and the base API&quot;,&quot; * endpoint.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.Routine} type RPC routine.&quot;,&quot; * @param {string} apiKey API key to append to the URL.&quot;,&quot; * @param {proto.bloombox.schema.analytics.Context=} opt_context Contextual&quot;,&quot; *        information that may be needed to render the URL.&quot;,&quot; * @param {string=} opt_target Explicit URL target. Optional.&quot;,&quot; * @return {string} Calculated endpoint URI.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.endpoint = function(type, apiKey, opt_context, opt_target) {&quot;,&quot;  let endpoint = (&quot;,&quot;    opt_target || bloombox.telemetry.renderEndpoint(type, opt_context));&quot;,null,&quot;  // force service endpoint in debug mode&quot;,&quot;  let prefix = bloombox.DEBUG === true ?&quot;,&quot;    &#39;https://telemetry.api.bloombox.cloud&#39; :&quot;,&quot;    bloombox.telemetry.TELEMETRY_API_ENDPOINT;&quot;,null,&quot;  return [[&quot;,&quot;    prefix,&quot;,&quot;    &#39;telemetry&#39;,&quot;,&quot;    bloombox.telemetry.TELEMETRY_API_VERSION,&quot;,&quot;    endpoint.startsWith(&#39;/&#39;) ? endpoint.slice(1) : endpoint&quot;,&quot;  ].join(&#39;/&#39;), [&#39;key&#39;, apiKey].join(&#39;=&#39;)].join(&#39;?&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Return a `TelemetryRPC` instance for a generic HTTP RPC call.&quot;,&quot; *&quot;,&quot; * @param {string} uuid Unique ID for this RPC transaction.&quot;,&quot; * @param {bloombox.telemetry.Routine} rpcMethod RPC routine.&quot;,&quot; * @param {bloombox.telemetry.SuccessCallback} success Callback to dispatch once&quot;,&quot; *        we have a response.&quot;,&quot; * @param {bloombox.telemetry.FailureCallback} failure Callback to dispatch if&quot;,&quot; *        a failure happens.&quot;,&quot; * @param {Object=} opt_payload Payload to use if we&#39;re POST-ing or PUT-ing.&quot;,&quot; * @param {proto.bloombox.schema.analytics.Context=} opt_context Contextual&quot;,&quot; *        information to provide to the URL renderer.&quot;,&quot; * @param {Object=} opt_headers Additional headers to add to the request.&quot;,&quot; * @param {string=} opt_endpoint URL endpoint to send the RPC to.&quot;,&quot; * @throws {bloombox.rpc.RPCException} If the provided values are invalid&quot;,&quot; *         in some way.&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; */&quot;,&quot;bloombox.telemetry.rpc.TelemetryRPC = function TelemetryRPC(uuid,&quot;,&quot;                                                            rpcMethod,&quot;,&quot;                                                            success,&quot;,&quot;                                                            failure,&quot;,&quot;                                                            opt_payload,&quot;,&quot;                                                            opt_context,&quot;,&quot;                                                            opt_headers,&quot;,&quot;                                                            opt_endpoint) {&quot;,&quot;  let config = bloombox.config.active();&quot;,&quot;  let apiKey = config.key;&quot;,null,&quot;  if (opt_endpoint &amp;&amp; typeof opt_endpoint !== &#39;string&#39;)&quot;,&quot;    throw new bloombox.rpc.RPCException(&quot;,&quot;      &#39;Invalid explicit RPC endpoint: &#39; + opt_endpoint);&quot;,&quot;  if (opt_payload !== null &amp;&amp; opt_payload !== undefined &amp;&amp; (&quot;,&quot;      typeof opt_payload !== &#39;object&#39;))&quot;,&quot;    throw new bloombox.rpc.RPCException(&quot;,&quot;      &#39;Cannot provide non-object type as payload: &#39; + opt_payload);&quot;,&quot;  if (!apiKey || !(typeof apiKey === &#39;string&#39;))&quot;,&quot;    throw new bloombox.rpc.RPCException(&#39;API key could not be resolved.&#39; +&quot;,&quot;      &#39; Please call `setup` before any RPC methods.&#39;);&quot;,null,&quot;  let targetEndpoint = bloombox.telemetry.endpoint(&quot;,&quot;    rpcMethod, apiKey, opt_context, opt_endpoint);&quot;,null,&quot;  /**&quot;,&quot;   * RPC routine we&#39;re calling.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.telemetry.Routine}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.rpcMethod = rpcMethod;&quot;,null,&quot;  /**&quot;,&quot;   * HTTP method to dispatch.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.util.HTTPMethod}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.httpMethod = bloombox.telemetry.TelemetryHTTPMethod[rpcMethod];&quot;,null,&quot;  /**&quot;,&quot;   * Target endpoint to send our RPC to.&quot;,&quot;   *&quot;,&quot;   * @type {string}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.endpoint = targetEndpoint;&quot;,null,&quot;  // freeze headers if we&#39;re given headers and freezing is supported&quot;,&quot;  if (opt_headers &amp;&amp; Object.isFrozen &amp;&amp; !Object.isFrozen(opt_headers))&quot;,&quot;    Object.freeze(opt_headers);&quot;,null,&quot;  /**&quot;,&quot;   * Additional headers to add to the request.&quot;,&quot;   *&quot;,&quot;   * @type {Object}&quot;,&quot;   */&quot;,&quot;  this.headers = opt_headers || {};&quot;,null,&quot;  // freeze payload if we&#39;re given a payload and freezing is supported&quot;,&quot;  if (opt_payload &amp;&amp; Object.isFrozen &amp;&amp; !Object.isFrozen(opt_payload))&quot;,&quot;    Object.freeze(opt_payload);&quot;,null,&quot;  /**&quot;,&quot;   * Payload to send with the request, if any.&quot;,&quot;   *&quot;,&quot;   * @type {?Object}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.payload = opt_payload === undefined ? null : opt_payload;&quot;,null,&quot;  /**&quot;,&quot;   * Callback to dispatch once the operation is complete.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.telemetry.SuccessCallback}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.successCallback = success;&quot;,null,&quot;  /**&quot;,&quot;   * Callback to dispatch if an error is encountered.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.telemetry.FailureCallback}&quot;,&quot;   * @public&quot;,&quot;   */&quot;,&quot;  this.failureCallback = failure;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../dossier.js" defer></script>