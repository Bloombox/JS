<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>event.js</title><link href="../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;event.js&quot;,&quot;src/telemetry/event.js&quot;,[null,&quot;/*&quot;,&quot; * Copyright 2018, Bloombox, LLC. All rights reserved.&quot;,&quot; *&quot;,&quot; * Source and object computer code contained herein is the private intellectual&quot;,&quot; * property of Bloombox, a California Limited Liability Corporation. Use of this&quot;,&quot; * code in source form requires permission in writing before use or the&quot;,&quot; * assembly, distribution, or publishing of derivative works, for commercial&quot;,&quot; * purposes or any other purpose, from a duly authorized officer of Momentum&quot;,&quot; * Ideas Co.&quot;,&quot; *&quot;,&quot; * Unless required by applicable law or agreed to in writing, software&quot;,&quot; * distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,&quot;,&quot; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot; * See the License for the specific language governing permissions and&quot;,&quot; * limitations under the License.&quot;,&quot; */&quot;,null,&quot;/**&quot;,&quot; * Bloombox Telemetry: Base Event&quot;,&quot; *&quot;,&quot; * @fileoverview Provides base logic for all events.&quot;,&quot; */&quot;,null,&quot;/*global goog */&quot;,null,&quot;goog.require(&#39;bloombox.DEBUG&#39;);&quot;,&quot;goog.require(&#39;bloombox.DEBUG_PROPERTY&#39;);&quot;,&quot;goog.require(&#39;bloombox.logging.log&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.rpc.API_KEY_HEADER&#39;);&quot;,&quot;goog.require(&#39;bloombox.rpc.DEBUG_HEADER&#39;);&quot;,&quot;goog.require(&#39;bloombox.rpc.TRACE_HEADER&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.Context&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.ContextException&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.OperationStatus&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.Routine&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.abort&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.enqueue&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.globalContext&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.rpc.CONTEXT_HEADER&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.rpc.ENABLE_CONTEXT_HEADER&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.rpc.TelemetryRPC&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.util.Exportable&#39;);&quot;,&quot;goog.require(&#39;bloombox.util.generateUUID&#39;);&quot;,&quot;goog.require(&#39;bloombox.util.proto.merge&#39;);&quot;,null,&quot;goog.require(&#39;proto.bloombox.schema.analytics.Context&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.telemetry.BaseEvent&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.FailureCallback&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.SuccessCallback&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.TelemetryEvent&#39;);&quot;,null,null,&quot;// - Type Definitions - //&quot;,null,&quot;/**&quot;,&quot; * Success callback, specifying one parameter: the result of the operation we&quot;,&quot; * are calling back from.&quot;,&quot; *&quot;,&quot; * @typedef {function(bloombox.telemetry.OperationStatus, ?string=)}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.SuccessCallback;&quot;,null,&quot;/**&quot;,&quot; * Failure callback, specifying three parameters: the result of the operation we&quot;,&quot; * are calling back from, any known telemetry error, and the underlying HTTP&quot;,&quot; * status code. In some cases, such as a timeout, all parameters may be `null`,&quot;,&quot; * except for the first one, which would be provided in every case as either&quot;,&quot; * `OK` or `ERROR`, enabling one function to be used as both a `SuccessCallback`&quot;,&quot; * and `FailureCallback`.&quot;,&quot; *&quot;,&quot; * @typedef {function(&quot;,&quot; *   bloombox.telemetry.OperationStatus,&quot;,&quot; *   ?bloombox.telemetry.TelemetryError,&quot;,&quot; *   ?number,&quot;,&quot; *   ?string=)}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.FailureCallback;&quot;,null,null,&quot;// - Interface: Sendable - //&quot;,&quot;/**&quot;,&quot; * Specifies an interface for an object that may be sent via the telemetry&quot;,&quot; * subsystem. Basically, this enforces the presence of a method, `send`, which&quot;,&quot; * can be called with no parameters, to send whatever it is being called on.&quot;,&quot; *&quot;,&quot; * That entails a lot of hidden machinery - rendering context and payloads,&quot;,&quot; * gathering global context, queueing, and so on. Most of that is implementation&quot;,&quot; * specific, and this method makes it possible to treat those implementors&quot;,&quot; * generically when it comes to sending data.&quot;,&quot; *&quot;,&quot; * @interface&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Sendable = function() {};&quot;,null,&quot;/**&quot;,&quot; * Send the subject data, with no regard for what happens afterwards. This is a&quot;,&quot; * fire-and-forget interface. For callback-based dispatch, see `dispatch`.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Sendable.prototype.send = function() {};&quot;,null,null,&quot;/**&quot;,&quot; * Send the subject data, with callbacks attached for success and error&quot;,&quot; * follow-up. For a fire-and-forget interface, see `send`.&quot;,&quot; *&quot;,&quot; * @param {?bloombox.telemetry.SuccessCallback} success Success callback.&quot;,&quot; * @param {?bloombox.telemetry.FailureCallback} failure Failure callback.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Sendable.prototype.dispatch = function(success, failure) {};&quot;,null,null,&quot;/**&quot;,&quot; * Abort whatever in-flight request might be in-flight for this operation. This&quot;,&quot; * calls into the underlying runtime with a best-effort guarantee.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.Sendable.prototype.abort = function() {};&quot;,null,null,&quot;// - Interface: Telemetry Event - //&quot;,&quot;/**&quot;,&quot; * Basic interface for a Telemetry event. Every event eventually complies with&quot;,&quot; * this interface. Some comply with more.&quot;,&quot; *&quot;,&quot; * @interface&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.TelemetryEvent = function() {};&quot;,null,null,&quot;/**&quot;,&quot; * Generate an RPC transaction corresponding to this event, that reports its&quot;,&quot; * encapsulated information to the telemetry service.&quot;,&quot; *&quot;,&quot; * @throws {bloombox.telemetry.ContextException} If required context is missing&quot;,&quot; *         or context values are invalid.&quot;,&quot; * @return {bloombox.telemetry.rpc.TelemetryRPC}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.TelemetryEvent.prototype.generateRPC = function() {};&quot;,null,null,&quot;/**&quot;,&quot; * Every event is associated with an RPC method that is used to transmit it.&quot;,&quot; * This method resolves the associated method for a given event.&quot;,&quot; *&quot;,&quot; * @return {bloombox.telemetry.Routine} RPC routine for this event.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.TelemetryEvent.prototype.rpcMethod = function() {};&quot;,null,null,&quot;/**&quot;,&quot; * Every event is assigned a unique ID by the frontend, and later again by the&quot;,&quot; * backend. This is mostly to keep track of individual events since objects are&quot;,&quot; * frequently reused in the underlying runtime.&quot;,&quot; *&quot;,&quot; * @return {string} Final UUID to use for this event.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.TelemetryEvent.prototype.renderUUID = function() {};&quot;,null,null,&quot;/**&quot;,&quot; * Every event carries context, which specifies common properties, like the&quot;,&quot; * partner context or user state under which the event was recorded.&quot;,&quot; *&quot;,&quot; * Before the event is sent, `renderContext` is called to merge global context&quot;,&quot; * with any event-specific context. The resulting object is used as the final&quot;,&quot; * context when the event is sent shortly thereafter.&quot;,&quot; *&quot;,&quot; * @param {proto.bloombox.schema.analytics.Context} global Global context to&quot;,&quot; *        merge onto.&quot;,&quot; * @return {proto.bloombox.schema.analytics.Context} Combined/rendered&quot;,&quot; *         event context.&quot;,&quot; * @throws {bloombox.telemetry.ContextException} If required context is missing&quot;,&quot; *         or context values are invalid.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.TelemetryEvent.prototype.renderContext = function(global) {};&quot;,null,null,&quot;/**&quot;,&quot; * Most event types support the concept of a `payload`, which is arbitrary&quot;,&quot; * object data detailing other information related to the event. The usage and&quot;,&quot; * specification for the payload is event specific, so this method resolves that&quot;,&quot; * for the generic case of rendering and sending those payloads.&quot;,&quot; *&quot;,&quot; * @return {?Object} Either `null`, indicating no payload should be attached, or&quot;,&quot; * an object that is serializable via JSON.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.TelemetryEvent.prototype.renderPayload = function() {};&quot;,null,null,&quot;/**&quot;,&quot; * Every event has a timestamp associated with when it occurred. This method&quot;,&quot; * requests that value from an event, delegating its timing to code inside the&quot;,&quot; * implementation of each event type.&quot;,&quot; *&quot;,&quot; * @param {number} now Timestamp for when this method is dispatched, in case the&quot;,&quot; *        event would like to use that.&quot;,&quot; * @return {number} Millisecond-resolution timestamp to use for this event.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.TelemetryEvent.prototype.renderOccurrence = function(now) {};&quot;,null,null,null,&quot;// - Base Classes: Base Event - //&quot;,&quot;// noinspection GjsLint&quot;,&quot;/**&quot;,&quot; * Basic constructor for every kind of event. Context is accepted, along with&quot;,&quot; * the option for a payload and an explicit timestamp. If a timestamp for event&quot;,&quot; * occurrence is not provided, one is generated.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.Context} context Context to apply to this event.&quot;,&quot; * @param {bloombox.telemetry.Routine} method RPC method for this event.&quot;,&quot; * @param {Object=} opt_payload Optional payload to attach to this event.&quot;,&quot; * @param {number=} opt_occurred Optional explicit occurrence timestamp to&quot;,&quot; *        specify for this event.&quot;,&quot; * @param {string=} opt_uuid Optional explicit UUID for this specific event.&quot;,&quot; *        If one is not provided, one will be generated by this method.&quot;,&quot; * @implements {bloombox.telemetry.TelemetryEvent}&quot;,&quot; * @implements {bloombox.telemetry.Sendable}&quot;,&quot; * @implements {bloombox.util.Exportable&lt;T&gt;}&quot;,&quot; * @template T&quot;,&quot; * @constructor&quot;,&quot; * @abstract&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent = function(context,&quot;,&quot;                                        method,&quot;,&quot;                                        opt_payload,&quot;,&quot;                                        opt_occurred,&quot;,&quot;                                        opt_uuid) {&quot;,&quot;  /**&quot;,&quot;   * Unique ID for this event.&quot;,&quot;   *&quot;,&quot;   * @type {string}&quot;,&quot;   * @protected&quot;,&quot;   */&quot;,&quot;  this.uuid = opt_uuid || bloombox.util.generateUUID();&quot;,null,&quot;  /**&quot;,&quot;   * RPC method to dispatch when transmitting this event.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.telemetry.Routine}&quot;,&quot;   * @protected&quot;,&quot;   */&quot;,&quot;  this.operation = method;&quot;,null,&quot;  /**&quot;,&quot;   * Context to apply for this event.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.telemetry.Context}&quot;,&quot;   * @protected&quot;,&quot;   */&quot;,&quot;  this.context = context;&quot;,null,&quot;  // freeze the payload if we are given one&quot;,&quot;  if (opt_payload &amp;&amp; Object.isFrozen &amp;&amp; !Object.isFrozen(opt_payload))&quot;,&quot;    Object.freeze(opt_payload);&quot;,null,&quot;  /**&quot;,&quot;   * Payload to attach to this event, if any.&quot;,&quot;   *&quot;,&quot;   * @type {?Object}&quot;,&quot;   * @protected&quot;,&quot;   */&quot;,&quot;  this.payload = opt_payload || null;&quot;,null,&quot;  /**&quot;,&quot;   * Context to apply for this event.&quot;,&quot;   *&quot;,&quot;   * @type {number}&quot;,&quot;   * @protected&quot;,&quot;   */&quot;,&quot;  this.occurred = opt_occurred || +(new Date);&quot;,null,&quot;  /**&quot;,&quot;   * Success callback to dispatch, if any.&quot;,&quot;   *&quot;,&quot;   * @type {?bloombox.telemetry.SuccessCallback}&quot;,&quot;   */&quot;,&quot;  this.successCallback = null;&quot;,null,&quot;  /**&quot;,&quot;   * Failure callback to dispatch, if any.&quot;,&quot;   *&quot;,&quot;   * @type {?bloombox.telemetry.FailureCallback}&quot;,&quot;   */&quot;,&quot;  this.failureCallback = null;&quot;,&quot;};&quot;,null,null,&quot;// - Base Event: Abstract Methods - //&quot;,&quot;// noinspection GjsLint&quot;,&quot;/**&quot;,&quot; * Retrieve this event&#39;s corresponding RPC method.&quot;,&quot; *&quot;,&quot; * @return {bloombox.telemetry.Routine} RPC routine for this ev ent.&quot;,&quot; * @public&quot;,&quot; * @abstract&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.rpcMethod = function() {};&quot;,null,null,&quot;// noinspection GjsLint&quot;,&quot;/**&quot;,&quot; * Abstract base method of proto/struct export, which must be defined on every&quot;,&quot; * event implementor of `BaseEvent`.&quot;,&quot; *&quot;,&quot; * @return {T}&quot;,&quot; * @public&quot;,&quot; * @abstract&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.export = function() {};&quot;,null,null,&quot;// noinspection GjsLint&quot;,&quot;/**&quot;,&quot; * Abstract base method to provide the attached payload, if any, as the final&quot;,&quot; * payload to send for the event.&quot;,&quot; *&quot;,&quot; * @abstract&quot;,&quot; * @return {?Object} Either `null`, indicating no payload should be attached, or&quot;,&quot; * the attached payload object, provided at construction time.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.renderPayload = function() {};&quot;,null,null,&quot;// - Base Event: Default Implementations - //&quot;,&quot;/**&quot;,&quot; * Default implementation. Success callback dispatcher.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.OperationStatus} status Status of the operation we&quot;,&quot; *        are calling back from.&quot;,&quot; * @param {?string=} opt_mark Sentinel to check for to prevent recursion.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.onSuccess = function(status, opt_mark) {&quot;,&quot;  // if there is a success callback attached, call it&quot;,&quot;  if (this.successCallback &amp;&amp; typeof this.successCallback === &#39;function&#39; &amp;&amp;&quot;,&quot;      opt_mark !== &#39;_BASE_EVENT_ON_SUCCESS_&#39;)&quot;,&quot;    this.successCallback(status, &#39;_BASE_EVENT_ON_SUCCESS_&#39;);&quot;,&quot;  this.successCallback = null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Default implementation. Failure callback dispatcher.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.OperationStatus} op Status of the operation we are&quot;,&quot; *        calling back from.&quot;,&quot; * @param {?bloombox.telemetry.TelemetryError} error Known error, if any.&quot;,&quot; * @param {?number} code Status code of the underlying RPC, if any.&quot;,&quot; * @param {?string=} opt_mark Sentinel to check for to prevent recursion.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.onFailure = function(op,&quot;,&quot;                                                            error,&quot;,&quot;                                                            code,&quot;,&quot;                                                            opt_mark) {&quot;,&quot;  // if there is a failure callback attached, call it&quot;,&quot;  if (this.failureCallback &amp;&amp; typeof this.failureCallback === &#39;function&#39; &amp;&amp;&quot;,&quot;      opt_mark !== &#39;_BASE_EVENT_ON_FAILURE_&#39;)&quot;,&quot;    this.failureCallback(op, error, code, &#39;_BASE_EVENT_ON_FAILURE_&#39;);&quot;,&quot;  this.failureCallback = null;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Encode an array of unsigned 8-bit integers (a.k.a. &#39;bytes&#39;), and return&quot;,&quot; * it base64 encoded.&quot;,&quot; *&quot;,&quot; * @param {Uint8Array} u8a Array of bytes.&quot;,&quot; * @return {string} Base64-encoded, UTF-8 encoded bytes.&quot;,&quot; * @private&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.encodeUint8Array_ = function(u8a) {&quot;,&quot;  let CHUNK_SZ = 0x8000;&quot;,&quot;  let c = [];&quot;,&quot;  for (let i = 0; i &lt; u8a.length; i += CHUNK_SZ) {&quot;,&quot;    c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));&quot;,&quot;  }&quot;,&quot;  return btoa(c.join(&#39;&#39;));&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Default implementation. Generate a `TelemetryRPC` suitable for fulfilling&quot;,&quot; * the transmission of this `BaseEvent` to the telemetry service.&quot;,&quot; *&quot;,&quot; * @return {bloombox.telemetry.rpc.TelemetryRPC}&quot;,&quot; * @throws {bloombox.telemetry.ContextException} If required context is missing&quot;,&quot; *         or context values are invalid.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.generateRPC = function() {&quot;,&quot;  // fetch global context and render&quot;,&quot;  let globalContext = bloombox.telemetry.globalContext().export();&quot;,&quot;  let mergedContext = this.renderContext(globalContext);&quot;,null,&quot;  let rpcMethod = this.rpcMethod();&quot;,&quot;  let rpcPayload = this.renderPayload();&quot;,&quot;  let uuid = this.renderUUID();&quot;,null,&quot;  let renderedContext = (&quot;,&quot;    bloombox.telemetry.Context.serializeProto(mergedContext));&quot;,null,&quot;  let resolvedPayload = rpcPayload === null ? {} : rpcPayload;&quot;,&quot;  let body = Object.assign({}, resolvedPayload,&quot;,&quot;    {&#39;context&#39;: renderedContext});&quot;,null,&quot;  // @TEST: test code for binary encoding&quot;,&quot;  let binaryEncoded = mergedContext.serializeBinary();&quot;,&quot;  let b64encoded = this.encodeUint8Array_(binaryEncoded);&quot;,null,&quot;  let currentLength = JSON.stringify(body).length;&quot;,&quot;  let reducedLength = (&quot;,&quot;    JSON.stringify(Object.assign({}, {&#39;payload&#39;: body[&#39;payload&#39;]})).length);&quot;,null,&quot;  bloombox.logging.log(&#39;Preparing RPC.&#39;, {&quot;,&quot;    &#39;payloads&#39;: {&quot;,&quot;      &#39;current&#39;: body,&quot;,&quot;      &#39;context&#39;: b64encoded&quot;,&quot;    },&quot;,&quot;    &#39;comparison&#39;: {&quot;,&quot;      &#39;current&#39;: currentLength,&quot;,&quot;      &#39;b64encoded&#39;: b64encoded.length,&quot;,&quot;      &#39;reduced&#39;: (currentLength &gt; reducedLength) ?&quot;,&quot;        (currentLength - reducedLength) : (reducedLength - currentLength),&quot;,&quot;      &#39;next&#39;: reducedLength&quot;,&quot;    }&quot;,&quot;  });&quot;,null,&quot;  // if debug mode is active, append the debug header and the event UUID as the&quot;,&quot;  // trace header for the request&quot;,&quot;  let rpcHeaders = {};&quot;,&quot;  if (bloombox.DEBUG || (window[bloombox.DEBUG_PROPERTY] === true)) {&quot;,&quot;    rpcHeaders[bloombox.rpc.DEBUG_HEADER] = &#39;debug&#39;;&quot;,&quot;    rpcHeaders[bloombox.rpc.TRACE_HEADER] = uuid;&quot;,&quot;  }&quot;,&quot;  if (bloombox.telemetry.rpc.ENABLE_CONTEXT_HEADER) {&quot;,&quot;    bloombox.logging.log(&#39;EXPERIMENTAL: Attaching context via header.&#39;, {&quot;,&quot;      &#39;encoded&#39;: b64encoded});&quot;,&quot;    rpcHeaders[bloombox.telemetry.rpc.CONTEXT_HEADER] = b64encoded;&quot;,&quot;  }&quot;,null,&quot;  return new bloombox.telemetry.rpc.TelemetryRPC(&quot;,&quot;    uuid,&quot;,&quot;    rpcMethod,&quot;,&quot;    this.onSuccess,&quot;,&quot;    this.onFailure,&quot;,&quot;    body,&quot;,&quot;    mergedContext);&quot;,&quot;};&quot;,null,&quot;/**&quot;,&quot; * Default implementation. Send this data to the telemetry service, with an&quot;,&quot; * attached success and failure callback.&quot;,&quot; *&quot;,&quot; * @param {?bloombox.telemetry.SuccessCallback} success Callback to dispatch if&quot;,&quot; *        the underlying runtime reports success.&quot;,&quot; * @param {?bloombox.telemetry.FailureCallback} failure Callback to dispatch if&quot;,&quot; *        some error or failure is encountered.&quot;,&quot; * @throws {bloombox.telemetry.ContextException} If required context is missing&quot;,&quot; *         or context values are invalid.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.dispatch = function(success, failure) {&quot;,&quot;  this.successCallback = success || null;&quot;,&quot;  this.failureCallback = failure || null;&quot;,&quot;  let rpc = this.generateRPC();&quot;,&quot;  bloombox.telemetry.enqueue(rpc);&quot;,&quot;};&quot;,null,&quot;/**&quot;,&quot; * Default implementation. Abort any underlying in-flight request for this&quot;,&quot; * event, on a best-effort basis.&quot;,&quot; *&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.abort = function() {&quot;,&quot;  let uuid = this.renderUUID();&quot;,&quot;  bloombox.telemetry.abort(uuid);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Default implementation. Use this event&#39;s pre-generated UUID for its&quot;,&quot; * underlying UUID.&quot;,&quot; *&quot;,&quot; * @return {string} Pre-generated or explicitly provided UUID.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.renderUUID = function() {&quot;,&quot;  return this.uuid;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Default implementation. Fire-and-forget this data, by sending it to the&quot;,&quot; * telemetry service.&quot;,&quot; *&quot;,&quot; * @throws {bloombox.telemetry.ContextException} If required context is missing&quot;,&quot; *         or context values are invalid.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.send = function() {&quot;,&quot;  this.dispatch(null, null);&quot;,&quot;};&quot;,null,&quot;/**&quot;,&quot; * Default implementation. Render event context by returning any attached&quot;,&quot; * payload object, or `null`, to indicate there is no payload.&quot;,&quot; *&quot;,&quot; * @param {proto.bloombox.schema.analytics.Context} global Global context.&quot;,&quot; * @return {proto.bloombox.schema.analytics.Context} Combined/rendered event&quot;,&quot; *         context.&quot;,&quot; * @throws {bloombox.telemetry.ContextException} If required context is missing&quot;,&quot; *         or context values are invalid.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.renderContext = function(global) {&quot;,&quot;  let local = /** @type {proto.bloombox.schema.analytics.Context} */ (&quot;,&quot;    this.context.export());&quot;,&quot;  let merged = bloombox.util.proto.merge(local, global);&quot;,&quot;  this.validateContext(merged);&quot;,&quot;  return merged;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Validate final event context before allowing it to return.&quot;,&quot; *&quot;,&quot; * @param {proto.bloombox.schema.analytics.Context} context Final context to&quot;,&quot; *        validate.&quot;,&quot; * @throws {bloombox.telemetry.ContextException} If required context is missing&quot;,&quot; *         or context values are invalid.&quot;,&quot; * @protected&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.validateContext = function(context) {&quot;,&quot;  // fingerprint and session are always required&quot;,&quot;  if (!context.getFingerprint())&quot;,&quot;    throw new bloombox.telemetry.ContextException(&quot;,&quot;      &#39;Missing device fingerprint ID.&#39;);&quot;,&quot;  if (!context.getGroup())&quot;,&quot;    throw new bloombox.telemetry.ContextException(&quot;,&quot;      &#39;Missing device session ID.&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Default implementation. Render the occurrence timestamp for this event,&quot;,&quot; * howsoever this event defines that value. By default, the occurrence timestamp&quot;,&quot; * provided or generated at event construction time is used. If that is not a&quot;,&quot; * valid value, `now` is returned, which is provided by the runtime when this&quot;,&quot; * method is dispatched.&quot;,&quot; *&quot;,&quot; * @param {number} now Millisecond-level timestamp for when this method is&quot;,&quot; *        dispatched.&quot;,&quot; * @return {number} Timestamp to use for this event&#39;s occurrence.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.BaseEvent.prototype.renderOccurrence = function(now) {&quot;,&quot;  return this.occurred || now;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../dossier.js" defer></script>