<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>queue.js</title><link href="../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;queue.js&quot;,&quot;src/telemetry/internals/queue.js&quot;,[null,&quot;/*&quot;,&quot; * Copyright 2018, Bloombox, LLC. All rights reserved.&quot;,&quot; *&quot;,&quot; * Source and object computer code contained herein is the private intellectual&quot;,&quot; * property of Bloombox, a California Limited Liability Corporation. Use of this&quot;,&quot; * code in source form requires permission in writing before use or the&quot;,&quot; * assembly, distribution, or publishing of derivative works, for commercial&quot;,&quot; * purposes or any other purpose, from a duly authorized officer of Momentum&quot;,&quot; * Ideas Co.&quot;,&quot; *&quot;,&quot; * Unless required by applicable law or agreed to in writing, software&quot;,&quot; * distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,&quot;,&quot; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot; * See the License for the specific language governing permissions and&quot;,&quot; * limitations under the License.&quot;,&quot; */&quot;,null,&quot;/**&quot;,&quot; * Bloombox Telemetry: Event Queue&quot;,&quot; *&quot;,&quot; * @fileoverview Provides RPC tools for managing a pool of XHRs.&quot;,&quot; */&quot;,null,&quot;goog.require(&#39;bloombox.logging.log&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.BATCH_SIZE&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.internals.stats.updateRPCQueued&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.rpc.TelemetryRPC&#39;);&quot;,&quot;goog.require(&#39;bloombox.util.generateUUID&#39;);&quot;,null,&quot;goog.require(&#39;goog.structs.PriorityQueue&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.telemetry.internals.EventQueue&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.internals.QueuedEvent&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.telemetry.prepareQueuedEvent&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * Enqueue a Telemetry RPC for fulfillment. This util method will also generate&quot;,&quot; * a UUID for the transaction if one is not provided.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.rpc.TelemetryRPC} rpc RPC to fulfill.&quot;,&quot; * @param {number} priority Priority for the request.&quot;,&quot; * @param {string=} opt_uuid UUID to use. If not provided, it will be generated.&quot;,&quot; * @return {bloombox.telemetry.internals.QueuedEvent} Event, ready to send.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.prepareQueuedEvent = function(rpc, priority, opt_uuid) {&quot;,&quot;  let uuid = opt_uuid === undefined ? bloombox.util.generateUUID() : opt_uuid;&quot;,&quot;  return new bloombox.telemetry.internals.QueuedEvent(uuid, rpc, priority);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Event queued to be sent with its RPC.&quot;,&quot; *&quot;,&quot; * @param {string} uuid UUID for this event.&quot;,&quot; * @param {bloombox.telemetry.rpc.TelemetryRPC} rpc RPC object to enqueue.&quot;,&quot; * @param {number} priority Priority for this event.&quot;,&quot; * @constructor&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.QueuedEvent = function QueuedEvent(uuid,&quot;,&quot;                                                                rpc,&quot;,&quot;                                                                priority) {&quot;,&quot;  /**&quot;,&quot;   * RPC that is enqueued-to-send.&quot;,&quot;   *&quot;,&quot;   * @type {bloombox.telemetry.rpc.TelemetryRPC}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.rpc = rpc;&quot;,null,&quot;  /**&quot;,&quot;   * UUID for this event.&quot;,&quot;   *&quot;,&quot;   * @type {string}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.uuid = uuid;&quot;,null,&quot;  /**&quot;,&quot;   * Priority for this event.&quot;,&quot;   *&quot;,&quot;   * @type {number}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.priority = priority;&quot;,&quot;};&quot;,null,&quot;/**&quot;,&quot; * Queue for event RPCs that are due to be sent to the Telemetry Service.&quot;,&quot; *&quot;,&quot; * @constructor&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.EventQueue = function EventQueue() {&quot;,&quot; /**&quot;,&quot;  * Internal priority queue that holds events-to-be-sent.&quot;,&quot;  *&quot;,&quot;  * @type {goog.structs.PriorityQueue&lt;bloombox.telemetry.internals.QueuedEvent&gt;}&quot;,&quot;  */&quot;,&quot; this.queue = new goog.structs.PriorityQueue();&quot;,null,&quot;  /**&quot;,&quot;   * Current count of queued events.&quot;,&quot;   *&quot;,&quot;   * @type {number}&quot;,&quot;   */&quot;,&quot; this.count = 0;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Enqueue an RPC for a telemetry event.&quot;,&quot; *&quot;,&quot; * @param {number} priority Priority value for this RPC.&quot;,&quot; * @param {bloombox.telemetry.internals.QueuedEvent} ev Event to enqueue.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.EventQueue.prototype.enqueue = function(priority,&quot;,&quot;                                                                     ev) {&quot;,&quot;  this.queue.enqueue(priority, ev);&quot;,&quot;  this.count++;&quot;,null,&quot;  bloombox.telemetry.internals.stats.updateRPCQueued(this.count);&quot;,&quot;  bloombox.logging.log(&#39;Enqueued telemetry event with UUID: &#39; + ev.uuid + &#39;.&#39;);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Dequeue an RPC for a telemetry event, so it can be dispatched.&quot;,&quot; *&quot;,&quot; * @param {function(bloombox.telemetry.internals.QueuedEvent)} mapper Mapper&quot;,&quot; *        function to handle each dequeued event.&quot;,&quot; * @param {?number=} opt_amt Number of events to dequeue. Defaults to the&quot;,&quot; *        default batch size which is configurable from the telemetry base&quot;,&quot; *        settings.&quot;,&quot; * @return {number} Count of events dequeued in this batch.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.EventQueue.prototype.dequeue = function(mapper,&quot;,&quot;                                                                     opt_amt) {&quot;,&quot;  let countToDequeue = opt_amt ? opt_amt : (&quot;,&quot;    bloombox.telemetry.BATCH_SIZE), i = 0;&quot;,null,&quot;  while (i &lt; countToDequeue) {&quot;,&quot;    let ev = this.queue.dequeue();&quot;,&quot;    if (ev) {&quot;,&quot;      // did we get an event?&quot;,&quot;      this.count--;&quot;,&quot;      bloombox.telemetry.internals.stats.updateRPCQueued(this.count);&quot;,&quot;      mapper(ev);&quot;,null,&quot;      // ok dequeue the next one&quot;,&quot;      i++;&quot;,&quot;    } else {&quot;,&quot;      break;&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;  return i;&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../dossier.js" defer></script>