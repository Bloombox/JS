<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>pool.js</title><link href="../../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;pool.js&quot;,&quot;src/telemetry/internals/pool.js&quot;,[null,&quot;/*&quot;,&quot; * Copyright 2018, Bloombox, LLC. All rights reserved.&quot;,&quot; *&quot;,&quot; * Source and object computer code contained herein is the private intellectual&quot;,&quot; * property of Bloombox, a California Limited Liability Corporation. Use of this&quot;,&quot; * code in source form requires permission in writing before use or the&quot;,&quot; * assembly, distribution, or publishing of derivative works, for commercial&quot;,&quot; * purposes or any other purpose, from a duly authorized officer of Momentum&quot;,&quot; * Ideas Co.&quot;,&quot; *&quot;,&quot; * Unless required by applicable law or agreed to in writing, software&quot;,&quot; * distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,&quot;,&quot; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot; * See the License for the specific language governing permissions and&quot;,&quot; * limitations under the License.&quot;,&quot; */&quot;,null,&quot;/**&quot;,&quot; * Bloombox Telemetry: RPC Pool&quot;,&quot; *&quot;,&quot; * @fileoverview Provides RPC tools for managing a pool of XHRs.&quot;,&quot; */&quot;,null,&quot;/*global goog */&quot;,null,&quot;goog.require(&#39;bloombox.logging.error&#39;);&quot;,&quot;goog.require(&#39;bloombox.logging.log&#39;);&quot;,&quot;goog.require(&#39;bloombox.logging.warn&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.MAX_XHRs&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.OperationStatus&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.Routine&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.XHR_DEBOUNCE&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.XHR_RETRIES&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.XHR_TIMEOUT&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.internals.EventQueue&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.internals.HTTP_HEADERS&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.internals.LocalStats&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.internals.QueuedEvent&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.internals.active&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.internals.enabled&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.internals.statistics&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.telemetry.internals.stats.recordPing&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.internals.stats.recordRPCError&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.internals.stats.recordRPCSent&#39;);&quot;,&quot;goog.require(&#39;bloombox.telemetry.internals.stats.recordRPCSuccess&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.util.debounced&#39;);&quot;,null,&quot;goog.require(&#39;goog.net.XhrManager&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.telemetry.abort&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.enqueue&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.telemetry.internals._sendEvent&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.telemetry.internals.rpcpool.MAX_XHRs&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.internals.rpcpool.MIN_XHRs&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.internals.rpcpool.RPC_POOL&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.internals.rpcpool.WITH_CREDENTIALS&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.internals.rpcpool.XHR_RETRIES&#39;);&quot;,&quot;goog.provide(&#39;bloombox.telemetry.internals.rpcpool.XHR_TIMEOUT&#39;);&quot;,null,null,&quot;// - Constants and Types - //&quot;,&quot;/**&quot;,&quot; * Minimum number of XHRs to create.&quot;,&quot; *&quot;,&quot; * @const {number}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcpool.MIN_XHRs = 1;&quot;,null,null,&quot;/**&quot;,&quot; * Maximum number of XHRs to create.&quot;,&quot; *&quot;,&quot; * @const {number}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcpool.MAX_XHRs = bloombox.telemetry.MAX_XHRs;&quot;,null,null,&quot;/**&quot;,&quot; * Maximum number of retries.&quot;,&quot; *&quot;,&quot; * @const {number}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcpool.XHR_RETRIES = (&quot;,&quot;  bloombox.telemetry.XHR_RETRIES);&quot;,null,null,&quot;/**&quot;,&quot; * XHR timeout interval.&quot;,&quot; *&quot;,&quot; * @const {number}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcpool.XHR_TIMEOUT = (&quot;,&quot;  bloombox.telemetry.XHR_TIMEOUT);&quot;,null,null,&quot;/**&quot;,&quot; * Whether to include credentials in RPC requests.&quot;,&quot; *&quot;,&quot; * @const {boolean}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcpool.WITH_CREDENTIALS = false;&quot;,null,null,&quot;/**&quot;,&quot; * Value for maximum priority.&quot;,&quot; *&quot;,&quot; * @const {number}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcpool.MAX_PRIORITY = 5;&quot;,null,null,&quot;/**&quot;,&quot; * Value for elevated priority.&quot;,&quot; *&quot;,&quot; * @const {number}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcpool.ELEVATED_PRIORITY = 50;&quot;,null,null,&quot;/**&quot;,&quot; * Value for normal priority.&quot;,&quot; *&quot;,&quot; * @const {number}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcpool.NORMAL_PRIORITY = 100;&quot;,null,null,&quot;/**&quot;,&quot; * Value for minimum priority.&quot;,&quot; *&quot;,&quot; * @const {number}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcpool.MIN_PRIORITY = 999;&quot;,null,null,&quot;/**&quot;,&quot; * Value for impression data priority.&quot;,&quot; *&quot;,&quot; * @const {number}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcpool.IMPRESSION_PRIORITY = (&quot;,&quot;  bloombox.telemetry.internals.rpcpool.MIN_PRIORITY);&quot;,null,null,&quot;/**&quot;,&quot; * Value for view data priority.&quot;,&quot; *&quot;,&quot; * @const {number}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcpool.VIEW_PRIORITY = (&quot;,&quot;  bloombox.telemetry.internals.rpcpool.NORMAL_PRIORITY);&quot;,null,null,&quot;/**&quot;,&quot; * Value for conversion data priority.&quot;,&quot; *&quot;,&quot; * @const {number}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcpool.CONVERSION_PRIORITY = (&quot;,&quot;  bloombox.telemetry.internals.rpcpool.ELEVATED_PRIORITY);&quot;,null,null,&quot;/**&quot;,&quot; * Enumerates priority by RPC routine.&quot;,&quot; *&quot;,&quot; * @enum {number}&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.RoutinePriority = {&quot;,&quot;  &#39;PING&#39;: (&quot;,&quot;    bloombox.telemetry.internals.rpcpool.MAX_PRIORITY),&quot;,&quot;  &#39;EVENT&#39;: (&quot;,&quot;    bloombox.telemetry.internals.rpcpool.NORMAL_PRIORITY),&quot;,&quot;  &#39;EXCEPTION&#39;: (&quot;,&quot;    bloombox.telemetry.internals.rpcpool.ELEVATED_PRIORITY),&quot;,&quot;  &#39;SECTION_IMPRESSION&#39;: (&quot;,&quot;    bloombox.telemetry.internals.rpcpool.IMPRESSION_PRIORITY),&quot;,&quot;  &#39;SECTION_VIEW&#39;: (&quot;,&quot;    bloombox.telemetry.internals.rpcpool.VIEW_PRIORITY),&quot;,&quot;  &#39;SECTION_ACTION&#39;: (&quot;,&quot;    bloombox.telemetry.internals.rpcpool.CONVERSION_PRIORITY),&quot;,&quot;  &#39;PRODUCT_IMPRESSION&#39;: (&quot;,&quot;    bloombox.telemetry.internals.rpcpool.IMPRESSION_PRIORITY),&quot;,&quot;  &#39;PRODUCT_VIEW&#39;: (&quot;,&quot;    bloombox.telemetry.internals.rpcpool.VIEW_PRIORITY),&quot;,&quot;  &#39;PRODUCT_ACTION&#39;: (&quot;,&quot;    bloombox.telemetry.internals.rpcpool.CONVERSION_PRIORITY),&quot;,&quot;  &#39;ORDER_ACTION&#39;: (&quot;,&quot;    bloombox.telemetry.internals.rpcpool.CONVERSION_PRIORITY)&quot;,&quot;};&quot;,null,null,&quot;// - Internals - //&quot;,&quot;/**&quot;,&quot; * Main RPC pool for sending telemetry RPCs.&quot;,&quot; *&quot;,&quot; * @type {goog.net.XhrManager}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.RPC_POOL = new goog.net.XhrManager(&quot;,&quot;  bloombox.telemetry.internals.rpcpool.XHR_RETRIES,&quot;,&quot;  bloombox.telemetry.internals.HTTP_HEADERS,&quot;,&quot;  bloombox.telemetry.internals.rpcpool.MIN_XHRs,&quot;,&quot;  bloombox.telemetry.internals.rpcpool.MAX_XHRs,&quot;,&quot;  bloombox.telemetry.internals.rpcpool.XHR_TIMEOUT,&quot;,&quot;  bloombox.telemetry.internals.rpcpool.WITH_CREDENTIALS);&quot;,null,null,&quot;bloombox.telemetry.internals.RPC_POOL&quot;,&quot;  .setTimeoutInterval(bloombox.telemetry.internals.rpcpool.XHR_TIMEOUT);&quot;,null,null,&quot;/**&quot;,&quot; * Queue for events to be sent, eventually, via the RPC pool.&quot;,&quot; *&quot;,&quot; * @type {bloombox.telemetry.internals.EventQueue}&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.EVENT_QUEUE = (&quot;,&quot;  new bloombox.telemetry.internals.EventQueue());&quot;,null,null,&quot;// - Flush - //&quot;,&quot;/**&quot;,&quot; * Flush any queued events by sending them to the RPC pool. By default, this&quot;,&quot; * will follow the configured batching rules, unless `opt_all` is passed, in&quot;,&quot; * which case the system will try to flush all queued events at once.&quot;,&quot; *&quot;,&quot; * @param {boolean=} opt_all Optionally flush the entire queue.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.flush = function(opt_all) {&quot;,&quot;  let stats = bloombox.telemetry.internals.statistics();&quot;,&quot;  let amountToFetch = 0;&quot;,&quot;  if (opt_all) {&quot;,&quot;    // get queue count as count to fetch&quot;,&quot;    amountToFetch = stats.queued;&quot;,&quot;  }&quot;,&quot;  let dequeued = bloombox.telemetry.internals.EVENT_QUEUE.dequeue((&quot;,&quot;    function(queuedEvent) {&quot;,&quot;    // for each event that we de-queue,&quot;,&quot;    bloombox.telemetry.internals._sendEvent(queuedEvent);&quot;,&quot;      bloombox.telemetry.internals.stats.recordRPCSent();&quot;,&quot;  }), amountToFetch || null);&quot;,null,&quot;  if ((stats.queued - dequeued) &gt; 0) {&quot;,&quot;    // we have tasks remaining in the queue - perform at least one more tick&quot;,&quot;    bloombox.telemetry.internals.tick();&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Send a single event to the RPC pool.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.internals.QueuedEvent} queuedEvent Event to send.&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals._sendEvent = function(queuedEvent) {&quot;,&quot;  bloombox.logging.log(&quot;,&quot;    &#39;Sending telemetry event.&#39;, queuedEvent.uuid, queuedEvent.rpc);&quot;,&quot;  let rpc = queuedEvent.rpc;&quot;,&quot;  let boundCallback = bloombox.telemetry.internals.rpcCallback(queuedEvent);&quot;,null,&quot;  let serializedPayload = (rpc.payload ? JSON.stringify(rpc.payload) :&quot;,&quot;    undefined);&quot;,null,&quot;  if (rpc.rpcMethod === bloombox.telemetry.Routine.PING)&quot;,&quot;    bloombox.telemetry.internals.stats.recordPing();&quot;,null,&quot;  bloombox.telemetry.internals.RPC_POOL.send(&quot;,&quot;    queuedEvent.uuid,&quot;,&quot;    rpc.endpoint,&quot;,&quot;    rpc.httpMethod,&quot;,&quot;    serializedPayload,&quot;,&quot;    rpc.headers,&quot;,&quot;    queuedEvent.priority,&quot;,&quot;    boundCallback,&quot;,&quot;    bloombox.telemetry.internals.rpcpool.XHR_RETRIES,&quot;,&quot;    goog.net.XhrIo.ResponseType.TEXT,&quot;,&quot;    bloombox.telemetry.internals.rpcpool.WITH_CREDENTIALS);&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Prepare an RPC callback function.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.internals.QueuedEvent} queuedEvent Event being&quot;,&quot; *        called back for.&quot;,&quot; * @return {function(goog.events.Event)} Responder function.&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.rpcCallback = function(queuedEvent) {&quot;,&quot;  return respond;&quot;,null,&quot;  /**&quot;,&quot;   * Event responder.&quot;,&quot;   *&quot;,&quot;   * @param {goog.events.Event} event&quot;,&quot;   */&quot;,&quot;  function respond(event) {&quot;,&quot;    if (event.type === goog.net.EventType.COMPLETE) {&quot;,&quot;      let xhr = event.target;&quot;,&quot;      let contentType = xhr.getResponseHeader(&#39;Content-Type&#39;);&quot;,&quot;      let contentLength = xhr.getResponseHeader(&#39;Content-Length&#39;);&quot;,&quot;      let status = xhr.getStatus();&quot;,null,&quot;      // parse status&quot;,&quot;      if (status === 200 ||&quot;,&quot;          status === 201 ||&quot;,&quot;          status === 202 ||&quot;,&quot;          status === 204) {&quot;,&quot;        bloombox.logging.log(&#39;Finished telemetry RPC.&#39;,&quot;,&quot;          {&#39;queuedEvent&#39;: queuedEvent, &#39;event&#39;: event, &#39;xhr&#39;: xhr});&quot;,null,&quot;        if (!contentLength || parseInt(contentLength, 10) === 0) {&quot;,&quot;          // no response body but still successful&quot;,&quot;          let opStatus = bloombox.telemetry.OperationStatus.OK;&quot;,&quot;          queuedEvent.rpc.successCallback(opStatus);&quot;,&quot;        } else {&quot;,&quot;          // we have a response body&quot;,&quot;          if (contentType === &#39;application/json&#39; ||&quot;,&quot;              contentType.startsWith(&#39;application/json&#39;)) {&quot;,&quot;            let status = bloombox.telemetry.OperationStatus.OK;&quot;,&quot;            bloombox.telemetry.internals.stats.recordRPCSuccess();&quot;,&quot;            queuedEvent.rpc.successCallback(status);&quot;,&quot;          }&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    } else if (event.type === goog.net.EventType.ERROR) {&quot;,&quot;      let xhr = event.target;&quot;,&quot;      let status = xhr.getStatus();&quot;,null,&quot;      // the runtime reports that an error occurred&quot;,&quot;      bloombox.logging.error(&#39;An error occurred while fulfilling a telemetry &#39; +&quot;,&quot;                             &#39;service RPC.&#39;,&quot;,&quot;        {&#39;queuedEvent&#39;: queuedEvent, &#39;event&#39;: event, &#39;xhr&#39;: event.target});&quot;,&quot;      let opStatus = bloombox.telemetry.OperationStatus.ERROR;&quot;,&quot;      let err = bloombox.telemetry.TelemetryError.UNKNOWN;&quot;,&quot;      bloombox.telemetry.internals.stats.recordRPCError();&quot;,&quot;      queuedEvent.rpc.failureCallback(opStatus, err, status);&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;// - Tick - //&quot;,&quot;/**&quot;,&quot; * Internal tick dispatch function. Called when the debouncer is triggered.&quot;,&quot; *&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals._doTick = function() {&quot;,&quot;  // check if we are enabled&quot;,&quot;  if (bloombox.telemetry.internals.enabled()) {&quot;,&quot;    if (bloombox.telemetry.internals.active()) {&quot;,&quot;      // we are active and enabled. gather subsystem stats.&quot;,&quot;      let stats = bloombox.telemetry.internals.statistics();&quot;,&quot;      if (stats.queued &gt; 0) {&quot;,&quot;        // we have events to send&quot;,&quot;        if (bloombox.telemetry.internals.RPC_POOL.getOutstandingCount() &gt;= (&quot;,&quot;            bloombox.telemetry.internals.rpcpool.MAX_XHRs)) {&quot;,&quot;          // we already have the max number of XHRs. wait until the next tick.&quot;,&quot;          bloombox.telemetry.internals.tick();&quot;,&quot;        } else {&quot;,&quot;          // we can send events - we have space&quot;,&quot;          bloombox.telemetry.internals.flush();&quot;,&quot;        }&quot;,&quot;      } else {&quot;,&quot;        bloombox.logging.log(&#39;No telemetry RPCs to send.&#39;);&quot;,&quot;      }&quot;,&quot;    } else {&quot;,&quot;      bloombox.logging.log(&#39;Tick skipped: telemetry is not active.&#39;);&quot;,null,&quot;      // system is enabled but not active. wait until the next tick.&quot;,&quot;      bloombox.telemetry.internals.tick();&quot;,&quot;    }&quot;,&quot;  } else {&quot;,&quot;    bloombox.logging.warn(&#39;Tick skipped: telemetry is not enabled.&#39;);&quot;,&quot;  }&quot;,&quot;};&quot;,null,&quot;/**&quot;,&quot; * Advance the telemetry subsystem by one step. This involves checking if the&quot;,&quot; * pool has any room for work, then adding a batch of events to the pool if it&quot;,&quot; * does, or aborting if it doesn&#39;t.&quot;,&quot; *&quot;,&quot; * @package&quot;,&quot; */&quot;,&quot;bloombox.telemetry.internals.tick = bloombox.util.debounced(&quot;,&quot;  bloombox.telemetry.XHR_DEBOUNCE, function() {&quot;,&quot;  // perform one tick&quot;,&quot;  bloombox.telemetry.internals._doTick();&quot;,&quot;}, true);&quot;,null,null,&quot;// - Enqueue - //&quot;,&quot;/**&quot;,&quot; * Enqueue an event to eventually be sent.&quot;,&quot; *&quot;,&quot; * @param {bloombox.telemetry.rpc.TelemetryRPC} rpc Event RPC to enqueue.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.enqueue = function(rpc) {&quot;,&quot;  let priority = (&quot;,&quot;    bloombox.telemetry.internals.RoutinePriority[rpc.rpcMethod]);&quot;,&quot;  let ev = bloombox.telemetry.prepareQueuedEvent(rpc, priority);&quot;,null,&quot;  // enqueue the event&quot;,&quot;  bloombox.telemetry.internals.EVENT_QUEUE.enqueue(priority, ev);&quot;,null,&quot;  // trigger one tick&quot;,&quot;  bloombox.telemetry.internals.tick();&quot;,&quot;};&quot;,null,null,&quot;// - Abort - //&quot;,&quot;/**&quot;,&quot; * Abort an in-flight RPC by its UUID.&quot;,&quot; *&quot;,&quot; * @param {string} uuid UUID to abort.&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.telemetry.abort = function(uuid) {&quot;,&quot;  bloombox.telemetry.internals.RPC_POOL.abort(uuid);&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../../dossier.js" defer></script>