<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>rpc.js</title><link href="../../../dossier.css" rel="stylesheet" type="text/css"><script src="../../../types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,null,null,[&quot;rpc.js&quot;,&quot;src/base/rpc.js&quot;,[null,&quot;/*&quot;,&quot; * Copyright 2018, Bloombox, LLC.&quot;,&quot; *&quot;,&quot; * Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);&quot;,&quot; * you may not use this file except in compliance with the License.&quot;,&quot; * You may obtain a copy of the License at&quot;,&quot; *&quot;,&quot; *     http://www.apache.org/licenses/LICENSE-2.0&quot;,&quot; *&quot;,&quot; * Unless required by applicable law or agreed to in writing, software&quot;,&quot; * distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,&quot;,&quot; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;,&quot; * See the License for the specific language governing permissions and&quot;,&quot; * limitations under the License.&quot;,&quot; */&quot;,null,&quot;/**&quot;,&quot; * Bloombox JS: RPC Internals&quot;,&quot; *&quot;,&quot; * @fileoverview Provides low-level tools for RPCs.&quot;,&quot; */&quot;,null,&quot;/*global goog */&quot;,null,&quot;goog.provide(&#39;bloombox.rpc.ACCEPT_HEADER_VALUE&#39;);&quot;,&quot;goog.provide(&#39;bloombox.rpc.API_KEY_HEADER&#39;);&quot;,&quot;goog.provide(&#39;bloombox.rpc.DEBUG_HEADER&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.rpc.RPC&#39;);&quot;,&quot;goog.provide(&#39;bloombox.rpc.RPCException&#39;);&quot;,null,&quot;goog.provide(&#39;bloombox.rpc.TRACE_HEADER&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.DEBUG&#39;);&quot;,&quot;goog.require(&#39;bloombox.DEBUG_PROPERTY&#39;);&quot;,&quot;goog.require(&#39;bloombox.VERSION&#39;);&quot;,&quot;goog.require(&#39;bloombox.config.active&#39;);&quot;,null,&quot;goog.require(&#39;bloombox.logging.error&#39;);&quot;,&quot;goog.require(&#39;bloombox.logging.log&#39;);&quot;,&quot;goog.require(&#39;bloombox.logging.warn&#39;);&quot;,null,&quot;goog.require(&#39;goog.events&#39;);&quot;,&quot;goog.require(&#39;goog.net.XhrIo&#39;);&quot;,null,&quot;goog.require(&#39;stackdriver.reportError&#39;);&quot;,null,null,&quot;/**&quot;,&quot; * Exception object for the construction phase of an RPC. Usually thrown when&quot;,&quot; * no API key is present, or `setup` is not called before RPC methods.&quot;,&quot; *&quot;,&quot; * @param {string} message Message for the error.&quot;,&quot; * @constructor&quot;,&quot; * @export&quot;,&quot; */&quot;,&quot;bloombox.rpc.RPCException = function RPCException(message) {&quot;,&quot;  /**&quot;,&quot;   * Exception message.&quot;,&quot;   *&quot;,&quot;   * @type {string}&quot;,&quot;   */&quot;,&quot;  this.message = message;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Accepted content type for response payloads.&quot;,&quot; *&quot;,&quot; * @type {string}&quot;,&quot; * @const&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.rpc.ACCEPT_HEADER_VALUE = &#39;application/json,*/*&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * API key header.&quot;,&quot; *&quot;,&quot; * @type {string}&quot;,&quot; * @const&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.rpc.API_KEY_HEADER = &#39;X-Bloom-Key&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * Debug header.&quot;,&quot; *&quot;,&quot; * @type {string}&quot;,&quot; * @const&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.rpc.DEBUG_HEADER = &#39;X-Bloom-Debug&#39;;&quot;,null,null,&quot;/**&quot;,&quot; * Trace header.&quot;,&quot; *&quot;,&quot; * @type {string}&quot;,&quot; * @const&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.rpc.TRACE_HEADER = &#39;X-Bloom-Trace&#39;;&quot;,null,null,&quot;// noinspection JSUnusedGlobalSymbols&quot;,&quot;/**&quot;,&quot; * Show this exception&#39;s message.&quot;,&quot; *&quot;,&quot; * @return {string} Message for this exception.&quot;,&quot; */&quot;,&quot;bloombox.rpc.RPCException.prototype.toString = function() {&quot;,&quot;  return &#39;RPCException: &#39; + this.message;&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Return an `RPC` instance for a generic HTTP RPC call.&quot;,&quot; *&quot;,&quot; * @param {string} httpMethod HTTP method to use.&quot;,&quot; * @param {string} endpoint URL endpoint to send the RPC to.&quot;,&quot; * @param {?Object=} opt_payload Payload to use if we&#39;re POST-ing or PUT-ing.&quot;,&quot; * @param {string=} opt_trace Trace ID to specify for the RPC.&quot;,&quot; * @param {boolean=} opt_keep Whether to keep this RPC around.&quot;,&quot; * @constructor&quot;,&quot; * @struct&quot;,&quot; * @public&quot;,&quot; */&quot;,&quot;bloombox.rpc.RPC = function RPC(httpMethod,&quot;,&quot;                                endpoint,&quot;,&quot;                                opt_payload,&quot;,&quot;                                opt_trace,&quot;,&quot;                                opt_keep) {&quot;,&quot;  let config = bloombox.config.active();&quot;,&quot;  let apiKey = config.key;&quot;,&quot;  let partner = config.partner;&quot;,&quot;  let location = config.location;&quot;,&quot;  if (!apiKey || !(typeof apiKey === &#39;string&#39;))&quot;,&quot;    throw new bloombox.rpc.RPCException(&#39;API key could not be resolved.&#39; +&quot;,&quot;        &#39; Please call `setup` before any RPC methods.&#39;);&quot;,&quot;  if (!partner || !(typeof partner === &#39;string&#39;))&quot;,&quot;    throw new bloombox.rpc.RPCException(&#39;Partner code could not be resolved.&#39; +&quot;,&quot;        &#39; Please call `setup` before any RPC methods.&#39;);&quot;,&quot;  if (!location || !(typeof location === &#39;string&#39;))&quot;,&quot;    throw new bloombox.rpc.RPCException(&#39;Location code could not be resolved.&#39; +&quot;,&quot;        &#39; Please call `setup` before any RPC methods.&#39;);&quot;,&quot;  if ((typeof opt_payload !== &#39;object&#39;) &amp;&amp;&quot;,&quot;      opt_payload !== null &amp;&amp;&quot;,&quot;      opt_payload !== undefined)&quot;,&quot;    throw new bloombox.rpc.RPCException(&#39;Invalid payload for RPC: &#39; +&quot;,&quot;        opt_payload);&quot;,null,&quot;  /**&quot;,&quot;   * HTTP method for this RPC.&quot;,&quot;   *&quot;,&quot;   * @type {string}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.httpMethod = httpMethod;&quot;,null,&quot;  /**&quot;,&quot;   * Trace ID to set on this RPC.&quot;,&quot;   *&quot;,&quot;   * @type {?string}&quot;,&quot;   */&quot;,&quot;  this.trace = opt_trace || null;&quot;,null,&quot;  /**&quot;,&quot;   * Endpoint URL.&quot;,&quot;   *&quot;,&quot;   * @type {string}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.endpoint = endpoint;&quot;,null,&quot;  /**&quot;,&quot;   * Payload data for this RPC, if any.&quot;,&quot;   *&quot;,&quot;   * @type {?Object}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.payload = opt_payload || null;&quot;,null,&quot;  /**&quot;,&quot;   * RPC completion flag.&quot;,&quot;   *&quot;,&quot;   * @type {boolean}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.done = false;&quot;,null,&quot;  /**&quot;,&quot;   * Underlying XHR object.&quot;,&quot;   *&quot;,&quot;   * @type {?goog.net.XhrIo}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.xhr = new goog.net.XhrIo();&quot;,null,&quot;  /**&quot;,&quot;   * API key to use.&quot;,&quot;   *&quot;,&quot;   * @type {string}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.apiKey = apiKey;&quot;,null,&quot;  /**&quot;,&quot;   * Partner code.&quot;,&quot;   *&quot;,&quot;   * @type {string}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.partner = partner;&quot;,null,&quot;  /**&quot;,&quot;   * Location code.&quot;,&quot;   *&quot;,&quot;   * @type {string}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.location = location;&quot;,null,&quot;  /**&quot;,&quot;   * Flag to keep this RPC around for re-use. Defaults to `false`.&quot;,&quot;   *&quot;,&quot;   * @type {boolean}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.keep = opt_keep || false;&quot;,null,&quot;  /**&quot;,&quot;   * Headers to add.&quot;,&quot;   *&quot;,&quot;   * @type {Object}&quot;,&quot;   * @package&quot;,&quot;   */&quot;,&quot;  this.headers = {&quot;,&quot;    &#39;Accept&#39;: bloombox.rpc.ACCEPT_HEADER_VALUE&quot;,&quot;  };&quot;,null,&quot;  // attach debug header, if so-instructed&quot;,&quot;  if (bloombox.DEBUG || (window[bloombox.DEBUG_PROPERTY] === true))&quot;,&quot;    this.headers[&#39;X-Bloom-Debug&#39;] = &#39;debug&#39;;&quot;,null,&quot;  bloombox.logging.log(&#39;Constructed RPC for endpoint \\&#39;&#39; +&quot;,&quot;      this.endpoint + &#39;\\&#39;.&#39;, {&#39;rpc&#39;: this});&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * RPC onload callback.&quot;,&quot; *&quot;,&quot; * @param {function(?Object)} success Success callback to bind in.&quot;,&quot; * @param {function(?number=)} error Error callback to bind in.&quot;,&quot; * @return {function(goog.events.Event)} On-load callback function.&quot;,&quot; */&quot;,&quot;bloombox.rpc.RPC.prototype.onload = function(success, error) {&quot;,&quot;  return onload.bind(this);&quot;,null,&quot;  /**&quot;,&quot;   * @this {bloombox.rpc.RPC}&quot;,&quot;   * @param {goog.events.Event} event&quot;,&quot;   */&quot;,&quot;  function onload(event) {&quot;,&quot;    // if we&#39;re done, begin responding&quot;,&quot;    if (event &amp;&amp; this.done === false) {&quot;,&quot;      this.done = true;&quot;,&quot;      let contentType = this.xhr.getResponseHeader(&#39;Content-Type&#39;);&quot;,&quot;      let contentLength = this.xhr.getResponseHeader(&#39;Content-Length&#39;);&quot;,&quot;      try {&quot;,&quot;        let response = this.xhr.getResponseJson();&quot;,null,&quot;        // parse status&quot;,&quot;        let status = this.xhr.getStatus();&quot;,null,&quot;        if (status === 200 ||&quot;,&quot;          status === 201 ||&quot;,&quot;          status === 202 ||&quot;,&quot;          status === 204) {&quot;,&quot;          bloombox.logging.log(&#39;RPC received successful status &#39; +&quot;,&quot;            status, {&#39;xhr&#39;: this.xhr});&quot;,null,&quot;          if (!response &amp;&amp;&quot;,&quot;            (!contentLength || parseInt(contentLength, 10) === 0)) {&quot;,&quot;            // no response body means a successful transaction, technically&quot;,&quot;            bloombox.logging.warn(&quot;,&quot;              &#39;Response returned for RPC was empty or invalid.&#39;, this);&quot;,&quot;            success(null);&quot;,&quot;          } else {&quot;,&quot;            if (contentType === &#39;application/json&#39; ||&quot;,&quot;              contentType.startsWith(&#39;application/json&#39;)) {&quot;,&quot;              bloombox.logging.log(&quot;,&quot;                &#39;Loaded payload for successful RPC transaction.&#39;,&quot;,&quot;                {&#39;rpc&#39;: this, &#39;response&#39;: response});&quot;,&quot;              success(/** @type {Object} */ (response));&quot;,&quot;            } else {&quot;,&quot;              bloombox.logging.error(&quot;,&quot;                &#39;Server indicated unrecognized content type:&#39;,&quot;,&quot;                contentType);&quot;,&quot;              error(null);&quot;,&quot;            }&quot;,&quot;          }&quot;,&quot;        } else {&quot;,&quot;          // some error event i.e. unrecognized status code&quot;,&quot;          bloombox.logging.error(&#39;Failed to resolve RPC: unrecognized status &#39; +&quot;,&quot;            status, {&#39;xhr&#39;: this.xhr, &#39;status&#39;: status});&quot;,&quot;          let err = new Error(&quot;,&quot;            &#39;RPC Error: \&quot;&#39; + this.httpMethod + &#39; &#39; + this.endpoint + &#39;\&quot;\\n&#39; +&quot;,&quot;            &#39;Status: &#39; + status.toString() + &#39;\\n&#39; +&quot;,&quot;            &#39;Failure code: &#39; + this.xhr.getLastErrorCode() + &#39;\\n&#39; +&quot;,&quot;            &#39;Failure reason: &#39; + this.xhr.getLastError() + &#39;\\n&#39; +&quot;,&quot;            &#39;Key: &#39; + this.apiKey);&quot;,&quot;          err.code = status || this.xhr.getLastErrorCode() || -1;&quot;,&quot;          stackdriver.reportError(err);&quot;,&quot;          error(status);&quot;,&quot;        }&quot;,&quot;        if (!this.keep) this.xhr = null;&quot;,&quot;      } catch (err) {&quot;,&quot;        // catch invalid JSON&quot;,&quot;        if (err instanceof Error) {&quot;,&quot;          if (err.message.toLowerCase().indexOf(&#39;invalid json&#39;) !== -1) {&quot;,&quot;            // json parse error&quot;,&quot;            err.code = this.xhr.getLastErrorCode() || -1;&quot;,&quot;            err.message = &#39;RPC failed with error \\&#39;&#39; + (err.name || &#39;UNKNOWN&#39;) +&quot;,&quot;              &#39;\\&#39;.\\nEndpoint: &#39; + this.endpoint +&quot;,&quot;              &#39;\\nFailure code: &#39; + this.xhr.getLastErrorCode() +&quot;,&quot;              &#39;\\nFailure reason: &#39; + this.xhr.getLastError() +&quot;,&quot;              &#39;\\nResponse: \&quot;&#39; + this.xhr.getResponseText() + &#39;\&quot;.&#39;;&quot;,null,&quot;            bloombox.logging.error(&#39;Failed to resolve RPC.&#39;, {&quot;,&quot;              &#39;xhr&#39;: this.xhr,&quot;,&quot;              &#39;error&#39;: err&quot;,&quot;            });&quot;,&quot;            stackdriver.reportError(err);&quot;,&quot;          }&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,&quot;};&quot;,null,null,&quot;/**&quot;,&quot; * Send a prepared RPC.&quot;,&quot; *&quot;,&quot; * @param {function(?Object)} callback Callback to dispatch once we&#39;re done.&quot;,&quot; * @param {function(?number=)} error Error callback.&quot;,&quot; * @throws {bloombox.rpc.RPCException} If `send` is called twice and this&quot;,&quot; *         XHR has already send and `keep` is falsy.&quot;,&quot; */&quot;,&quot;bloombox.rpc.RPC.prototype.send = function(callback, error) {&quot;,&quot;  if (this.xhr === null)&quot;,&quot;    throw new bloombox.rpc.RPCException(&quot;,&quot;      &#39;Cannot re-send an already-sent RPC without \\&#39;keep\\&#39; mode active.&#39;);&quot;,null,&quot;  // check API key&quot;,&quot;  if (!this.apiKey)&quot;,&quot;    throw new bloombox.rpc.RPCException(&quot;,&quot;      &#39;Failed to resolve API key before request.&#39;);&quot;,&quot;  if (!this.partner)&quot;,&quot;    throw new bloombox.rpc.RPCException(&quot;,&quot;      &#39;Partner was not set.&#39;);&quot;,&quot;  if (!this.location)&quot;,&quot;    throw new bloombox.rpc.RPCException(&quot;,&quot;      &#39;Location was not set.&#39;);&quot;,null,&quot;  // attach the on-load handler&quot;,&quot;  goog.events.listen(&quot;,&quot;    this.xhr,&quot;,&quot;    goog.net.EventType.COMPLETE,&quot;,&quot;    this.onload(callback.bind(this), error.bind(this)));&quot;,null,&quot;  // open the XHR&quot;,&quot;  let targetEndpoint = [&quot;,&quot;    this.endpoint, [&#39;key&#39;, this.apiKey].join(&#39;=&#39;)].join(&#39;?&#39;);&quot;,&quot;  bloombox.logging.log(&#39;Initializing RPC with HTTP request: \\&#39;&#39; +&quot;,&quot;      this.httpMethod + &#39; &#39; + targetEndpoint + &#39;\\&#39;&#39;);&quot;,null,&quot;  // attach headers&quot;,&quot;  if (bloombox.DEBUG) {&quot;,&quot;    for (let key in this.headers) {&quot;,&quot;      if (this.headers.hasOwnProperty(key)) {&quot;,&quot;        let context = {};&quot;,&quot;        context[key] = this.headers[key];&quot;,&quot;        bloombox.logging.log(&#39;Setting request header: &#39;, context);&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;  }&quot;,null,&quot;  bloombox.logging.log(&#39;Sending RPC...&#39;, this);&quot;,null,&quot;  // JSON-encode data if we have it to send&quot;,&quot;  let payloadData = this.payload !== null ? JSON.stringify(this.payload) : null;&quot;,null,&quot;  let overrideHeaders = {};&quot;,null,&quot;  // set the trace header if so-instructed&quot;,&quot;  if (this.trace)&quot;,&quot;    overrideHeaders[bloombox.rpc.TRACE_HEADER] = this.trace;&quot;,null,&quot;  // same with the debug headers&quot;,&quot;  if (bloombox.DEBUG || (window[bloombox.DEBUG_PROPERTY] === true))&quot;,&quot;    this.headers[&#39;X-Bloom-Debug&#39;] = &#39;debug&#39;;&quot;,null,&quot;  let finalizedHeaders = Object.assign({}, this.headers, overrideHeaders);&quot;,null,&quot;  // send the underlying XHR&quot;,&quot;  this.xhr.send(&quot;,&quot;    targetEndpoint,&quot;,&quot;    this.httpMethod,&quot;,&quot;    payloadData,&quot;,&quot;    finalizedHeaders);&quot;,&quot;};&quot;]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="../../../dossier.js" defer></script>